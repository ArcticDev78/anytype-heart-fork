// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/lib/pb/model/protos/models.proto

package model

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SmartBlockType int32

const (
	SmartBlockType_Breadcrumbs         SmartBlockType = 0
	SmartBlockType_Page                SmartBlockType = 16
	SmartBlockType_ProfilePage         SmartBlockType = 17
	SmartBlockType_Home                SmartBlockType = 32
	SmartBlockType_Archive             SmartBlockType = 48
	SmartBlockType_Database            SmartBlockType = 64
	SmartBlockType_Set                 SmartBlockType = 65
	SmartBlockType_STObjectType        SmartBlockType = 96
	SmartBlockType_File                SmartBlockType = 256
	SmartBlockType_Template            SmartBlockType = 288
	SmartBlockType_BundledTemplate     SmartBlockType = 289
	SmartBlockType_MarketplaceType     SmartBlockType = 272
	SmartBlockType_MarketplaceRelation SmartBlockType = 273
	SmartBlockType_MarketplaceTemplate SmartBlockType = 274
	SmartBlockType_BundledRelation     SmartBlockType = 512
	SmartBlockType_IndexedRelation     SmartBlockType = 513
	SmartBlockType_BundledObjectType   SmartBlockType = 514
	SmartBlockType_AnytypeProfile      SmartBlockType = 515
)

var SmartBlockType_name = map[int32]string{
	0:   "Breadcrumbs",
	16:  "Page",
	17:  "ProfilePage",
	32:  "Home",
	48:  "Archive",
	64:  "Database",
	65:  "Set",
	96:  "STObjectType",
	256: "File",
	288: "Template",
	289: "BundledTemplate",
	272: "MarketplaceType",
	273: "MarketplaceRelation",
	274: "MarketplaceTemplate",
	512: "BundledRelation",
	513: "IndexedRelation",
	514: "BundledObjectType",
	515: "AnytypeProfile",
}

var SmartBlockType_value = map[string]int32{
	"Breadcrumbs":         0,
	"Page":                16,
	"ProfilePage":         17,
	"Home":                32,
	"Archive":             48,
	"Database":            64,
	"Set":                 65,
	"STObjectType":        96,
	"File":                256,
	"Template":            288,
	"BundledTemplate":     289,
	"MarketplaceType":     272,
	"MarketplaceRelation": 273,
	"MarketplaceTemplate": 274,
	"BundledRelation":     512,
	"IndexedRelation":     513,
	"BundledObjectType":   514,
	"AnytypeProfile":      515,
}

func (x SmartBlockType) String() string {
	return proto.EnumName(SmartBlockType_name, int32(x))
}

func (SmartBlockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{0}
}

// RelationFormat describes how the underlying data is stored in the google.protobuf.Value and how it should be validated/sanitized
type RelationFormat int32

const (
	RelationFormat_longtext  RelationFormat = 0
	RelationFormat_shorttext RelationFormat = 1
	RelationFormat_number    RelationFormat = 2
	RelationFormat_status    RelationFormat = 3
	RelationFormat_tag       RelationFormat = 11
	RelationFormat_date      RelationFormat = 4
	RelationFormat_file      RelationFormat = 5
	RelationFormat_checkbox  RelationFormat = 6
	RelationFormat_url       RelationFormat = 7
	RelationFormat_email     RelationFormat = 8
	RelationFormat_phone     RelationFormat = 9
	RelationFormat_emoji     RelationFormat = 10
	RelationFormat_object    RelationFormat = 100
	RelationFormat_relations RelationFormat = 101
)

var RelationFormat_name = map[int32]string{
	0:   "longtext",
	1:   "shorttext",
	2:   "number",
	3:   "status",
	11:  "tag",
	4:   "date",
	5:   "file",
	6:   "checkbox",
	7:   "url",
	8:   "email",
	9:   "phone",
	10:  "emoji",
	100: "object",
	101: "relations",
}

var RelationFormat_value = map[string]int32{
	"longtext":  0,
	"shorttext": 1,
	"number":    2,
	"status":    3,
	"tag":       11,
	"date":      4,
	"file":      5,
	"checkbox":  6,
	"url":       7,
	"email":     8,
	"phone":     9,
	"emoji":     10,
	"object":    100,
	"relations": 101,
}

func (x RelationFormat) String() string {
	return proto.EnumName(RelationFormat_name, int32(x))
}

func (RelationFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1}
}

type BlockPosition int32

const (
	Block_None    BlockPosition = 0
	Block_Top     BlockPosition = 1
	Block_Bottom  BlockPosition = 2
	Block_Left    BlockPosition = 3
	Block_Right   BlockPosition = 4
	Block_Inner   BlockPosition = 5
	Block_Replace BlockPosition = 6
)

var BlockPosition_name = map[int32]string{
	0: "None",
	1: "Top",
	2: "Bottom",
	3: "Left",
	4: "Right",
	5: "Inner",
	6: "Replace",
}

var BlockPosition_value = map[string]int32{
	"None":    0,
	"Top":     1,
	"Bottom":  2,
	"Left":    3,
	"Right":   4,
	"Inner":   5,
	"Replace": 6,
}

func (x BlockPosition) String() string {
	return proto.EnumName(BlockPosition_name, int32(x))
}

func (BlockPosition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 0}
}

type BlockAlign int32

const (
	Block_AlignLeft   BlockAlign = 0
	Block_AlignCenter BlockAlign = 1
	Block_AlignRight  BlockAlign = 2
)

var BlockAlign_name = map[int32]string{
	0: "AlignLeft",
	1: "AlignCenter",
	2: "AlignRight",
}

var BlockAlign_value = map[string]int32{
	"AlignLeft":   0,
	"AlignCenter": 1,
	"AlignRight":  2,
}

func (x BlockAlign) String() string {
	return proto.EnumName(BlockAlign_name, int32(x))
}

func (BlockAlign) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1}
}

type BlockContentLayoutStyle int32

const (
	BlockContentLayout_Row    BlockContentLayoutStyle = 0
	BlockContentLayout_Column BlockContentLayoutStyle = 1
	BlockContentLayout_Div    BlockContentLayoutStyle = 2
	BlockContentLayout_Header BlockContentLayoutStyle = 3
)

var BlockContentLayoutStyle_name = map[int32]string{
	0: "Row",
	1: "Column",
	2: "Div",
	3: "Header",
}

var BlockContentLayoutStyle_value = map[string]int32{
	"Row":    0,
	"Column": 1,
	"Div":    2,
	"Header": 3,
}

func (x BlockContentLayoutStyle) String() string {
	return proto.EnumName(BlockContentLayoutStyle_name, int32(x))
}

func (BlockContentLayoutStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 0, 0}
}

type BlockContentLinkStyle int32

const (
	BlockContentLink_Page      BlockContentLinkStyle = 0
	BlockContentLink_Dataview  BlockContentLinkStyle = 1
	BlockContentLink_Dashboard BlockContentLinkStyle = 2
	BlockContentLink_Archive   BlockContentLinkStyle = 3
)

var BlockContentLinkStyle_name = map[int32]string{
	0: "Page",
	1: "Dataview",
	2: "Dashboard",
	3: "Archive",
}

var BlockContentLinkStyle_value = map[string]int32{
	"Page":      0,
	"Dataview":  1,
	"Dashboard": 2,
	"Archive":   3,
}

func (x BlockContentLinkStyle) String() string {
	return proto.EnumName(BlockContentLinkStyle_name, int32(x))
}

func (BlockContentLinkStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 1, 0}
}

type BlockContentDivStyle int32

const (
	BlockContentDiv_Line BlockContentDivStyle = 0
	BlockContentDiv_Dots BlockContentDivStyle = 1
)

var BlockContentDivStyle_name = map[int32]string{
	0: "Line",
	1: "Dots",
}

var BlockContentDivStyle_value = map[string]int32{
	"Line": 0,
	"Dots": 1,
}

func (x BlockContentDivStyle) String() string {
	return proto.EnumName(BlockContentDivStyle_name, int32(x))
}

func (BlockContentDivStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 2, 0}
}

type BlockContentTextStyle int32

const (
	BlockContentText_Paragraph   BlockContentTextStyle = 0
	BlockContentText_Header1     BlockContentTextStyle = 1
	BlockContentText_Header2     BlockContentTextStyle = 2
	BlockContentText_Header3     BlockContentTextStyle = 3
	BlockContentText_Header4     BlockContentTextStyle = 4
	BlockContentText_Quote       BlockContentTextStyle = 5
	BlockContentText_Code        BlockContentTextStyle = 6
	BlockContentText_Title       BlockContentTextStyle = 7
	BlockContentText_Checkbox    BlockContentTextStyle = 8
	BlockContentText_Marked      BlockContentTextStyle = 9
	BlockContentText_Numbered    BlockContentTextStyle = 10
	BlockContentText_Toggle      BlockContentTextStyle = 11
	BlockContentText_Description BlockContentTextStyle = 12
)

var BlockContentTextStyle_name = map[int32]string{
	0:  "Paragraph",
	1:  "Header1",
	2:  "Header2",
	3:  "Header3",
	4:  "Header4",
	5:  "Quote",
	6:  "Code",
	7:  "Title",
	8:  "Checkbox",
	9:  "Marked",
	10: "Numbered",
	11: "Toggle",
	12: "Description",
}

var BlockContentTextStyle_value = map[string]int32{
	"Paragraph":   0,
	"Header1":     1,
	"Header2":     2,
	"Header3":     3,
	"Header4":     4,
	"Quote":       5,
	"Code":        6,
	"Title":       7,
	"Checkbox":    8,
	"Marked":      9,
	"Numbered":    10,
	"Toggle":      11,
	"Description": 12,
}

func (x BlockContentTextStyle) String() string {
	return proto.EnumName(BlockContentTextStyle_name, int32(x))
}

func (BlockContentTextStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 6, 0}
}

type BlockContentTextMarkType int32

const (
	BlockContentTextMark_Strikethrough   BlockContentTextMarkType = 0
	BlockContentTextMark_Keyboard        BlockContentTextMarkType = 1
	BlockContentTextMark_Italic          BlockContentTextMarkType = 2
	BlockContentTextMark_Bold            BlockContentTextMarkType = 3
	BlockContentTextMark_Underscored     BlockContentTextMarkType = 4
	BlockContentTextMark_Link            BlockContentTextMarkType = 5
	BlockContentTextMark_TextColor       BlockContentTextMarkType = 6
	BlockContentTextMark_BackgroundColor BlockContentTextMarkType = 7
	BlockContentTextMark_Mention         BlockContentTextMarkType = 8
)

var BlockContentTextMarkType_name = map[int32]string{
	0: "Strikethrough",
	1: "Keyboard",
	2: "Italic",
	3: "Bold",
	4: "Underscored",
	5: "Link",
	6: "TextColor",
	7: "BackgroundColor",
	8: "Mention",
}

var BlockContentTextMarkType_value = map[string]int32{
	"Strikethrough":   0,
	"Keyboard":        1,
	"Italic":          2,
	"Bold":            3,
	"Underscored":     4,
	"Link":            5,
	"TextColor":       6,
	"BackgroundColor": 7,
	"Mention":         8,
}

func (x BlockContentTextMarkType) String() string {
	return proto.EnumName(BlockContentTextMarkType_name, int32(x))
}

func (BlockContentTextMarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 6, 1, 0}
}

type BlockContentFileType int32

const (
	BlockContentFile_None  BlockContentFileType = 0
	BlockContentFile_File  BlockContentFileType = 1
	BlockContentFile_Image BlockContentFileType = 2
	BlockContentFile_Video BlockContentFileType = 3
)

var BlockContentFileType_name = map[int32]string{
	0: "None",
	1: "File",
	2: "Image",
	3: "Video",
}

var BlockContentFileType_value = map[string]int32{
	"None":  0,
	"File":  1,
	"Image": 2,
	"Video": 3,
}

func (x BlockContentFileType) String() string {
	return proto.EnumName(BlockContentFileType_name, int32(x))
}

func (BlockContentFileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 7, 0}
}

type BlockContentFileState int32

const (
	BlockContentFile_Empty     BlockContentFileState = 0
	BlockContentFile_Uploading BlockContentFileState = 1
	BlockContentFile_Done      BlockContentFileState = 2
	BlockContentFile_Error     BlockContentFileState = 3
)

var BlockContentFileState_name = map[int32]string{
	0: "Empty",
	1: "Uploading",
	2: "Done",
	3: "Error",
}

var BlockContentFileState_value = map[string]int32{
	"Empty":     0,
	"Uploading": 1,
	"Done":      2,
	"Error":     3,
}

func (x BlockContentFileState) String() string {
	return proto.EnumName(BlockContentFileState_name, int32(x))
}

func (BlockContentFileState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 7, 1}
}

type BlockContentDataviewViewType int32

const (
	BlockContentDataviewView_Table   BlockContentDataviewViewType = 0
	BlockContentDataviewView_List    BlockContentDataviewViewType = 1
	BlockContentDataviewView_Gallery BlockContentDataviewViewType = 2
	BlockContentDataviewView_Kanban  BlockContentDataviewViewType = 3
)

var BlockContentDataviewViewType_name = map[int32]string{
	0: "Table",
	1: "List",
	2: "Gallery",
	3: "Kanban",
}

var BlockContentDataviewViewType_value = map[string]int32{
	"Table":   0,
	"List":    1,
	"Gallery": 2,
	"Kanban":  3,
}

func (x BlockContentDataviewViewType) String() string {
	return proto.EnumName(BlockContentDataviewViewType_name, int32(x))
}

func (BlockContentDataviewViewType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 0, 0}
}

type BlockContentDataviewRelationDateFormat int32

const (
	BlockContentDataviewRelation_MonthAbbrBeforeDay BlockContentDataviewRelationDateFormat = 0
	BlockContentDataviewRelation_MonthAbbrAfterDay  BlockContentDataviewRelationDateFormat = 1
	BlockContentDataviewRelation_Short              BlockContentDataviewRelationDateFormat = 2
	BlockContentDataviewRelation_ShortUS            BlockContentDataviewRelationDateFormat = 3
	BlockContentDataviewRelation_ISO                BlockContentDataviewRelationDateFormat = 4
)

var BlockContentDataviewRelationDateFormat_name = map[int32]string{
	0: "MonthAbbrBeforeDay",
	1: "MonthAbbrAfterDay",
	2: "Short",
	3: "ShortUS",
	4: "ISO",
}

var BlockContentDataviewRelationDateFormat_value = map[string]int32{
	"MonthAbbrBeforeDay": 0,
	"MonthAbbrAfterDay":  1,
	"Short":              2,
	"ShortUS":            3,
	"ISO":                4,
}

func (x BlockContentDataviewRelationDateFormat) String() string {
	return proto.EnumName(BlockContentDataviewRelationDateFormat_name, int32(x))
}

func (BlockContentDataviewRelationDateFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 1, 0}
}

type BlockContentDataviewRelationTimeFormat int32

const (
	BlockContentDataviewRelation_Format12 BlockContentDataviewRelationTimeFormat = 0
	BlockContentDataviewRelation_Format24 BlockContentDataviewRelationTimeFormat = 1
)

var BlockContentDataviewRelationTimeFormat_name = map[int32]string{
	0: "Format12",
	1: "Format24",
}

var BlockContentDataviewRelationTimeFormat_value = map[string]int32{
	"Format12": 0,
	"Format24": 1,
}

func (x BlockContentDataviewRelationTimeFormat) String() string {
	return proto.EnumName(BlockContentDataviewRelationTimeFormat_name, int32(x))
}

func (BlockContentDataviewRelationTimeFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 1, 1}
}

type BlockContentDataviewSortType int32

const (
	BlockContentDataviewSort_Asc  BlockContentDataviewSortType = 0
	BlockContentDataviewSort_Desc BlockContentDataviewSortType = 1
)

var BlockContentDataviewSortType_name = map[int32]string{
	0: "Asc",
	1: "Desc",
}

var BlockContentDataviewSortType_value = map[string]int32{
	"Asc":  0,
	"Desc": 1,
}

func (x BlockContentDataviewSortType) String() string {
	return proto.EnumName(BlockContentDataviewSortType_name, int32(x))
}

func (BlockContentDataviewSortType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 2, 0}
}

type BlockContentDataviewFilterOperator int32

const (
	BlockContentDataviewFilter_And BlockContentDataviewFilterOperator = 0
	BlockContentDataviewFilter_Or  BlockContentDataviewFilterOperator = 1
)

var BlockContentDataviewFilterOperator_name = map[int32]string{
	0: "And",
	1: "Or",
}

var BlockContentDataviewFilterOperator_value = map[string]int32{
	"And": 0,
	"Or":  1,
}

func (x BlockContentDataviewFilterOperator) String() string {
	return proto.EnumName(BlockContentDataviewFilterOperator_name, int32(x))
}

func (BlockContentDataviewFilterOperator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 3, 0}
}

type BlockContentDataviewFilterCondition int32

const (
	BlockContentDataviewFilter_None           BlockContentDataviewFilterCondition = 0
	BlockContentDataviewFilter_Equal          BlockContentDataviewFilterCondition = 1
	BlockContentDataviewFilter_NotEqual       BlockContentDataviewFilterCondition = 2
	BlockContentDataviewFilter_Greater        BlockContentDataviewFilterCondition = 3
	BlockContentDataviewFilter_Less           BlockContentDataviewFilterCondition = 4
	BlockContentDataviewFilter_GreaterOrEqual BlockContentDataviewFilterCondition = 5
	BlockContentDataviewFilter_LessOrEqual    BlockContentDataviewFilterCondition = 6
	BlockContentDataviewFilter_Like           BlockContentDataviewFilterCondition = 7
	BlockContentDataviewFilter_NotLike        BlockContentDataviewFilterCondition = 8
	BlockContentDataviewFilter_In             BlockContentDataviewFilterCondition = 9
	BlockContentDataviewFilter_NotIn          BlockContentDataviewFilterCondition = 10
	BlockContentDataviewFilter_Empty          BlockContentDataviewFilterCondition = 11
	BlockContentDataviewFilter_NotEmpty       BlockContentDataviewFilterCondition = 12
	BlockContentDataviewFilter_AllIn          BlockContentDataviewFilterCondition = 13
	BlockContentDataviewFilter_NotAllIn       BlockContentDataviewFilterCondition = 14
)

var BlockContentDataviewFilterCondition_name = map[int32]string{
	0:  "None",
	1:  "Equal",
	2:  "NotEqual",
	3:  "Greater",
	4:  "Less",
	5:  "GreaterOrEqual",
	6:  "LessOrEqual",
	7:  "Like",
	8:  "NotLike",
	9:  "In",
	10: "NotIn",
	11: "Empty",
	12: "NotEmpty",
	13: "AllIn",
	14: "NotAllIn",
}

var BlockContentDataviewFilterCondition_value = map[string]int32{
	"None":           0,
	"Equal":          1,
	"NotEqual":       2,
	"Greater":        3,
	"Less":           4,
	"GreaterOrEqual": 5,
	"LessOrEqual":    6,
	"Like":           7,
	"NotLike":        8,
	"In":             9,
	"NotIn":          10,
	"Empty":          11,
	"NotEmpty":       12,
	"AllIn":          13,
	"NotAllIn":       14,
}

func (x BlockContentDataviewFilterCondition) String() string {
	return proto.EnumName(BlockContentDataviewFilterCondition_name, int32(x))
}

func (BlockContentDataviewFilterCondition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 3, 1}
}

type LinkPreviewType int32

const (
	LinkPreview_Unknown LinkPreviewType = 0
	LinkPreview_Page    LinkPreviewType = 1
	LinkPreview_Image   LinkPreviewType = 2
	LinkPreview_Text    LinkPreviewType = 3
)

var LinkPreviewType_name = map[int32]string{
	0: "Unknown",
	1: "Page",
	2: "Image",
	3: "Text",
}

var LinkPreviewType_value = map[string]int32{
	"Unknown": 0,
	"Page":    1,
	"Image":   2,
	"Text":    3,
}

func (x LinkPreviewType) String() string {
	return proto.EnumName(LinkPreviewType_name, int32(x))
}

func (LinkPreviewType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{5, 0}
}

type RestrictionsObjectRestriction int32

const (
	Restrictions_None RestrictionsObjectRestriction = 0
	// restricts delete
	Restrictions_Delete RestrictionsObjectRestriction = 1
	// restricts work with relations
	Restrictions_Relations RestrictionsObjectRestriction = 2
	// restricts work with blocks
	Restrictions_Blocks RestrictionsObjectRestriction = 3
	// restricts work with details
	Restrictions_Details      RestrictionsObjectRestriction = 4
	Restrictions_TypeChange   RestrictionsObjectRestriction = 5
	Restrictions_LayoutChange RestrictionsObjectRestriction = 6
	Restrictions_Template     RestrictionsObjectRestriction = 7
)

var RestrictionsObjectRestriction_name = map[int32]string{
	0: "None",
	1: "Delete",
	2: "Relations",
	3: "Blocks",
	4: "Details",
	5: "TypeChange",
	6: "LayoutChange",
	7: "Template",
}

var RestrictionsObjectRestriction_value = map[string]int32{
	"None":         0,
	"Delete":       1,
	"Relations":    2,
	"Blocks":       3,
	"Details":      4,
	"TypeChange":   5,
	"LayoutChange": 6,
	"Template":     7,
}

func (x RestrictionsObjectRestriction) String() string {
	return proto.EnumName(RestrictionsObjectRestriction_name, int32(x))
}

func (RestrictionsObjectRestriction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{6, 0}
}

type RestrictionsDataviewRestriction int32

const (
	Restrictions_DVNone         RestrictionsDataviewRestriction = 0
	Restrictions_DVRelation     RestrictionsDataviewRestriction = 1
	Restrictions_DVCreateObject RestrictionsDataviewRestriction = 2
	Restrictions_DVViews        RestrictionsDataviewRestriction = 3
)

var RestrictionsDataviewRestriction_name = map[int32]string{
	0: "DVNone",
	1: "DVRelation",
	2: "DVCreateObject",
	3: "DVViews",
}

var RestrictionsDataviewRestriction_value = map[string]int32{
	"DVNone":         0,
	"DVRelation":     1,
	"DVCreateObject": 2,
	"DVViews":        3,
}

func (x RestrictionsDataviewRestriction) String() string {
	return proto.EnumName(RestrictionsDataviewRestriction_name, int32(x))
}

func (RestrictionsDataviewRestriction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{6, 1}
}

type ObjectTypeLayout int32

const (
	ObjectType_basic      ObjectTypeLayout = 0
	ObjectType_profile    ObjectTypeLayout = 1
	ObjectType_todo       ObjectTypeLayout = 2
	ObjectType_set        ObjectTypeLayout = 3
	ObjectType_objectType ObjectTypeLayout = 4
	ObjectType_relation   ObjectTypeLayout = 5
	ObjectType_file       ObjectTypeLayout = 6
	ObjectType_dashboard  ObjectTypeLayout = 7
	ObjectType_image      ObjectTypeLayout = 8
	ObjectType_database   ObjectTypeLayout = 20
)

var ObjectTypeLayout_name = map[int32]string{
	0:  "basic",
	1:  "profile",
	2:  "todo",
	3:  "set",
	4:  "objectType",
	5:  "relation",
	6:  "file",
	7:  "dashboard",
	8:  "image",
	20: "database",
}

var ObjectTypeLayout_value = map[string]int32{
	"basic":      0,
	"profile":    1,
	"todo":       2,
	"set":        3,
	"objectType": 4,
	"relation":   5,
	"file":       6,
	"dashboard":  7,
	"image":      8,
	"database":   20,
}

func (x ObjectTypeLayout) String() string {
	return proto.EnumName(ObjectTypeLayout_name, int32(x))
}

func (ObjectTypeLayout) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{7, 0}
}

type RelationScope int32

const (
	Relation_object               RelationScope = 0
	Relation_type                 RelationScope = 1
	Relation_setOfTheSameType     RelationScope = 2
	Relation_objectsOfTheSameType RelationScope = 3
	Relation_library              RelationScope = 4
)

var RelationScope_name = map[int32]string{
	0: "object",
	1: "type",
	2: "setOfTheSameType",
	3: "objectsOfTheSameType",
	4: "library",
}

var RelationScope_value = map[string]int32{
	"object":               0,
	"type":                 1,
	"setOfTheSameType":     2,
	"objectsOfTheSameType": 3,
	"library":              4,
}

func (x RelationScope) String() string {
	return proto.EnumName(RelationScope_name, int32(x))
}

func (RelationScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{10, 0}
}

type RelationDataSource int32

const (
	Relation_details RelationDataSource = 0
	Relation_derived RelationDataSource = 1
	Relation_account RelationDataSource = 2
)

var RelationDataSource_name = map[int32]string{
	0: "details",
	1: "derived",
	2: "account",
}

var RelationDataSource_value = map[string]int32{
	"details": 0,
	"derived": 1,
	"account": 2,
}

func (x RelationDataSource) String() string {
	return proto.EnumName(RelationDataSource_name, int32(x))
}

func (RelationDataSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{10, 1}
}

type RelationOptionScope int32

const (
	RelationOption_local    RelationOptionScope = 0
	RelationOption_relation RelationOptionScope = 1
	RelationOption_format   RelationOptionScope = 2
)

var RelationOptionScope_name = map[int32]string{
	0: "local",
	1: "relation",
	2: "format",
}

var RelationOptionScope_value = map[string]int32{
	"local":    0,
	"relation": 1,
	"format":   2,
}

func (x RelationOptionScope) String() string {
	return proto.EnumName(RelationOptionScope_name, int32(x))
}

func (RelationOptionScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{10, 0, 0}
}

type SmartBlockSnapshotBase struct {
	Blocks         []*Block      `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
	Details        *types.Struct `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	FileKeys       *types.Struct `protobuf:"bytes,3,opt,name=fileKeys,proto3" json:"fileKeys,omitempty"`
	ExtraRelations []*Relation   `protobuf:"bytes,4,rep,name=extraRelations,proto3" json:"extraRelations,omitempty"`
	ObjectTypes    []string      `protobuf:"bytes,5,rep,name=objectTypes,proto3" json:"objectTypes,omitempty"`
}

func (m *SmartBlockSnapshotBase) Reset()         { *m = SmartBlockSnapshotBase{} }
func (m *SmartBlockSnapshotBase) String() string { return proto.CompactTextString(m) }
func (*SmartBlockSnapshotBase) ProtoMessage()    {}
func (*SmartBlockSnapshotBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{0}
}
func (m *SmartBlockSnapshotBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SmartBlockSnapshotBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SmartBlockSnapshotBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SmartBlockSnapshotBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmartBlockSnapshotBase.Merge(m, src)
}
func (m *SmartBlockSnapshotBase) XXX_Size() int {
	return m.Size()
}
func (m *SmartBlockSnapshotBase) XXX_DiscardUnknown() {
	xxx_messageInfo_SmartBlockSnapshotBase.DiscardUnknown(m)
}

var xxx_messageInfo_SmartBlockSnapshotBase proto.InternalMessageInfo

func (m *SmartBlockSnapshotBase) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *SmartBlockSnapshotBase) GetDetails() *types.Struct {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *SmartBlockSnapshotBase) GetFileKeys() *types.Struct {
	if m != nil {
		return m.FileKeys
	}
	return nil
}

func (m *SmartBlockSnapshotBase) GetExtraRelations() []*Relation {
	if m != nil {
		return m.ExtraRelations
	}
	return nil
}

func (m *SmartBlockSnapshotBase) GetObjectTypes() []string {
	if m != nil {
		return m.ObjectTypes
	}
	return nil
}

type Block struct {
	Id              string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields          *types.Struct      `protobuf:"bytes,2,opt,name=fields,proto3" json:"fields,omitempty"`
	Restrictions    *BlockRestrictions `protobuf:"bytes,3,opt,name=restrictions,proto3" json:"restrictions,omitempty"`
	ChildrenIds     []string           `protobuf:"bytes,4,rep,name=childrenIds,proto3" json:"childrenIds,omitempty"`
	BackgroundColor string             `protobuf:"bytes,5,opt,name=backgroundColor,proto3" json:"backgroundColor,omitempty"`
	Align           BlockAlign         `protobuf:"varint,6,opt,name=align,proto3,enum=anytype.model.BlockAlign" json:"align,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*BlockContentOfSmartblock
	//	*BlockContentOfText
	//	*BlockContentOfFile
	//	*BlockContentOfLayout
	//	*BlockContentOfDiv
	//	*BlockContentOfBookmark
	//	*BlockContentOfIcon
	//	*BlockContentOfLink
	//	*BlockContentOfDataview
	//	*BlockContentOfRelation
	//	*BlockContentOfFeaturedRelations
	Content IsBlockContent `protobuf_oneof:"content"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

type IsBlockContent interface {
	IsBlockContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BlockContentOfSmartblock struct {
	Smartblock *BlockContentSmartblock `protobuf:"bytes,11,opt,name=smartblock,proto3,oneof" json:"smartblock,omitempty"`
}
type BlockContentOfText struct {
	Text *BlockContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type BlockContentOfFile struct {
	File *BlockContentFile `protobuf:"bytes,15,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type BlockContentOfLayout struct {
	Layout *BlockContentLayout `protobuf:"bytes,16,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type BlockContentOfDiv struct {
	Div *BlockContentDiv `protobuf:"bytes,17,opt,name=div,proto3,oneof" json:"div,omitempty"`
}
type BlockContentOfBookmark struct {
	Bookmark *BlockContentBookmark `protobuf:"bytes,18,opt,name=bookmark,proto3,oneof" json:"bookmark,omitempty"`
}
type BlockContentOfIcon struct {
	Icon *BlockContentIcon `protobuf:"bytes,19,opt,name=icon,proto3,oneof" json:"icon,omitempty"`
}
type BlockContentOfLink struct {
	Link *BlockContentLink `protobuf:"bytes,20,opt,name=link,proto3,oneof" json:"link,omitempty"`
}
type BlockContentOfDataview struct {
	Dataview *BlockContentDataview `protobuf:"bytes,21,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type BlockContentOfRelation struct {
	Relation *BlockContentRelation `protobuf:"bytes,22,opt,name=relation,proto3,oneof" json:"relation,omitempty"`
}
type BlockContentOfFeaturedRelations struct {
	FeaturedRelations *BlockContentFeaturedRelations `protobuf:"bytes,23,opt,name=featuredRelations,proto3,oneof" json:"featuredRelations,omitempty"`
}

func (*BlockContentOfSmartblock) IsBlockContent()        {}
func (*BlockContentOfText) IsBlockContent()              {}
func (*BlockContentOfFile) IsBlockContent()              {}
func (*BlockContentOfLayout) IsBlockContent()            {}
func (*BlockContentOfDiv) IsBlockContent()               {}
func (*BlockContentOfBookmark) IsBlockContent()          {}
func (*BlockContentOfIcon) IsBlockContent()              {}
func (*BlockContentOfLink) IsBlockContent()              {}
func (*BlockContentOfDataview) IsBlockContent()          {}
func (*BlockContentOfRelation) IsBlockContent()          {}
func (*BlockContentOfFeaturedRelations) IsBlockContent() {}

func (m *Block) GetContent() IsBlockContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Block) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block) GetFields() *types.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Block) GetRestrictions() *BlockRestrictions {
	if m != nil {
		return m.Restrictions
	}
	return nil
}

func (m *Block) GetChildrenIds() []string {
	if m != nil {
		return m.ChildrenIds
	}
	return nil
}

func (m *Block) GetBackgroundColor() string {
	if m != nil {
		return m.BackgroundColor
	}
	return ""
}

func (m *Block) GetAlign() BlockAlign {
	if m != nil {
		return m.Align
	}
	return Block_AlignLeft
}

func (m *Block) GetSmartblock() *BlockContentSmartblock {
	if x, ok := m.GetContent().(*BlockContentOfSmartblock); ok {
		return x.Smartblock
	}
	return nil
}

func (m *Block) GetText() *BlockContentText {
	if x, ok := m.GetContent().(*BlockContentOfText); ok {
		return x.Text
	}
	return nil
}

func (m *Block) GetFile() *BlockContentFile {
	if x, ok := m.GetContent().(*BlockContentOfFile); ok {
		return x.File
	}
	return nil
}

func (m *Block) GetLayout() *BlockContentLayout {
	if x, ok := m.GetContent().(*BlockContentOfLayout); ok {
		return x.Layout
	}
	return nil
}

func (m *Block) GetDiv() *BlockContentDiv {
	if x, ok := m.GetContent().(*BlockContentOfDiv); ok {
		return x.Div
	}
	return nil
}

func (m *Block) GetBookmark() *BlockContentBookmark {
	if x, ok := m.GetContent().(*BlockContentOfBookmark); ok {
		return x.Bookmark
	}
	return nil
}

func (m *Block) GetIcon() *BlockContentIcon {
	if x, ok := m.GetContent().(*BlockContentOfIcon); ok {
		return x.Icon
	}
	return nil
}

func (m *Block) GetLink() *BlockContentLink {
	if x, ok := m.GetContent().(*BlockContentOfLink); ok {
		return x.Link
	}
	return nil
}

func (m *Block) GetDataview() *BlockContentDataview {
	if x, ok := m.GetContent().(*BlockContentOfDataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *Block) GetRelation() *BlockContentRelation {
	if x, ok := m.GetContent().(*BlockContentOfRelation); ok {
		return x.Relation
	}
	return nil
}

func (m *Block) GetFeaturedRelations() *BlockContentFeaturedRelations {
	if x, ok := m.GetContent().(*BlockContentOfFeaturedRelations); ok {
		return x.FeaturedRelations
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Block) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BlockContentOfSmartblock)(nil),
		(*BlockContentOfText)(nil),
		(*BlockContentOfFile)(nil),
		(*BlockContentOfLayout)(nil),
		(*BlockContentOfDiv)(nil),
		(*BlockContentOfBookmark)(nil),
		(*BlockContentOfIcon)(nil),
		(*BlockContentOfLink)(nil),
		(*BlockContentOfDataview)(nil),
		(*BlockContentOfRelation)(nil),
		(*BlockContentOfFeaturedRelations)(nil),
	}
}

type BlockRestrictions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *BlockRestrictions) Reset()         { *m = BlockRestrictions{} }
func (m *BlockRestrictions) String() string { return proto.CompactTextString(m) }
func (*BlockRestrictions) ProtoMessage()    {}
func (*BlockRestrictions) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 0}
}
func (m *BlockRestrictions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRestrictions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRestrictions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRestrictions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRestrictions.Merge(m, src)
}
func (m *BlockRestrictions) XXX_Size() int {
	return m.Size()
}
func (m *BlockRestrictions) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRestrictions.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRestrictions proto.InternalMessageInfo

func (m *BlockRestrictions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *BlockRestrictions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *BlockRestrictions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *BlockRestrictions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *BlockRestrictions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type BlockContent struct {
}

func (m *BlockContent) Reset()         { *m = BlockContent{} }
func (m *BlockContent) String() string { return proto.CompactTextString(m) }
func (*BlockContent) ProtoMessage()    {}
func (*BlockContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1}
}
func (m *BlockContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContent.Merge(m, src)
}
func (m *BlockContent) XXX_Size() int {
	return m.Size()
}
func (m *BlockContent) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContent.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContent proto.InternalMessageInfo

//
// Layout have no visual representation, but affects on blocks, that it contains.
// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
type BlockContentLayout struct {
	Style BlockContentLayoutStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.model.BlockContentLayoutStyle" json:"style,omitempty"`
}

func (m *BlockContentLayout) Reset()         { *m = BlockContentLayout{} }
func (m *BlockContentLayout) String() string { return proto.CompactTextString(m) }
func (*BlockContentLayout) ProtoMessage()    {}
func (*BlockContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 0}
}
func (m *BlockContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentLayout.Merge(m, src)
}
func (m *BlockContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentLayout proto.InternalMessageInfo

func (m *BlockContentLayout) GetStyle() BlockContentLayoutStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentLayout_Row
}

//
// Link: block to link some content from an external sources.
type BlockContentLink struct {
	TargetBlockId string                `protobuf:"bytes,1,opt,name=targetBlockId,proto3" json:"targetBlockId,omitempty"`
	Style         BlockContentLinkStyle `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.model.BlockContentLinkStyle" json:"style,omitempty"`
	Fields        *types.Struct         `protobuf:"bytes,3,opt,name=fields,proto3" json:"fields,omitempty"`
}

func (m *BlockContentLink) Reset()         { *m = BlockContentLink{} }
func (m *BlockContentLink) String() string { return proto.CompactTextString(m) }
func (*BlockContentLink) ProtoMessage()    {}
func (*BlockContentLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 1}
}
func (m *BlockContentLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentLink.Merge(m, src)
}
func (m *BlockContentLink) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentLink) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentLink.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentLink proto.InternalMessageInfo

func (m *BlockContentLink) GetTargetBlockId() string {
	if m != nil {
		return m.TargetBlockId
	}
	return ""
}

func (m *BlockContentLink) GetStyle() BlockContentLinkStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentLink_Page
}

func (m *BlockContentLink) GetFields() *types.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

//
// Divider: block, that contains only one horizontal thin line
type BlockContentDiv struct {
	Style BlockContentDivStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.model.BlockContentDivStyle" json:"style,omitempty"`
}

func (m *BlockContentDiv) Reset()         { *m = BlockContentDiv{} }
func (m *BlockContentDiv) String() string { return proto.CompactTextString(m) }
func (*BlockContentDiv) ProtoMessage()    {}
func (*BlockContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 2}
}
func (m *BlockContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDiv.Merge(m, src)
}
func (m *BlockContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDiv proto.InternalMessageInfo

func (m *BlockContentDiv) GetStyle() BlockContentDivStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentDiv_Line
}

//
// Bookmark is to keep a web-link and to preview a content.
type BlockContentBookmark struct {
	Url         string          `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Title       string          `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description string          `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	ImageHash   string          `protobuf:"bytes,4,opt,name=imageHash,proto3" json:"imageHash,omitempty"`
	FaviconHash string          `protobuf:"bytes,5,opt,name=faviconHash,proto3" json:"faviconHash,omitempty"`
	Type        LinkPreviewType `protobuf:"varint,6,opt,name=type,proto3,enum=anytype.model.LinkPreviewType" json:"type,omitempty"`
}

func (m *BlockContentBookmark) Reset()         { *m = BlockContentBookmark{} }
func (m *BlockContentBookmark) String() string { return proto.CompactTextString(m) }
func (*BlockContentBookmark) ProtoMessage()    {}
func (*BlockContentBookmark) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 3}
}
func (m *BlockContentBookmark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentBookmark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentBookmark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentBookmark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentBookmark.Merge(m, src)
}
func (m *BlockContentBookmark) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentBookmark) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentBookmark.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentBookmark proto.InternalMessageInfo

func (m *BlockContentBookmark) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *BlockContentBookmark) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BlockContentBookmark) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BlockContentBookmark) GetImageHash() string {
	if m != nil {
		return m.ImageHash
	}
	return ""
}

func (m *BlockContentBookmark) GetFaviconHash() string {
	if m != nil {
		return m.FaviconHash
	}
	return ""
}

func (m *BlockContentBookmark) GetType() LinkPreviewType {
	if m != nil {
		return m.Type
	}
	return LinkPreview_Unknown
}

type BlockContentIcon struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *BlockContentIcon) Reset()         { *m = BlockContentIcon{} }
func (m *BlockContentIcon) String() string { return proto.CompactTextString(m) }
func (*BlockContentIcon) ProtoMessage()    {}
func (*BlockContentIcon) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 4}
}
func (m *BlockContentIcon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentIcon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentIcon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentIcon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentIcon.Merge(m, src)
}
func (m *BlockContentIcon) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentIcon) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentIcon.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentIcon proto.InternalMessageInfo

func (m *BlockContentIcon) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BlockContentFeaturedRelations struct {
}

func (m *BlockContentFeaturedRelations) Reset()         { *m = BlockContentFeaturedRelations{} }
func (m *BlockContentFeaturedRelations) String() string { return proto.CompactTextString(m) }
func (*BlockContentFeaturedRelations) ProtoMessage()    {}
func (*BlockContentFeaturedRelations) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 5}
}
func (m *BlockContentFeaturedRelations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFeaturedRelations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFeaturedRelations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFeaturedRelations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFeaturedRelations.Merge(m, src)
}
func (m *BlockContentFeaturedRelations) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFeaturedRelations) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFeaturedRelations.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFeaturedRelations proto.InternalMessageInfo

type BlockContentText struct {
	Text    string                 `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style   BlockContentTextStyle  `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.model.BlockContentTextStyle" json:"style,omitempty"`
	Marks   *BlockContentTextMarks `protobuf:"bytes,3,opt,name=marks,proto3" json:"marks,omitempty"`
	Checked bool                   `protobuf:"varint,4,opt,name=checked,proto3" json:"checked,omitempty"`
	Color   string                 `protobuf:"bytes,5,opt,name=color,proto3" json:"color,omitempty"`
}

func (m *BlockContentText) Reset()         { *m = BlockContentText{} }
func (m *BlockContentText) String() string { return proto.CompactTextString(m) }
func (*BlockContentText) ProtoMessage()    {}
func (*BlockContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 6}
}
func (m *BlockContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentText.Merge(m, src)
}
func (m *BlockContentText) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentText.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentText proto.InternalMessageInfo

func (m *BlockContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *BlockContentText) GetStyle() BlockContentTextStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentText_Paragraph
}

func (m *BlockContentText) GetMarks() *BlockContentTextMarks {
	if m != nil {
		return m.Marks
	}
	return nil
}

func (m *BlockContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

func (m *BlockContentText) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

type BlockContentTextMarks struct {
	Marks []*BlockContentTextMark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *BlockContentTextMarks) Reset()         { *m = BlockContentTextMarks{} }
func (m *BlockContentTextMarks) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMarks) ProtoMessage()    {}
func (*BlockContentTextMarks) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 6, 0}
}
func (m *BlockContentTextMarks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMarks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMarks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMarks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMarks.Merge(m, src)
}
func (m *BlockContentTextMarks) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMarks) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMarks.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMarks proto.InternalMessageInfo

func (m *BlockContentTextMarks) GetMarks() []*BlockContentTextMark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type BlockContentTextMark struct {
	Range *Range                   `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  BlockContentTextMarkType `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.model.BlockContentTextMarkType" json:"type,omitempty"`
	Param string                   `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *BlockContentTextMark) Reset()         { *m = BlockContentTextMark{} }
func (m *BlockContentTextMark) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMark) ProtoMessage()    {}
func (*BlockContentTextMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 6, 1}
}
func (m *BlockContentTextMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMark.Merge(m, src)
}
func (m *BlockContentTextMark) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMark) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMark.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMark proto.InternalMessageInfo

func (m *BlockContentTextMark) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *BlockContentTextMark) GetType() BlockContentTextMarkType {
	if m != nil {
		return m.Type
	}
	return BlockContentTextMark_Strikethrough
}

func (m *BlockContentTextMark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type BlockContentFile struct {
	Hash    string                `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Name    string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Type    BlockContentFileType  `protobuf:"varint,3,opt,name=type,proto3,enum=anytype.model.BlockContentFileType" json:"type,omitempty"`
	Mime    string                `protobuf:"bytes,4,opt,name=mime,proto3" json:"mime,omitempty"`
	Size_   int64                 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	AddedAt int64                 `protobuf:"varint,6,opt,name=addedAt,proto3" json:"addedAt,omitempty"`
	State   BlockContentFileState `protobuf:"varint,7,opt,name=state,proto3,enum=anytype.model.BlockContentFileState" json:"state,omitempty"`
}

func (m *BlockContentFile) Reset()         { *m = BlockContentFile{} }
func (m *BlockContentFile) String() string { return proto.CompactTextString(m) }
func (*BlockContentFile) ProtoMessage()    {}
func (*BlockContentFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 7}
}
func (m *BlockContentFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFile.Merge(m, src)
}
func (m *BlockContentFile) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFile) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFile.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFile proto.InternalMessageInfo

func (m *BlockContentFile) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *BlockContentFile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentFile) GetType() BlockContentFileType {
	if m != nil {
		return m.Type
	}
	return BlockContentFile_None
}

func (m *BlockContentFile) GetMime() string {
	if m != nil {
		return m.Mime
	}
	return ""
}

func (m *BlockContentFile) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *BlockContentFile) GetAddedAt() int64 {
	if m != nil {
		return m.AddedAt
	}
	return 0
}

func (m *BlockContentFile) GetState() BlockContentFileState {
	if m != nil {
		return m.State
	}
	return BlockContentFile_Empty
}

type BlockContentSmartblock struct {
}

func (m *BlockContentSmartblock) Reset()         { *m = BlockContentSmartblock{} }
func (m *BlockContentSmartblock) String() string { return proto.CompactTextString(m) }
func (*BlockContentSmartblock) ProtoMessage()    {}
func (*BlockContentSmartblock) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 8}
}
func (m *BlockContentSmartblock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentSmartblock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentSmartblock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentSmartblock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentSmartblock.Merge(m, src)
}
func (m *BlockContentSmartblock) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentSmartblock) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentSmartblock.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentSmartblock proto.InternalMessageInfo

type BlockContentDataview struct {
	Source string                      `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Views  []*BlockContentDataviewView `protobuf:"bytes,2,rep,name=views,proto3" json:"views,omitempty"`
	// index 3 is deprecated, was used for schemaURL in old-format sets
	Relations  []*Relation `protobuf:"bytes,4,rep,name=relations,proto3" json:"relations,omitempty"`
	ActiveView string      `protobuf:"bytes,3,opt,name=activeView,proto3" json:"activeView,omitempty"`
}

func (m *BlockContentDataview) Reset()         { *m = BlockContentDataview{} }
func (m *BlockContentDataview) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataview) ProtoMessage()    {}
func (*BlockContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9}
}
func (m *BlockContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataview.Merge(m, src)
}
func (m *BlockContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataview proto.InternalMessageInfo

func (m *BlockContentDataview) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *BlockContentDataview) GetViews() []*BlockContentDataviewView {
	if m != nil {
		return m.Views
	}
	return nil
}

func (m *BlockContentDataview) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *BlockContentDataview) GetActiveView() string {
	if m != nil {
		return m.ActiveView
	}
	return ""
}

type BlockContentDataviewView struct {
	Id        string                          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type      BlockContentDataviewViewType    `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.model.BlockContentDataviewViewType" json:"type,omitempty"`
	Name      string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Sorts     []*BlockContentDataviewSort     `protobuf:"bytes,4,rep,name=sorts,proto3" json:"sorts,omitempty"`
	Filters   []*BlockContentDataviewFilter   `protobuf:"bytes,5,rep,name=filters,proto3" json:"filters,omitempty"`
	Relations []*BlockContentDataviewRelation `protobuf:"bytes,6,rep,name=relations,proto3" json:"relations,omitempty"`
}

func (m *BlockContentDataviewView) Reset()         { *m = BlockContentDataviewView{} }
func (m *BlockContentDataviewView) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataviewView) ProtoMessage()    {}
func (*BlockContentDataviewView) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 0}
}
func (m *BlockContentDataviewView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataviewView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataviewView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataviewView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataviewView.Merge(m, src)
}
func (m *BlockContentDataviewView) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataviewView) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataviewView.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataviewView proto.InternalMessageInfo

func (m *BlockContentDataviewView) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BlockContentDataviewView) GetType() BlockContentDataviewViewType {
	if m != nil {
		return m.Type
	}
	return BlockContentDataviewView_Table
}

func (m *BlockContentDataviewView) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentDataviewView) GetSorts() []*BlockContentDataviewSort {
	if m != nil {
		return m.Sorts
	}
	return nil
}

func (m *BlockContentDataviewView) GetFilters() []*BlockContentDataviewFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *BlockContentDataviewView) GetRelations() []*BlockContentDataviewRelation {
	if m != nil {
		return m.Relations
	}
	return nil
}

type BlockContentDataviewRelation struct {
	Key             string                                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	IsVisible       bool                                   `protobuf:"varint,2,opt,name=isVisible,proto3" json:"isVisible,omitempty"`
	Width           int32                                  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	DateIncludeTime bool                                   `protobuf:"varint,5,opt,name=dateIncludeTime,proto3" json:"dateIncludeTime,omitempty"`
	TimeFormat      BlockContentDataviewRelationTimeFormat `protobuf:"varint,6,opt,name=timeFormat,proto3,enum=anytype.model.BlockContentDataviewRelationTimeFormat" json:"timeFormat,omitempty"`
	DateFormat      BlockContentDataviewRelationDateFormat `protobuf:"varint,7,opt,name=dateFormat,proto3,enum=anytype.model.BlockContentDataviewRelationDateFormat" json:"dateFormat,omitempty"`
}

func (m *BlockContentDataviewRelation) Reset()         { *m = BlockContentDataviewRelation{} }
func (m *BlockContentDataviewRelation) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataviewRelation) ProtoMessage()    {}
func (*BlockContentDataviewRelation) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 1}
}
func (m *BlockContentDataviewRelation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataviewRelation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataviewRelation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataviewRelation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataviewRelation.Merge(m, src)
}
func (m *BlockContentDataviewRelation) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataviewRelation) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataviewRelation.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataviewRelation proto.InternalMessageInfo

func (m *BlockContentDataviewRelation) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *BlockContentDataviewRelation) GetIsVisible() bool {
	if m != nil {
		return m.IsVisible
	}
	return false
}

func (m *BlockContentDataviewRelation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *BlockContentDataviewRelation) GetDateIncludeTime() bool {
	if m != nil {
		return m.DateIncludeTime
	}
	return false
}

func (m *BlockContentDataviewRelation) GetTimeFormat() BlockContentDataviewRelationTimeFormat {
	if m != nil {
		return m.TimeFormat
	}
	return BlockContentDataviewRelation_Format12
}

func (m *BlockContentDataviewRelation) GetDateFormat() BlockContentDataviewRelationDateFormat {
	if m != nil {
		return m.DateFormat
	}
	return BlockContentDataviewRelation_MonthAbbrBeforeDay
}

type BlockContentDataviewSort struct {
	RelationKey string                       `protobuf:"bytes,1,opt,name=RelationKey,proto3" json:"RelationKey,omitempty"`
	Type        BlockContentDataviewSortType `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.model.BlockContentDataviewSortType" json:"type,omitempty"`
}

func (m *BlockContentDataviewSort) Reset()         { *m = BlockContentDataviewSort{} }
func (m *BlockContentDataviewSort) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataviewSort) ProtoMessage()    {}
func (*BlockContentDataviewSort) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 2}
}
func (m *BlockContentDataviewSort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataviewSort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataviewSort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataviewSort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataviewSort.Merge(m, src)
}
func (m *BlockContentDataviewSort) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataviewSort) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataviewSort.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataviewSort proto.InternalMessageInfo

func (m *BlockContentDataviewSort) GetRelationKey() string {
	if m != nil {
		return m.RelationKey
	}
	return ""
}

func (m *BlockContentDataviewSort) GetType() BlockContentDataviewSortType {
	if m != nil {
		return m.Type
	}
	return BlockContentDataviewSort_Asc
}

type BlockContentDataviewFilter struct {
	Operator         BlockContentDataviewFilterOperator  `protobuf:"varint,1,opt,name=operator,proto3,enum=anytype.model.BlockContentDataviewFilterOperator" json:"operator,omitempty"`
	RelationKey      string                              `protobuf:"bytes,2,opt,name=RelationKey,proto3" json:"RelationKey,omitempty"`
	RelationProperty string                              `protobuf:"bytes,5,opt,name=relationProperty,proto3" json:"relationProperty,omitempty"`
	Condition        BlockContentDataviewFilterCondition `protobuf:"varint,3,opt,name=condition,proto3,enum=anytype.model.BlockContentDataviewFilterCondition" json:"condition,omitempty"`
	Value            *types.Value                        `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *BlockContentDataviewFilter) Reset()         { *m = BlockContentDataviewFilter{} }
func (m *BlockContentDataviewFilter) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataviewFilter) ProtoMessage()    {}
func (*BlockContentDataviewFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 9, 3}
}
func (m *BlockContentDataviewFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataviewFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataviewFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataviewFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataviewFilter.Merge(m, src)
}
func (m *BlockContentDataviewFilter) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataviewFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataviewFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataviewFilter proto.InternalMessageInfo

func (m *BlockContentDataviewFilter) GetOperator() BlockContentDataviewFilterOperator {
	if m != nil {
		return m.Operator
	}
	return BlockContentDataviewFilter_And
}

func (m *BlockContentDataviewFilter) GetRelationKey() string {
	if m != nil {
		return m.RelationKey
	}
	return ""
}

func (m *BlockContentDataviewFilter) GetRelationProperty() string {
	if m != nil {
		return m.RelationProperty
	}
	return ""
}

func (m *BlockContentDataviewFilter) GetCondition() BlockContentDataviewFilterCondition {
	if m != nil {
		return m.Condition
	}
	return BlockContentDataviewFilter_None
}

func (m *BlockContentDataviewFilter) GetValue() *types.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type BlockContentRelation struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *BlockContentRelation) Reset()         { *m = BlockContentRelation{} }
func (m *BlockContentRelation) String() string { return proto.CompactTextString(m) }
func (*BlockContentRelation) ProtoMessage()    {}
func (*BlockContentRelation) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{1, 1, 10}
}
func (m *BlockContentRelation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentRelation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentRelation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentRelation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentRelation.Merge(m, src)
}
func (m *BlockContentRelation) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentRelation) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentRelation.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentRelation proto.InternalMessageInfo

func (m *BlockContentRelation) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

//
// Used to decode block meta only, without the content itself
type BlockMetaOnly struct {
	Id     string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields *types.Struct `protobuf:"bytes,2,opt,name=fields,proto3" json:"fields,omitempty"`
}

func (m *BlockMetaOnly) Reset()         { *m = BlockMetaOnly{} }
func (m *BlockMetaOnly) String() string { return proto.CompactTextString(m) }
func (*BlockMetaOnly) ProtoMessage()    {}
func (*BlockMetaOnly) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{2}
}
func (m *BlockMetaOnly) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMetaOnly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockMetaOnly.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockMetaOnly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMetaOnly.Merge(m, src)
}
func (m *BlockMetaOnly) XXX_Size() int {
	return m.Size()
}
func (m *BlockMetaOnly) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMetaOnly.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMetaOnly proto.InternalMessageInfo

func (m *BlockMetaOnly) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BlockMetaOnly) GetFields() *types.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

//
// General purpose structure, uses in Mark.
type Range struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{3}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Range) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

//*
// Contains basic information about a user account
type Account struct {
	Id     string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Avatar *AccountAvatar `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{4}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Account) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account) GetAvatar() *AccountAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

//*
// Avatar of a user's account. It could be an image or color
type AccountAvatar struct {
	// Types that are valid to be assigned to Avatar:
	//	*AccountAvatarAvatarOfImage
	//	*AccountAvatarAvatarOfColor
	Avatar IsAccountAvatarAvatar `protobuf_oneof:"avatar"`
}

func (m *AccountAvatar) Reset()         { *m = AccountAvatar{} }
func (m *AccountAvatar) String() string { return proto.CompactTextString(m) }
func (*AccountAvatar) ProtoMessage()    {}
func (*AccountAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{4, 0}
}
func (m *AccountAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountAvatar.Merge(m, src)
}
func (m *AccountAvatar) XXX_Size() int {
	return m.Size()
}
func (m *AccountAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_AccountAvatar proto.InternalMessageInfo

type IsAccountAvatarAvatar interface {
	IsAccountAvatarAvatar()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AccountAvatarAvatarOfImage struct {
	Image *BlockContentFile `protobuf:"bytes,1,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type AccountAvatarAvatarOfColor struct {
	Color string `protobuf:"bytes,2,opt,name=color,proto3,oneof" json:"color,omitempty"`
}

func (*AccountAvatarAvatarOfImage) IsAccountAvatarAvatar() {}
func (*AccountAvatarAvatarOfColor) IsAccountAvatarAvatar() {}

func (m *AccountAvatar) GetAvatar() IsAccountAvatarAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *AccountAvatar) GetImage() *BlockContentFile {
	if x, ok := m.GetAvatar().(*AccountAvatarAvatarOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *AccountAvatar) GetColor() string {
	if x, ok := m.GetAvatar().(*AccountAvatarAvatarOfColor); ok {
		return x.Color
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AccountAvatar) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AccountAvatarAvatarOfImage)(nil),
		(*AccountAvatarAvatarOfColor)(nil),
	}
}

type LinkPreview struct {
	Url         string          `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Title       string          `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description string          `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	ImageUrl    string          `protobuf:"bytes,4,opt,name=imageUrl,proto3" json:"imageUrl,omitempty"`
	FaviconUrl  string          `protobuf:"bytes,5,opt,name=faviconUrl,proto3" json:"faviconUrl,omitempty"`
	Type        LinkPreviewType `protobuf:"varint,6,opt,name=type,proto3,enum=anytype.model.LinkPreviewType" json:"type,omitempty"`
}

func (m *LinkPreview) Reset()         { *m = LinkPreview{} }
func (m *LinkPreview) String() string { return proto.CompactTextString(m) }
func (*LinkPreview) ProtoMessage()    {}
func (*LinkPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{5}
}
func (m *LinkPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkPreview.Merge(m, src)
}
func (m *LinkPreview) XXX_Size() int {
	return m.Size()
}
func (m *LinkPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkPreview.DiscardUnknown(m)
}

var xxx_messageInfo_LinkPreview proto.InternalMessageInfo

func (m *LinkPreview) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *LinkPreview) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *LinkPreview) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *LinkPreview) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

func (m *LinkPreview) GetFaviconUrl() string {
	if m != nil {
		return m.FaviconUrl
	}
	return ""
}

func (m *LinkPreview) GetType() LinkPreviewType {
	if m != nil {
		return m.Type
	}
	return LinkPreview_Unknown
}

type Restrictions struct {
	Object   []RestrictionsObjectRestriction     `protobuf:"varint,1,rep,packed,name=object,proto3,enum=anytype.model.RestrictionsObjectRestriction" json:"object,omitempty"`
	Dataview []*RestrictionsDataviewRestrictions `protobuf:"bytes,2,rep,name=dataview,proto3" json:"dataview,omitempty"`
}

func (m *Restrictions) Reset()         { *m = Restrictions{} }
func (m *Restrictions) String() string { return proto.CompactTextString(m) }
func (*Restrictions) ProtoMessage()    {}
func (*Restrictions) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{6}
}
func (m *Restrictions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Restrictions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Restrictions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Restrictions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Restrictions.Merge(m, src)
}
func (m *Restrictions) XXX_Size() int {
	return m.Size()
}
func (m *Restrictions) XXX_DiscardUnknown() {
	xxx_messageInfo_Restrictions.DiscardUnknown(m)
}

var xxx_messageInfo_Restrictions proto.InternalMessageInfo

func (m *Restrictions) GetObject() []RestrictionsObjectRestriction {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *Restrictions) GetDataview() []*RestrictionsDataviewRestrictions {
	if m != nil {
		return m.Dataview
	}
	return nil
}

type RestrictionsDataviewRestrictions struct {
	BlockId      string                            `protobuf:"bytes,1,opt,name=blockId,proto3" json:"blockId,omitempty"`
	Restrictions []RestrictionsDataviewRestriction `protobuf:"varint,2,rep,packed,name=restrictions,proto3,enum=anytype.model.RestrictionsDataviewRestriction" json:"restrictions,omitempty"`
}

func (m *RestrictionsDataviewRestrictions) Reset()         { *m = RestrictionsDataviewRestrictions{} }
func (m *RestrictionsDataviewRestrictions) String() string { return proto.CompactTextString(m) }
func (*RestrictionsDataviewRestrictions) ProtoMessage()    {}
func (*RestrictionsDataviewRestrictions) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{6, 0}
}
func (m *RestrictionsDataviewRestrictions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestrictionsDataviewRestrictions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestrictionsDataviewRestrictions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestrictionsDataviewRestrictions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestrictionsDataviewRestrictions.Merge(m, src)
}
func (m *RestrictionsDataviewRestrictions) XXX_Size() int {
	return m.Size()
}
func (m *RestrictionsDataviewRestrictions) XXX_DiscardUnknown() {
	xxx_messageInfo_RestrictionsDataviewRestrictions.DiscardUnknown(m)
}

var xxx_messageInfo_RestrictionsDataviewRestrictions proto.InternalMessageInfo

func (m *RestrictionsDataviewRestrictions) GetBlockId() string {
	if m != nil {
		return m.BlockId
	}
	return ""
}

func (m *RestrictionsDataviewRestrictions) GetRestrictions() []RestrictionsDataviewRestriction {
	if m != nil {
		return m.Restrictions
	}
	return nil
}

type ObjectType struct {
	Url         string           `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Name        string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Relations   []*Relation      `protobuf:"bytes,3,rep,name=relations,proto3" json:"relations,omitempty"`
	Layout      ObjectTypeLayout `protobuf:"varint,4,opt,name=layout,proto3,enum=anytype.model.ObjectTypeLayout" json:"layout,omitempty"`
	IconEmoji   string           `protobuf:"bytes,5,opt,name=iconEmoji,proto3" json:"iconEmoji,omitempty"`
	Description string           `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Hidden      bool             `protobuf:"varint,7,opt,name=hidden,proto3" json:"hidden,omitempty"`
	Types       []SmartBlockType `protobuf:"varint,8,rep,packed,name=types,proto3,enum=anytype.model.SmartBlockType" json:"types,omitempty"`
}

func (m *ObjectType) Reset()         { *m = ObjectType{} }
func (m *ObjectType) String() string { return proto.CompactTextString(m) }
func (*ObjectType) ProtoMessage()    {}
func (*ObjectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{7}
}
func (m *ObjectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectType.Merge(m, src)
}
func (m *ObjectType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectType proto.InternalMessageInfo

func (m *ObjectType) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ObjectType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectType) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func (m *ObjectType) GetLayout() ObjectTypeLayout {
	if m != nil {
		return m.Layout
	}
	return ObjectType_basic
}

func (m *ObjectType) GetIconEmoji() string {
	if m != nil {
		return m.IconEmoji
	}
	return ""
}

func (m *ObjectType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectType) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *ObjectType) GetTypes() []SmartBlockType {
	if m != nil {
		return m.Types
	}
	return nil
}

type Layout struct {
	Id                ObjectTypeLayout `protobuf:"varint,1,opt,name=id,proto3,enum=anytype.model.ObjectTypeLayout" json:"id,omitempty"`
	Name              string           `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	RequiredRelations []*Relation      `protobuf:"bytes,3,rep,name=requiredRelations,proto3" json:"requiredRelations,omitempty"`
}

func (m *Layout) Reset()         { *m = Layout{} }
func (m *Layout) String() string { return proto.CompactTextString(m) }
func (*Layout) ProtoMessage()    {}
func (*Layout) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{8}
}
func (m *Layout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Layout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Layout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layout.Merge(m, src)
}
func (m *Layout) XXX_Size() int {
	return m.Size()
}
func (m *Layout) XXX_DiscardUnknown() {
	xxx_messageInfo_Layout.DiscardUnknown(m)
}

var xxx_messageInfo_Layout proto.InternalMessageInfo

func (m *Layout) GetId() ObjectTypeLayout {
	if m != nil {
		return m.Id
	}
	return ObjectType_basic
}

func (m *Layout) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Layout) GetRequiredRelations() []*Relation {
	if m != nil {
		return m.RequiredRelations
	}
	return nil
}

type RelationWithValue struct {
	Relation *Relation    `protobuf:"bytes,1,opt,name=relation,proto3" json:"relation,omitempty"`
	Value    *types.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RelationWithValue) Reset()         { *m = RelationWithValue{} }
func (m *RelationWithValue) String() string { return proto.CompactTextString(m) }
func (*RelationWithValue) ProtoMessage()    {}
func (*RelationWithValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{9}
}
func (m *RelationWithValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationWithValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationWithValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelationWithValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationWithValue.Merge(m, src)
}
func (m *RelationWithValue) XXX_Size() int {
	return m.Size()
}
func (m *RelationWithValue) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationWithValue.DiscardUnknown(m)
}

var xxx_messageInfo_RelationWithValue proto.InternalMessageInfo

func (m *RelationWithValue) GetRelation() *Relation {
	if m != nil {
		return m.Relation
	}
	return nil
}

func (m *RelationWithValue) GetValue() *types.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// Relation describe the human-interpreted relation type. It may be something like "Date of creation, format=date" or "Assignee, format=objectId, objectType=person"
type Relation struct {
	// Key under which the value is stored in the map. Must be unique for the object type.
	// It usually auto-generated bsonid, but also may be something human-readable in case of prebuilt types.
	Key          string             `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Format       RelationFormat     `protobuf:"varint,2,opt,name=format,proto3,enum=anytype.model.RelationFormat" json:"format,omitempty"`
	Name         string             `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	DefaultValue *types.Value       `protobuf:"bytes,4,opt,name=defaultValue,proto3" json:"defaultValue,omitempty"`
	DataSource   RelationDataSource `protobuf:"varint,5,opt,name=dataSource,proto3,enum=anytype.model.RelationDataSource" json:"dataSource,omitempty"`
	Hidden       bool               `protobuf:"varint,6,opt,name=hidden,proto3" json:"hidden,omitempty"`
	ReadOnly     bool               `protobuf:"varint,7,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	Multi        bool               `protobuf:"varint,8,opt,name=multi,proto3" json:"multi,omitempty"`
	ObjectTypes  []string           `protobuf:"bytes,9,rep,name=objectTypes,proto3" json:"objectTypes,omitempty"`
	// index 10, 11 was used in internal-only builds. Can be reused, but may break some test accounts
	SelectDict  []*RelationOption `protobuf:"bytes,12,rep,name=selectDict,proto3" json:"selectDict,omitempty"`
	MaxCount    int32             `protobuf:"varint,13,opt,name=maxCount,proto3" json:"maxCount,omitempty"`
	Description string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	// on-store fields, injected only locally
	Scope   RelationScope `protobuf:"varint,20,opt,name=scope,proto3,enum=anytype.model.RelationScope" json:"scope,omitempty"`
	Creator string        `protobuf:"bytes,21,opt,name=creator,proto3" json:"creator,omitempty"`
}

func (m *Relation) Reset()         { *m = Relation{} }
func (m *Relation) String() string { return proto.CompactTextString(m) }
func (*Relation) ProtoMessage()    {}
func (*Relation) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{10}
}
func (m *Relation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relation.Merge(m, src)
}
func (m *Relation) XXX_Size() int {
	return m.Size()
}
func (m *Relation) XXX_DiscardUnknown() {
	xxx_messageInfo_Relation.DiscardUnknown(m)
}

var xxx_messageInfo_Relation proto.InternalMessageInfo

func (m *Relation) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Relation) GetFormat() RelationFormat {
	if m != nil {
		return m.Format
	}
	return RelationFormat_longtext
}

func (m *Relation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Relation) GetDefaultValue() *types.Value {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *Relation) GetDataSource() RelationDataSource {
	if m != nil {
		return m.DataSource
	}
	return Relation_details
}

func (m *Relation) GetHidden() bool {
	if m != nil {
		return m.Hidden
	}
	return false
}

func (m *Relation) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *Relation) GetMulti() bool {
	if m != nil {
		return m.Multi
	}
	return false
}

func (m *Relation) GetObjectTypes() []string {
	if m != nil {
		return m.ObjectTypes
	}
	return nil
}

func (m *Relation) GetSelectDict() []*RelationOption {
	if m != nil {
		return m.SelectDict
	}
	return nil
}

func (m *Relation) GetMaxCount() int32 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

func (m *Relation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Relation) GetScope() RelationScope {
	if m != nil {
		return m.Scope
	}
	return Relation_object
}

func (m *Relation) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

type RelationOption struct {
	Id    string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Text  string              `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	Color string              `protobuf:"bytes,3,opt,name=color,proto3" json:"color,omitempty"`
	Scope RelationOptionScope `protobuf:"varint,4,opt,name=scope,proto3,enum=anytype.model.RelationOptionScope" json:"scope,omitempty"`
}

func (m *RelationOption) Reset()         { *m = RelationOption{} }
func (m *RelationOption) String() string { return proto.CompactTextString(m) }
func (*RelationOption) ProtoMessage()    {}
func (*RelationOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{10, 0}
}
func (m *RelationOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelationOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelationOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelationOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelationOption.Merge(m, src)
}
func (m *RelationOption) XXX_Size() int {
	return m.Size()
}
func (m *RelationOption) XXX_DiscardUnknown() {
	xxx_messageInfo_RelationOption.DiscardUnknown(m)
}

var xxx_messageInfo_RelationOption proto.InternalMessageInfo

func (m *RelationOption) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RelationOption) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *RelationOption) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

func (m *RelationOption) GetScope() RelationOptionScope {
	if m != nil {
		return m.Scope
	}
	return RelationOption_local
}

type Relations struct {
	Relations []*Relation `protobuf:"bytes,1,rep,name=relations,proto3" json:"relations,omitempty"`
}

func (m *Relations) Reset()         { *m = Relations{} }
func (m *Relations) String() string { return proto.CompactTextString(m) }
func (*Relations) ProtoMessage()    {}
func (*Relations) Descriptor() ([]byte, []int) {
	return fileDescriptor_98a910b73321e591, []int{11}
}
func (m *Relations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Relations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Relations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Relations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Relations.Merge(m, src)
}
func (m *Relations) XXX_Size() int {
	return m.Size()
}
func (m *Relations) XXX_DiscardUnknown() {
	xxx_messageInfo_Relations.DiscardUnknown(m)
}

var xxx_messageInfo_Relations proto.InternalMessageInfo

func (m *Relations) GetRelations() []*Relation {
	if m != nil {
		return m.Relations
	}
	return nil
}

func init() {
	proto.RegisterEnum("anytype.model.SmartBlockType", SmartBlockType_name, SmartBlockType_value)
	proto.RegisterEnum("anytype.model.RelationFormat", RelationFormat_name, RelationFormat_value)
	proto.RegisterEnum("anytype.model.BlockPosition", BlockPosition_name, BlockPosition_value)
	proto.RegisterEnum("anytype.model.BlockAlign", BlockAlign_name, BlockAlign_value)
	proto.RegisterEnum("anytype.model.BlockContentLayoutStyle", BlockContentLayoutStyle_name, BlockContentLayoutStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentLinkStyle", BlockContentLinkStyle_name, BlockContentLinkStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentDivStyle", BlockContentDivStyle_name, BlockContentDivStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentTextStyle", BlockContentTextStyle_name, BlockContentTextStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentTextMarkType", BlockContentTextMarkType_name, BlockContentTextMarkType_value)
	proto.RegisterEnum("anytype.model.BlockContentFileType", BlockContentFileType_name, BlockContentFileType_value)
	proto.RegisterEnum("anytype.model.BlockContentFileState", BlockContentFileState_name, BlockContentFileState_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewViewType", BlockContentDataviewViewType_name, BlockContentDataviewViewType_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewRelationDateFormat", BlockContentDataviewRelationDateFormat_name, BlockContentDataviewRelationDateFormat_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewRelationTimeFormat", BlockContentDataviewRelationTimeFormat_name, BlockContentDataviewRelationTimeFormat_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewSortType", BlockContentDataviewSortType_name, BlockContentDataviewSortType_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewFilterOperator", BlockContentDataviewFilterOperator_name, BlockContentDataviewFilterOperator_value)
	proto.RegisterEnum("anytype.model.BlockContentDataviewFilterCondition", BlockContentDataviewFilterCondition_name, BlockContentDataviewFilterCondition_value)
	proto.RegisterEnum("anytype.model.LinkPreviewType", LinkPreviewType_name, LinkPreviewType_value)
	proto.RegisterEnum("anytype.model.RestrictionsObjectRestriction", RestrictionsObjectRestriction_name, RestrictionsObjectRestriction_value)
	proto.RegisterEnum("anytype.model.RestrictionsDataviewRestriction", RestrictionsDataviewRestriction_name, RestrictionsDataviewRestriction_value)
	proto.RegisterEnum("anytype.model.ObjectTypeLayout", ObjectTypeLayout_name, ObjectTypeLayout_value)
	proto.RegisterEnum("anytype.model.RelationScope", RelationScope_name, RelationScope_value)
	proto.RegisterEnum("anytype.model.RelationDataSource", RelationDataSource_name, RelationDataSource_value)
	proto.RegisterEnum("anytype.model.RelationOptionScope", RelationOptionScope_name, RelationOptionScope_value)
	proto.RegisterType((*SmartBlockSnapshotBase)(nil), "anytype.model.SmartBlockSnapshotBase")
	proto.RegisterType((*Block)(nil), "anytype.model.Block")
	proto.RegisterType((*BlockRestrictions)(nil), "anytype.model.Block.Restrictions")
	proto.RegisterType((*BlockContent)(nil), "anytype.model.Block.Content")
	proto.RegisterType((*BlockContentLayout)(nil), "anytype.model.Block.Content.Layout")
	proto.RegisterType((*BlockContentLink)(nil), "anytype.model.Block.Content.Link")
	proto.RegisterType((*BlockContentDiv)(nil), "anytype.model.Block.Content.Div")
	proto.RegisterType((*BlockContentBookmark)(nil), "anytype.model.Block.Content.Bookmark")
	proto.RegisterType((*BlockContentIcon)(nil), "anytype.model.Block.Content.Icon")
	proto.RegisterType((*BlockContentFeaturedRelations)(nil), "anytype.model.Block.Content.FeaturedRelations")
	proto.RegisterType((*BlockContentText)(nil), "anytype.model.Block.Content.Text")
	proto.RegisterType((*BlockContentTextMarks)(nil), "anytype.model.Block.Content.Text.Marks")
	proto.RegisterType((*BlockContentTextMark)(nil), "anytype.model.Block.Content.Text.Mark")
	proto.RegisterType((*BlockContentFile)(nil), "anytype.model.Block.Content.File")
	proto.RegisterType((*BlockContentSmartblock)(nil), "anytype.model.Block.Content.Smartblock")
	proto.RegisterType((*BlockContentDataview)(nil), "anytype.model.Block.Content.Dataview")
	proto.RegisterType((*BlockContentDataviewView)(nil), "anytype.model.Block.Content.Dataview.View")
	proto.RegisterType((*BlockContentDataviewRelation)(nil), "anytype.model.Block.Content.Dataview.Relation")
	proto.RegisterType((*BlockContentDataviewSort)(nil), "anytype.model.Block.Content.Dataview.Sort")
	proto.RegisterType((*BlockContentDataviewFilter)(nil), "anytype.model.Block.Content.Dataview.Filter")
	proto.RegisterType((*BlockContentRelation)(nil), "anytype.model.Block.Content.Relation")
	proto.RegisterType((*BlockMetaOnly)(nil), "anytype.model.BlockMetaOnly")
	proto.RegisterType((*Range)(nil), "anytype.model.Range")
	proto.RegisterType((*Account)(nil), "anytype.model.Account")
	proto.RegisterType((*AccountAvatar)(nil), "anytype.model.Account.Avatar")
	proto.RegisterType((*LinkPreview)(nil), "anytype.model.LinkPreview")
	proto.RegisterType((*Restrictions)(nil), "anytype.model.Restrictions")
	proto.RegisterType((*RestrictionsDataviewRestrictions)(nil), "anytype.model.Restrictions.DataviewRestrictions")
	proto.RegisterType((*ObjectType)(nil), "anytype.model.ObjectType")
	proto.RegisterType((*Layout)(nil), "anytype.model.Layout")
	proto.RegisterType((*RelationWithValue)(nil), "anytype.model.RelationWithValue")
	proto.RegisterType((*Relation)(nil), "anytype.model.Relation")
	proto.RegisterType((*RelationOption)(nil), "anytype.model.Relation.Option")
	proto.RegisterType((*Relations)(nil), "anytype.model.Relations")
}

func init() {
	proto.RegisterFile("pkg/lib/pb/model/protos/models.proto", fileDescriptor_98a910b73321e591)
}

var fileDescriptor_98a910b73321e591 = []byte{
	// 3180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0x4d, 0x6f, 0x23, 0x47,
	0x76, 0x6a, 0xb2, 0xf9, 0xf5, 0x24, 0x71, 0x4a, 0x35, 0xb2, 0xcc, 0xd0, 0xb6, 0xa2, 0x74, 0xfc,
	0x31, 0x19, 0x4f, 0xa8, 0x19, 0x69, 0xc6, 0x8e, 0x9d, 0x38, 0xb6, 0x3e, 0x66, 0x2c, 0x61, 0x3e,
	0x34, 0x6e, 0x6a, 0x14, 0xc4, 0x08, 0x02, 0x17, 0xbb, 0x4b, 0x64, 0x5b, 0xcd, 0x2e, 0xba, 0xba,
	0xa8, 0x19, 0x19, 0x39, 0xd8, 0x31, 0x02, 0x24, 0x37, 0x3b, 0x81, 0x91, 0xeb, 0xee, 0x7d, 0x81,
	0x3d, 0xed, 0xc7, 0x61, 0xcf, 0x8b, 0x5d, 0xec, 0x61, 0x7d, 0x59, 0x60, 0x7d, 0x33, 0xec, 0xbf,
	0xb1, 0x0b, 0x2c, 0x5e, 0x55, 0x77, 0xb3, 0x49, 0x69, 0x34, 0x1c, 0xef, 0xde, 0xfa, 0xbd, 0x7a,
	0xef, 0xd5, 0xab, 0x57, 0xef, 0xab, 0x1e, 0x09, 0x2f, 0x0e, 0x8e, 0xba, 0xab, 0x61, 0xd0, 0x59,
	0x1d, 0x74, 0x56, 0xfb, 0xc2, 0xe7, 0xe1, 0xea, 0x40, 0x0a, 0x25, 0x62, 0x03, 0xc4, 0x2d, 0x0d,
	0xd1, 0x79, 0x16, 0x9d, 0xa8, 0x93, 0x01, 0x6f, 0x69, 0x6c, 0xf3, 0xf9, 0xae, 0x10, 0xdd, 0x90,
	0x1b, 0xd2, 0xce, 0xf0, 0x70, 0x35, 0x56, 0x72, 0xe8, 0x29, 0x43, 0xec, 0x7c, 0x51, 0x80, 0xa5,
	0x76, 0x9f, 0x49, 0xb5, 0x19, 0x0a, 0xef, 0xa8, 0x1d, 0xb1, 0x41, 0xdc, 0x13, 0x6a, 0x93, 0xc5,
	0x9c, 0x5e, 0x81, 0x72, 0x07, 0x91, 0x71, 0xc3, 0x5a, 0x29, 0x5e, 0x9a, 0x5d, 0x5b, 0x6c, 0x8d,
	0x09, 0x6e, 0x69, 0x0e, 0x37, 0xa1, 0xa1, 0xd7, 0xa0, 0xe2, 0x73, 0xc5, 0x82, 0x30, 0x6e, 0x14,
	0x56, 0xac, 0x4b, 0xb3, 0x6b, 0xcf, 0xb6, 0xcc, 0xc6, 0xad, 0x74, 0xe3, 0x56, 0x5b, 0x6f, 0xec,
	0xa6, 0x74, 0x74, 0x1d, 0xaa, 0x87, 0x41, 0xc8, 0x6f, 0xf3, 0x93, 0xb8, 0x51, 0x3c, 0x9f, 0x27,
	0x23, 0xa4, 0x6f, 0x43, 0x9d, 0x3f, 0x52, 0x92, 0xb9, 0x3c, 0x64, 0x2a, 0x10, 0x51, 0xdc, 0xb0,
	0xb5, 0x76, 0xcf, 0x4e, 0x68, 0x97, 0xae, 0xbb, 0x13, 0xe4, 0x74, 0x05, 0x66, 0x45, 0xe7, 0x43,
	0xee, 0xa9, 0xfd, 0x93, 0x01, 0x8f, 0x1b, 0xa5, 0x95, 0xe2, 0xa5, 0x9a, 0x9b, 0x47, 0x39, 0x3f,
	0x7b, 0x09, 0x4a, 0xfa, 0x70, 0xb4, 0x0e, 0x85, 0xc0, 0x6f, 0x58, 0x2b, 0xd6, 0xa5, 0x9a, 0x5b,
	0x08, 0x7c, 0xba, 0x0a, 0xe5, 0xc3, 0x80, 0x87, 0xfe, 0x13, 0xcf, 0x98, 0x90, 0xd1, 0x9b, 0x30,
	0x27, 0x79, 0xac, 0x64, 0xe0, 0x19, 0x5d, 0xcd, 0x31, 0xff, 0xe6, 0x2c, 0x4b, 0xb6, 0xdc, 0x1c,
	0xa1, 0x3b, 0xc6, 0x86, 0x3a, 0x7b, 0xbd, 0x20, 0xf4, 0x25, 0x8f, 0x76, 0x7d, 0x73, 0xe2, 0x9a,
	0x9b, 0x47, 0xd1, 0x4b, 0x70, 0xa1, 0xc3, 0xbc, 0xa3, 0xae, 0x14, 0xc3, 0xc8, 0xdf, 0x12, 0xa1,
	0x90, 0x8d, 0x92, 0x56, 0x7b, 0x12, 0x4d, 0xaf, 0x42, 0x89, 0x85, 0x41, 0x37, 0x6a, 0x94, 0x57,
	0xac, 0x4b, 0xf5, 0xb5, 0xe6, 0x99, 0xba, 0x6c, 0x20, 0x85, 0x6b, 0x08, 0xe9, 0x2e, 0x40, 0x8c,
	0x2e, 0xa2, 0x6f, 0xba, 0x31, 0xab, 0x8f, 0xf0, 0xca, 0x99, 0x6c, 0x5b, 0x22, 0x52, 0x3c, 0x52,
	0xad, 0x76, 0x46, 0xbe, 0x33, 0xe3, 0xe6, 0x98, 0xe9, 0xeb, 0x60, 0x2b, 0xfe, 0x48, 0x35, 0xea,
	0xe7, 0xd8, 0x21, 0x15, 0xb2, 0xcf, 0x1f, 0xa9, 0x9d, 0x19, 0x57, 0x33, 0x20, 0x23, 0xba, 0x40,
	0xe3, 0xc2, 0x14, 0x8c, 0xb7, 0x82, 0x90, 0x23, 0x23, 0x32, 0xd0, 0xb7, 0xa0, 0x1c, 0xb2, 0x13,
	0x31, 0x54, 0x0d, 0xa2, 0x59, 0xff, 0xf6, 0x5c, 0xd6, 0x3b, 0x9a, 0x74, 0x67, 0xc6, 0x4d, 0x98,
	0xe8, 0x75, 0x28, 0xfa, 0xc1, 0x71, 0x63, 0x41, 0xf3, 0xae, 0x9c, 0xcb, 0xbb, 0x1d, 0x1c, 0xef,
	0xcc, 0xb8, 0x48, 0x4e, 0xb7, 0xa0, 0xda, 0x11, 0xe2, 0xa8, 0xcf, 0xe4, 0x51, 0x83, 0x6a, 0xd6,
	0x97, 0xce, 0x65, 0xdd, 0x4c, 0x88, 0x77, 0x66, 0xdc, 0x8c, 0x11, 0x8f, 0x1c, 0x78, 0x22, 0x6a,
	0x5c, 0x9c, 0xe2, 0xc8, 0xbb, 0x9e, 0x88, 0xf0, 0xc8, 0xc8, 0x80, 0x8c, 0x61, 0x10, 0x1d, 0x35,
	0x16, 0xa7, 0x60, 0xbc, 0x13, 0x44, 0xb8, 0xab, 0x66, 0x40, 0xb5, 0x7d, 0xa6, 0xd8, 0x71, 0xc0,
	0x1f, 0x36, 0x9e, 0x99, 0x42, 0xed, 0xed, 0x84, 0x18, 0xd5, 0x4e, 0x19, 0x51, 0x88, 0x4c, 0x82,
	0xad, 0xb1, 0x34, 0x85, 0x90, 0x34, 0x32, 0x51, 0x48, 0xca, 0x48, 0xff, 0x1d, 0x16, 0x0e, 0x39,
	0x53, 0x43, 0xc9, 0xfd, 0x51, 0xa0, 0x3f, 0xab, 0xa5, 0xb5, 0xce, 0xbf, 0xfb, 0x49, 0xae, 0x9d,
	0x19, 0xf7, 0xb4, 0xa8, 0xe6, 0xc7, 0x30, 0x97, 0x0f, 0x37, 0x4a, 0xc1, 0x96, 0x9c, 0x99, 0x50,
	0xaf, 0xba, 0xfa, 0x1b, 0x71, 0xdc, 0x0f, 0x94, 0x0e, 0xf5, 0xaa, 0xab, 0xbf, 0xe9, 0x12, 0x94,
	0x25, 0xef, 0x8b, 0x63, 0xae, 0x23, 0xb9, 0xea, 0x26, 0x10, 0xd2, 0xfa, 0x92, 0x75, 0x1b, 0xb6,
	0xa1, 0xc5, 0x6f, 0xa4, 0xf5, 0xa5, 0x18, 0xec, 0x45, 0x3a, 0x12, 0xab, 0x6e, 0x02, 0x35, 0x7f,
	0xf1, 0x1c, 0x54, 0x12, 0x75, 0x9b, 0xff, 0x01, 0x65, 0xe3, 0x72, 0xf4, 0x6d, 0x28, 0xc5, 0xea,
	0x24, 0xe4, 0x5a, 0x85, 0xfa, 0xda, 0xdf, 0x4d, 0xe1, 0xa6, 0xad, 0x36, 0x32, 0xb8, 0x86, 0xcf,
	0xb9, 0x06, 0x25, 0x0d, 0xd3, 0x0a, 0x14, 0x5d, 0xf1, 0x90, 0xcc, 0x50, 0x80, 0xf2, 0x96, 0x08,
	0x87, 0xfd, 0x88, 0x58, 0x88, 0xdc, 0x0e, 0x8e, 0x49, 0x01, 0x91, 0x3b, 0x9c, 0xf9, 0x5c, 0x92,
	0x62, 0xf3, 0x6b, 0x0b, 0x6c, 0x74, 0x00, 0xfa, 0x22, 0xcc, 0x2b, 0x26, 0xbb, 0xdc, 0x54, 0x81,
	0xdd, 0x34, 0xe5, 0x8d, 0x23, 0xe9, 0x5b, 0xa9, 0x8a, 0x05, 0xad, 0xe2, 0x2b, 0x4f, 0x74, 0xac,
	0x31, 0x05, 0x73, 0xc9, 0xb3, 0x38, 0x55, 0xf2, 0x74, 0xfe, 0x31, 0x3d, 0x51, 0x15, 0xec, 0xfb,
	0xac, 0xcb, 0xc9, 0x0c, 0x9d, 0x83, 0x6a, 0xea, 0x74, 0xc4, 0xa2, 0xf3, 0x50, 0xdb, 0x66, 0x71,
	0xaf, 0x23, 0x98, 0xf4, 0x49, 0x81, 0xce, 0x42, 0x65, 0x43, 0x7a, 0xbd, 0xe0, 0x98, 0x93, 0x62,
	0xf3, 0x03, 0x7d, 0x60, 0xfa, 0x4f, 0xe3, 0x66, 0x7d, 0xf9, 0x49, 0x11, 0x3c, 0x6e, 0xd3, 0xe7,
	0x72, 0x1a, 0xdc, 0x09, 0x22, 0xd4, 0xa0, 0x0a, 0xf6, 0xb6, 0x50, 0x31, 0xb1, 0x9a, 0xbf, 0xb6,
	0xa0, 0x9a, 0x06, 0x2e, 0x25, 0x50, 0x1c, 0xca, 0x30, 0xb1, 0x1b, 0x7e, 0xd2, 0x45, 0x28, 0xa9,
	0x40, 0x25, 0xd6, 0xaa, 0xb9, 0x06, 0xc0, 0x4c, 0xee, 0xf3, 0xd8, 0x93, 0xc1, 0x40, 0x07, 0x48,
	0x51, 0xaf, 0xe5, 0x51, 0xf4, 0x79, 0xa8, 0x05, 0x7d, 0xd6, 0xe5, 0x3b, 0x2c, 0xee, 0x69, 0x7f,
	0xaa, 0xb9, 0x23, 0x04, 0xf2, 0x1f, 0xb2, 0x63, 0x0c, 0x73, 0xbd, 0x6e, 0x72, 0x7c, 0x1e, 0x45,
	0xd7, 0xc1, 0xc6, 0x03, 0x26, 0xe9, 0xfd, 0xaf, 0x27, 0x0e, 0x8c, 0xd7, 0x72, 0x5f, 0x72, 0x34,
	0x60, 0x0b, 0xab, 0x9d, 0xab, 0x89, 0x9b, 0x4d, 0xb0, 0x31, 0x85, 0xa0, 0x1f, 0x47, 0xac, 0xcf,
	0x93, 0x73, 0xe8, 0xef, 0xe6, 0x45, 0x58, 0x38, 0x15, 0x55, 0xcd, 0xaf, 0x4b, 0x60, 0x63, 0x82,
	0x46, 0x0e, 0x9d, 0xd1, 0x13, 0x0e, 0x9d, 0xac, 0x9f, 0xca, 0x51, 0x50, 0xca, 0xb8, 0xa3, 0xbc,
	0x05, 0x25, 0xb4, 0x69, 0xea, 0x27, 0x53, 0xb0, 0xdf, 0x45, 0x72, 0xd7, 0x70, 0xd1, 0x06, 0x54,
	0xbc, 0x1e, 0xf7, 0x8e, 0xb8, 0x9f, 0x84, 0x63, 0x0a, 0xe2, 0x95, 0x78, 0xb9, 0xd2, 0x68, 0x80,
	0xe6, 0x4d, 0x28, 0x69, 0x7e, 0xf4, 0x15, 0xb3, 0xaf, 0xe9, 0x77, 0x5e, 0x9e, 0x6e, 0xdf, 0x64,
	0xdb, 0xe6, 0x97, 0x05, 0xb0, 0x11, 0xa6, 0x97, 0xa1, 0x24, 0x59, 0xd4, 0x35, 0x46, 0x3c, 0xdd,
	0x36, 0xb9, 0xb8, 0xe6, 0x1a, 0x12, 0xfa, 0x76, 0x72, 0x59, 0xc6, 0x50, 0xaf, 0x4e, 0xb7, 0x63,
	0xee, 0xe2, 0xf0, 0x48, 0x03, 0x26, 0x59, 0x3f, 0xf1, 0x24, 0x03, 0x38, 0xff, 0x63, 0x81, 0x8d,
	0x44, 0x74, 0x01, 0xe6, 0xdb, 0x4a, 0x06, 0x47, 0x5c, 0xf5, 0xa4, 0x18, 0x76, 0x7b, 0x26, 0x84,
	0x6e, 0xf3, 0x13, 0x13, 0x33, 0x16, 0xa6, 0x83, 0x5d, 0xc5, 0xc2, 0xc0, 0x23, 0x05, 0x74, 0xed,
	0x4d, 0x11, 0xfa, 0xa4, 0x48, 0x2f, 0xc0, 0xec, 0x83, 0xc8, 0xe7, 0x32, 0xf6, 0x84, 0xe4, 0x3e,
	0xb1, 0x13, 0xff, 0x3f, 0x22, 0x25, 0x8c, 0x39, 0x54, 0x44, 0xf7, 0x12, 0xa4, 0x4c, 0x2f, 0xc2,
	0x85, 0xcd, 0xf1, 0x06, 0x83, 0x54, 0x30, 0x10, 0xef, 0xf2, 0x08, 0x1d, 0x85, 0x54, 0x9d, 0x1f,
	0x5b, 0x69, 0x10, 0xcd, 0x43, 0xed, 0x3e, 0x93, 0xac, 0x2b, 0xd9, 0x00, 0x15, 0x99, 0x85, 0x8a,
	0xc9, 0x44, 0xd7, 0x88, 0x35, 0x02, 0xd6, 0x4c, 0x20, 0x1b, 0x60, 0x9d, 0x14, 0x47, 0xc0, 0x75,
	0x62, 0xd3, 0x1a, 0x94, 0xde, 0x1b, 0x0a, 0xc5, 0x49, 0x09, 0x55, 0xda, 0x12, 0x3e, 0x27, 0x65,
	0x44, 0xee, 0x63, 0x70, 0x91, 0x0a, 0x1e, 0x6e, 0x0b, 0x2f, 0xbb, 0x23, 0x1e, 0x91, 0x2a, 0x1e,
	0x0e, 0xed, 0xc5, 0x7d, 0x52, 0xc3, 0x95, 0x7b, 0xc3, 0x7e, 0x87, 0xe3, 0x79, 0x00, 0x57, 0xf6,
	0x45, 0xb7, 0x1b, 0x72, 0x32, 0x8b, 0x87, 0xdd, 0x1e, 0xc5, 0x1f, 0x99, 0x6b, 0xfe, 0xae, 0x00,
	0x36, 0xf6, 0x10, 0xe8, 0xdb, 0x3d, 0x8c, 0xb2, 0xc4, 0xb7, 0xf1, 0x3b, 0x8b, 0x90, 0xc2, 0x28,
	0x42, 0xe8, 0x9b, 0xc9, 0x2d, 0x16, 0xa7, 0xc8, 0x31, 0x28, 0x38, 0x7f, 0x81, 0x14, 0xec, 0x7e,
	0xd0, 0xe7, 0x49, 0xa4, 0xeb, 0x6f, 0xc4, 0xc5, 0xc1, 0xc7, 0x5c, 0xbb, 0x69, 0xd1, 0xd5, 0xdf,
	0xe8, 0xd5, 0xcc, 0xf7, 0xb9, 0xbf, 0xa1, 0x74, 0x64, 0x17, 0xdd, 0x14, 0x34, 0xd1, 0xc6, 0x14,
	0x6f, 0x54, 0xa6, 0x88, 0x36, 0xbd, 0x7d, 0x1b, 0xc9, 0x5d, 0xc3, 0xe5, 0x5c, 0x4d, 0x5c, 0xa5,
	0x0a, 0xf6, 0x3d, 0x91, 0xa6, 0x38, 0x24, 0x23, 0x16, 0x5a, 0x76, 0x17, 0x53, 0x0f, 0x29, 0xe0,
	0xe7, 0x41, 0xe0, 0x73, 0x41, 0x8a, 0xce, 0x6b, 0x78, 0xa1, 0x4c, 0x71, 0xc4, 0xdd, 0xec, 0x0f,
	0xd4, 0x09, 0x99, 0xc1, 0xbb, 0x7d, 0x30, 0x08, 0x05, 0xf3, 0x83, 0xa8, 0x4b, 0x2c, 0x93, 0x25,
	0xa3, 0x84, 0xef, 0xa6, 0x94, 0x02, 0xcb, 0xcd, 0x1c, 0xc0, 0xa8, 0x31, 0x6c, 0xfe, 0xff, 0xfc,
	0x28, 0x97, 0x63, 0xad, 0x8c, 0xc5, 0x50, 0x7a, 0x69, 0xe6, 0x49, 0x20, 0xfa, 0x0e, 0x94, 0x70,
	0x1d, 0xfb, 0x6d, 0x0c, 0xc9, 0xcb, 0x53, 0xb5, 0x23, 0xad, 0x83, 0x80, 0x3f, 0x74, 0x0d, 0x23,
	0xbd, 0x01, 0x35, 0x39, 0xed, 0x53, 0x61, 0x44, 0x49, 0x97, 0x01, 0x98, 0xa7, 0x82, 0x63, 0x8e,
	0xb2, 0x92, 0xe0, 0xca, 0x61, 0x9a, 0x7f, 0x2c, 0x80, 0x8d, 0x1f, 0xa7, 0x9e, 0x08, 0x5b, 0x63,
	0x11, 0xbd, 0x3a, 0xbd, 0xc2, 0x13, 0x4e, 0xa1, 0x9d, 0xac, 0x98, 0x73, 0xb2, 0x77, 0xa0, 0x14,
	0x0b, 0xa9, 0xd2, 0x43, 0x4c, 0x69, 0x8a, 0xb6, 0x90, 0xca, 0x35, 0x8c, 0xf4, 0x16, 0x54, 0x0e,
	0x83, 0x50, 0x71, 0x69, 0x5e, 0x3d, 0xb3, 0x6b, 0x57, 0xa6, 0x93, 0x71, 0x4b, 0x33, 0xb9, 0x29,
	0x33, 0xbd, 0x93, 0x37, 0x69, 0x59, 0x4b, 0x6a, 0x4d, 0x27, 0xe9, 0x0c, 0x4b, 0x3b, 0xd7, 0x13,
	0xff, 0xc3, 0x28, 0x66, 0x9d, 0x30, 0x71, 0xc0, 0x3b, 0x41, 0xac, 0x4c, 0x5a, 0x78, 0x97, 0x85,
	0x21, 0x97, 0x27, 0xa6, 0x75, 0xb9, 0xcd, 0xa2, 0x0e, 0x8b, 0x48, 0xb1, 0xf9, 0xf3, 0x22, 0x54,
	0x53, 0x69, 0x58, 0x7c, 0x8f, 0xf8, 0x49, 0x5a, 0x7c, 0x8f, 0xf8, 0x89, 0x2e, 0xa2, 0xf1, 0x41,
	0x10, 0x07, 0x9d, 0xa4, 0x0a, 0x55, 0xdd, 0x11, 0x02, 0x93, 0xe6, 0xc3, 0xc0, 0x57, 0x3d, 0x6d,
	0xdf, 0x92, 0x6b, 0x00, 0x7c, 0x42, 0xf9, 0x4c, 0xf1, 0xdd, 0xc8, 0x0b, 0x87, 0x3e, 0xdf, 0xc7,
	0xa0, 0x34, 0x8d, 0xdb, 0x24, 0x9a, 0xfe, 0x2b, 0x80, 0x0a, 0xfa, 0xfc, 0x96, 0x90, 0x7d, 0xa6,
	0x92, 0x42, 0xfb, 0xc6, 0xd3, 0x59, 0xa0, 0xb5, 0x9f, 0x09, 0x70, 0x73, 0xc2, 0x50, 0x34, 0xee,
	0x96, 0x88, 0xae, 0x7c, 0x2f, 0xd1, 0xdb, 0x99, 0x00, 0x37, 0x27, 0xcc, 0xf9, 0x37, 0x80, 0xd1,
	0x0a, 0x5d, 0x02, 0x7a, 0x57, 0x44, 0xaa, 0xb7, 0xd1, 0xe9, 0xc8, 0x4d, 0x7e, 0x28, 0x24, 0xdf,
	0x66, 0x18, 0xc8, 0xcf, 0xc0, 0x42, 0x86, 0xdf, 0x38, 0x54, 0x5c, 0x22, 0x5a, 0x67, 0x82, 0x76,
	0x4f, 0x48, 0x65, 0xb2, 0xb3, 0xfe, 0x7c, 0xd0, 0x26, 0x45, 0xec, 0x2b, 0x77, 0xdb, 0x7b, 0xc4,
	0x76, 0x2e, 0x01, 0x8c, 0x8e, 0x84, 0xd9, 0xd6, 0x7c, 0x5d, 0x5b, 0x33, 0x25, 0xc7, 0x40, 0x6b,
	0xd7, 0x89, 0xd5, 0xfc, 0x6f, 0x0b, 0x6c, 0x74, 0x4b, 0xec, 0x65, 0x52, 0x9d, 0x6f, 0x67, 0xd7,
	0x97, 0x47, 0x7d, 0xbf, 0x60, 0x42, 0xd9, 0xb9, 0x60, 0x72, 0xfe, 0x2a, 0x71, 0xb0, 0x0a, 0x14,
	0x37, 0x62, 0x2f, 0x69, 0xe1, 0x78, 0xec, 0x11, 0xab, 0xf9, 0x7f, 0x36, 0x94, 0x8d, 0x77, 0xd3,
	0xf7, 0xa0, 0x2a, 0x06, 0x5c, 0x32, 0x25, 0x64, 0xd2, 0x2b, 0xde, 0x78, 0x9a, 0xe8, 0x68, 0xed,
	0x25, 0xcc, 0x6e, 0x26, 0x66, 0xf2, 0x7c, 0x85, 0xd3, 0xe7, 0xbb, 0x0c, 0x24, 0x0d, 0x84, 0xfb,
	0x12, 0xf9, 0xd4, 0x49, 0xd2, 0x9b, 0x9c, 0xc2, 0xd3, 0x7d, 0xa8, 0x79, 0x22, 0xf2, 0x83, 0xac,
	0x6f, 0xac, 0xaf, 0xbd, 0xf6, 0x54, 0x1a, 0x6e, 0xa5, 0xdc, 0xee, 0x48, 0x10, 0xbd, 0x02, 0xa5,
	0x63, 0x16, 0x0e, 0x4d, 0xfd, 0x99, 0x5d, 0x5b, 0x3a, 0xd5, 0x93, 0x1f, 0xe0, 0xaa, 0x6b, 0x88,
	0x9c, 0xe7, 0xa0, 0x9a, 0x9e, 0x53, 0x9b, 0x33, 0xf2, 0xc9, 0x0c, 0x2d, 0x43, 0x61, 0x4f, 0x12,
	0xcb, 0xf9, 0xa5, 0x05, 0xb5, 0x6c, 0x8f, 0x5c, 0x39, 0xc1, 0x0a, 0xf0, 0xd1, 0x90, 0x85, 0xc4,
	0xd2, 0x45, 0x58, 0x28, 0x03, 0x69, 0x47, 0x7a, 0x57, 0x72, 0xa6, 0xf0, 0x2d, 0xa2, 0x63, 0x9e,
	0xc7, 0x31, 0xb1, 0x29, 0x85, 0x7a, 0x82, 0xde, 0x93, 0x86, 0xb4, 0x84, 0x35, 0x1a, 0x57, 0x53,
	0x44, 0xd9, 0xa4, 0x88, 0x23, 0x6e, 0x9a, 0x8d, 0x7b, 0x42, 0x69, 0xa0, 0x8a, 0xba, 0xec, 0x46,
	0xa4, 0x86, 0x7b, 0xde, 0x13, 0x6a, 0x37, 0x22, 0x30, 0x2a, 0x52, 0xb3, 0xe9, 0xf6, 0x1a, 0x9a,
	0xc3, 0x85, 0x8d, 0x30, 0xdc, 0x8d, 0xc8, 0x7c, 0xb2, 0x60, 0xa0, 0x7a, 0xf3, 0xf9, 0xf3, 0x52,
	0x8b, 0x73, 0x00, 0xd5, 0xfb, 0x22, 0x9e, 0x3c, 0x64, 0x05, 0x8a, 0xfb, 0x62, 0x60, 0x1a, 0xaa,
	0x4d, 0xa1, 0x94, 0xe8, 0x9b, 0x86, 0xea, 0x0e, 0x3f, 0x54, 0xa4, 0x88, 0x7b, 0xb9, 0x41, 0xb7,
	0xa7, 0x4c, 0x0b, 0xb3, 0x1b, 0x45, 0x5c, 0x92, 0x12, 0xaa, 0xee, 0xf2, 0x41, 0xc8, 0x3c, 0x4e,
	0xca, 0xce, 0xeb, 0xa8, 0x4e, 0xd0, 0x8d, 0xb0, 0x94, 0xea, 0x0f, 0xcd, 0x3a, 0x83, 0x47, 0xd7,
	0xe0, 0x16, 0x8f, 0xd0, 0x52, 0x16, 0xad, 0x03, 0x98, 0xf1, 0x8c, 0x16, 0x58, 0xd8, 0xac, 0x41,
	0xc5, 0x33, 0x57, 0xee, 0xdc, 0x87, 0x79, 0xed, 0x03, 0x77, 0xb9, 0x62, 0x7b, 0x51, 0x78, 0xf2,
	0x67, 0x0f, 0xb0, 0x9c, 0x57, 0xa1, 0xa4, 0x1b, 0x56, 0x2c, 0x49, 0x87, 0x52, 0xf4, 0xb5, 0xac,
	0x92, 0xab, 0xbf, 0x51, 0xba, 0x12, 0x5a, 0x52, 0xc9, 0x2d, 0x28, 0xe1, 0xfc, 0xc6, 0x82, 0xca,
	0x86, 0xe7, 0x89, 0x61, 0xa4, 0x4e, 0xed, 0x7c, 0x56, 0xdf, 0x74, 0x03, 0xca, 0xec, 0x98, 0x29,
	0x26, 0x93, 0x4e, 0xff, 0x85, 0x09, 0x7f, 0x4e, 0x64, 0xb5, 0x36, 0x34, 0x91, 0x9b, 0x10, 0x37,
	0x39, 0x94, 0x0d, 0x86, 0xbe, 0x01, 0x25, 0xfd, 0x34, 0x4a, 0x5a, 0xed, 0xa9, 0xc6, 0x42, 0x86,
	0x83, 0x2e, 0xa5, 0x6f, 0x01, 0xad, 0x10, 0xe2, 0x35, 0xb8, 0x59, 0x4d, 0x75, 0x72, 0xfe, 0x60,
	0xc1, 0x6c, 0xee, 0xb9, 0xf4, 0x17, 0x7c, 0xe2, 0x35, 0xa1, 0xaa, 0x95, 0x78, 0x20, 0xc3, 0xa4,
	0xef, 0xcb, 0x60, 0x6c, 0x3c, 0x92, 0xd7, 0x1c, 0xae, 0x9a, 0x64, 0x90, 0xc3, 0x7c, 0xaf, 0xe7,
	0x9d, 0xb3, 0x96, 0xa4, 0xc0, 0x59, 0xa8, 0x3c, 0x88, 0x8e, 0x22, 0xf1, 0x30, 0x32, 0x69, 0x50,
	0xbf, 0xaa, 0xc7, 0xda, 0xbc, 0xaa, 0x79, 0xd6, 0x91, 0xa2, 0xf3, 0x99, 0x3d, 0x31, 0x23, 0xb9,
	0x09, 0x65, 0x33, 0x25, 0xd5, 0xef, 0xa3, 0xfa, 0xda, 0xdf, 0x9f, 0x6a, 0xa3, 0x46, 0xc4, 0xad,
	0x3d, 0x4d, 0x99, 0x43, 0xb9, 0x09, 0x33, 0xbd, 0x93, 0x1b, 0x32, 0x99, 0xae, 0xee, 0xea, 0x79,
	0x82, 0xd2, 0x2c, 0x36, 0x36, 0x1d, 0xcd, 0x24, 0x34, 0xff, 0xcb, 0x82, 0xc5, 0xb3, 0x48, 0xb0,
	0x5f, 0xee, 0x8c, 0x0d, 0x33, 0x52, 0x90, 0xb6, 0x27, 0x66, 0xb2, 0x05, 0x7d, 0x9a, 0xd5, 0xa7,
	0x54, 0x62, 0x7c, 0x42, 0xeb, 0x7c, 0x6a, 0xc1, 0xc2, 0xa9, 0x33, 0xe7, 0xf2, 0x03, 0x40, 0x79,
	0x9b, 0x87, 0x5c, 0x71, 0x33, 0xb6, 0xc8, 0x1e, 0xd2, 0xa6, 0xad, 0xd1, 0x8e, 0x1a, 0x9b, 0xc7,
	0xce, 0xb6, 0x99, 0x8e, 0x13, 0x1b, 0x03, 0x1d, 0x6f, 0x6d, 0xab, 0x87, 0x01, 0x48, 0x4a, 0x94,
	0xc0, 0x9c, 0x19, 0xfc, 0x24, 0x98, 0x32, 0xe6, 0xad, 0x7d, 0xde, 0x1f, 0x84, 0x4c, 0x71, 0x52,
	0x71, 0x5c, 0xb8, 0x78, 0x86, 0xa2, 0x7a, 0xeb, 0x83, 0x44, 0x8d, 0x3a, 0xc0, 0xf6, 0x41, 0xba,
	0x39, 0xb1, 0x30, 0xd7, 0x6e, 0x1f, 0x6c, 0xe9, 0x6c, 0x6b, 0xb4, 0x37, 0x69, 0x79, 0xfb, 0x00,
	0x3b, 0xd2, 0x98, 0x14, 0x9d, 0x9f, 0x16, 0x01, 0xf6, 0xb2, 0xd9, 0xf8, 0x19, 0x31, 0x70, 0x76,
	0x5c, 0xe7, 0x1a, 0xc4, 0xe2, 0xd4, 0x3d, 0xf7, 0x3f, 0x64, 0xa3, 0x5a, 0x5b, 0x3b, 0xf7, 0xe4,
	0xb8, 0x75, 0xa4, 0x47, 0x32, 0x00, 0xcb, 0xa6, 0xb4, 0xd8, 0xee, 0x79, 0x22, 0xba, 0xd9, 0x17,
	0x1f, 0x06, 0x49, 0xcc, 0x8c, 0x10, 0x93, 0x01, 0x59, 0x3e, 0x1d, 0x90, 0x4b, 0x50, 0xee, 0x05,
	0xbe, 0xcf, 0x23, 0xdd, 0x71, 0x55, 0xdd, 0x04, 0xa2, 0xeb, 0x50, 0x52, 0xfa, 0x57, 0x82, 0xaa,
	0xf6, 0x91, 0xc9, 0xfc, 0x34, 0xfa, 0xe1, 0x44, 0xc7, 0x9a, 0xa1, 0x75, 0x3e, 0xb3, 0xb2, 0xa1,
	0x5e, 0x0d, 0x4a, 0x1d, 0x16, 0x07, 0x9e, 0x79, 0xed, 0x0e, 0xa4, 0x38, 0x34, 0xef, 0xaa, 0x2a,
	0xd8, 0x4a, 0xf8, 0x82, 0x14, 0xb0, 0x6e, 0xc4, 0x1c, 0x2b, 0x44, 0x1d, 0x60, 0xf4, 0x1b, 0x04,
	0xb1, 0xf1, 0x6a, 0x53, 0xcb, 0x98, 0xc7, 0xae, 0x66, 0x2d, 0xa3, 0xf3, 0xf8, 0xd9, 0xcc, 0xab,
	0x82, 0x3b, 0xe8, 0xd4, 0x41, 0xaa, 0xc8, 0x81, 0x61, 0xd1, 0x61, 0x31, 0x27, 0x8b, 0xce, 0x97,
	0x23, 0x2d, 0xae, 0x66, 0xa9, 0x78, 0x1a, 0x9b, 0x3e, 0x2e, 0x59, 0xdf, 0x84, 0x05, 0xc9, 0x3f,
	0x1a, 0x06, 0x63, 0x23, 0xd9, 0x27, 0x5c, 0xee, 0x69, 0x0e, 0xe7, 0x18, 0x16, 0x52, 0xe0, 0x5f,
	0x02, 0xd5, 0xd3, 0xed, 0x05, 0x5d, 0xcf, 0xcd, 0x8c, 0xad, 0xa4, 0x30, 0x3d, 0x46, 0xe4, 0x68,
	0x46, 0x9c, 0xb5, 0x2e, 0x85, 0x69, 0x5a, 0x97, 0x6f, 0xca, 0xe7, 0x3e, 0x18, 0x6e, 0x40, 0xf9,
	0xd0, 0xf4, 0xdc, 0xa6, 0xd7, 0x7c, 0xe1, 0x31, 0xfb, 0x27, 0x7d, 0x75, 0x42, 0x7c, 0xe6, 0x43,
	0xed, 0x4d, 0x98, 0xf3, 0xf9, 0x21, 0x1b, 0x86, 0xea, 0x60, 0x8a, 0xce, 0x6a, 0x8c, 0x96, 0x6e,
	0xea, 0xf6, 0x9f, 0xb5, 0xcd, 0x5b, 0xb8, 0xa4, 0x55, 0x71, 0x1e, 0xa3, 0x8a, 0xce, 0x4a, 0x86,
	0xd2, 0xcd, 0x71, 0xe5, 0x9c, 0xb9, 0x3c, 0xe6, 0xcc, 0x4d, 0x34, 0x32, 0xf3, 0xb1, 0x2f, 0x48,
	0xdc, 0x3c, 0x83, 0xb1, 0x92, 0xf5, 0x87, 0xa1, 0x0a, 0x1a, 0x55, 0xbd, 0x60, 0x80, 0xc9, 0x9f,
	0xca, 0x6a, 0xa7, 0x7e, 0x2a, 0xa3, 0xff, 0x0c, 0x10, 0xf3, 0x90, 0x7b, 0x6a, 0x3b, 0xf0, 0x54,
	0x63, 0x4e, 0x7b, 0xc3, 0xf2, 0xe3, 0xf4, 0xdd, 0xd3, 0xc1, 0xe6, 0xe6, 0x38, 0x50, 0xa7, 0x3e,
	0x7b, 0xb4, 0x85, 0x55, 0xbe, 0x31, 0xaf, 0xfb, 0x88, 0x0c, 0x9e, 0x0c, 0xdb, 0xfa, 0xe9, 0xb0,
	0x5d, 0x87, 0x52, 0xec, 0x89, 0x01, 0xd7, 0xbf, 0x74, 0x3c, 0xfe, 0xce, 0x5a, 0x6d, 0x24, 0x72,
	0x0d, 0xad, 0x1e, 0x0f, 0x62, 0xc2, 0x13, 0x52, 0xff, 0xc6, 0x51, 0x73, 0x53, 0xb0, 0xf9, 0x23,
	0x0b, 0xca, 0x46, 0xc7, 0xb3, 0xba, 0x17, 0x3d, 0xe5, 0x2c, 0xe4, 0xa6, 0x9c, 0xd9, 0x34, 0xb1,
	0x98, 0x9b, 0x26, 0xd2, 0x37, 0x53, 0x9d, 0x4c, 0x0e, 0x7b, 0xf1, 0x7c, 0x63, 0x8c, 0xa9, 0xe6,
	0x5c, 0x81, 0x92, 0x86, 0x31, 0xaa, 0x43, 0xe1, 0xb1, 0xd0, 0xbc, 0x9d, 0xe4, 0x28, 0x5f, 0x43,
	0xea, 0xa6, 0xa4, 0xe0, 0xbc, 0x9f, 0x52, 0x43, 0x5a, 0x98, 0x4d, 0x51, 0xc7, 0xdd, 0x88, 0x45,
	0x17, 0x81, 0xc4, 0x5c, 0xed, 0x1d, 0xee, 0xf7, 0x78, 0x9b, 0xf5, 0xb9, 0x4e, 0x2b, 0x05, 0xda,
	0x80, 0x45, 0x43, 0x1b, 0x8f, 0xaf, 0xe8, 0xd2, 0x13, 0x06, 0x1d, 0xc9, 0xe4, 0x09, 0xb1, 0x9d,
	0x75, 0xfd, 0x56, 0x4c, 0x3d, 0x6a, 0x36, 0xfb, 0x6d, 0xd7, 0x24, 0x32, 0x9f, 0xcb, 0xe0, 0x98,
	0xfb, 0xe6, 0x7d, 0xce, 0x4c, 0x93, 0x46, 0x0a, 0xce, 0x66, 0xae, 0xae, 0x8d, 0xd7, 0x00, 0x6b,
	0xda, 0x1a, 0x70, 0xf9, 0xb7, 0x05, 0xa8, 0x8f, 0xa7, 0x55, 0x6c, 0x80, 0x37, 0xd1, 0x51, 0x3d,
	0x39, 0xec, 0x77, 0xe2, 0x5c, 0xe3, 0x42, 0x70, 0xe9, 0xbe, 0x49, 0xaa, 0x1a, 0xb1, 0x80, 0x4b,
	0x3b, 0xa2, 0xcf, 0xc9, 0x4a, 0xfe, 0xc7, 0x80, 0xab, 0xe9, 0xcf, 0x06, 0x3a, 0x35, 0xbe, 0x83,
	0x39, 0xb7, 0xcd, 0x15, 0xd9, 0xc0, 0x82, 0xda, 0xde, 0x1f, 0x65, 0x40, 0xf2, 0x01, 0xad, 0x25,
	0xa3, 0xaf, 0x4f, 0x0a, 0x74, 0x3e, 0x57, 0x5b, 0x7f, 0x50, 0xa0, 0x8b, 0x70, 0x61, 0x73, 0x18,
	0xf9, 0x21, 0xf7, 0x33, 0xec, 0x0f, 0x35, 0x56, 0x4f, 0x18, 0x95, 0xee, 0xe2, 0xb5, 0x90, 0xcf,
	0xd1, 0xc8, 0x17, 0x73, 0xd8, 0xac, 0xdc, 0x7e, 0x31, 0xb9, 0x92, 0x49, 0xfa, 0xdf, 0xbc, 0xfc,
	0x8c, 0xfe, 0x13, 0x1b, 0xb1, 0xbb, 0x91, 0xcf, 0x1f, 0xe5, 0xb0, 0x9f, 0xda, 0x74, 0x09, 0x16,
	0x12, 0xda, 0x9c, 0xf2, 0xff, 0x69, 0xd3, 0x8b, 0x50, 0xdf, 0x30, 0x16, 0x4e, 0xac, 0x42, 0x3e,
	0xb3, 0x2f, 0xff, 0xc4, 0x82, 0xfa, 0x78, 0xf6, 0x42, 0x73, 0x84, 0x22, 0xea, 0xa2, 0x17, 0x9b,
	0xd1, 0x5d, 0x8c, 0xef, 0x79, 0x0d, 0x6a, 0x17, 0x8b, 0xf4, 0xa0, 0xd4, 0xb4, 0x26, 0xb1, 0x62,
	0x6a, 0x18, 0x9b, 0x97, 0xbe, 0x62, 0x5d, 0x32, 0x8b, 0x36, 0xf6, 0x51, 0x69, 0x3b, 0xab, 0x4a,
	0x25, 0x94, 0xe8, 0xa5, 0x73, 0xd7, 0x32, 0x92, 0x0e, 0x65, 0x68, 0xaa, 0x13, 0xef, 0xb3, 0x20,
	0x24, 0x55, 0xfc, 0x1c, 0xf4, 0xb0, 0x09, 0xa9, 0x19, 0xac, 0xf8, 0x30, 0x30, 0x73, 0xd8, 0xc4,
	0x75, 0x7d, 0xd4, 0x23, 0xf3, 0x03, 0xc2, 0x37, 0x2f, 0xff, 0xea, 0xdb, 0x65, 0xeb, 0xab, 0x6f,
	0x97, 0xad, 0x6f, 0xbe, 0x5d, 0xb6, 0x3e, 0xff, 0x6e, 0x79, 0xe6, 0xab, 0xef, 0x96, 0x67, 0x7e,
	0xff, 0xdd, 0xf2, 0xcc, 0xfb, 0x64, 0xf2, 0x6f, 0x10, 0x9d, 0xb2, 0x4e, 0xaa, 0xeb, 0x7f, 0x0a,
	0x00, 0x00, 0xff, 0xff, 0xac, 0x1b, 0x2b, 0x8d, 0x21, 0x21, 0x00, 0x00,
}

func (m *SmartBlockSnapshotBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartBlockSnapshotBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SmartBlockSnapshotBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ObjectTypes) > 0 {
		for iNdEx := len(m.ObjectTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ObjectTypes[iNdEx])
			copy(dAtA[i:], m.ObjectTypes[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.ObjectTypes[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ExtraRelations) > 0 {
		for iNdEx := len(m.ExtraRelations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExtraRelations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.FileKeys != nil {
		{
			size, err := m.FileKeys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Align != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Align))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BackgroundColor) > 0 {
		i -= len(m.BackgroundColor)
		copy(dAtA[i:], m.BackgroundColor)
		i = encodeVarintModels(dAtA, i, uint64(len(m.BackgroundColor)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ChildrenIds) > 0 {
		for iNdEx := len(m.ChildrenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChildrenIds[iNdEx])
			copy(dAtA[i:], m.ChildrenIds[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.ChildrenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Restrictions != nil {
		{
			size, err := m.Restrictions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentOfSmartblock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfSmartblock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Smartblock != nil {
		{
			size, err := m.Smartblock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bookmark != nil {
		{
			size, err := m.Bookmark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfIcon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfIcon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Icon != nil {
		{
			size, err := m.Icon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfRelation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfRelation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Relation != nil {
		{
			size, err := m.Relation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfFeaturedRelations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfFeaturedRelations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FeaturedRelations != nil {
		{
			size, err := m.FeaturedRelations.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *BlockRestrictions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRestrictions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRestrictions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TargetBlockId) > 0 {
		i -= len(m.TargetBlockId)
		copy(dAtA[i:], m.TargetBlockId)
		i = encodeVarintModels(dAtA, i, uint64(len(m.TargetBlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentBookmark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.FaviconHash) > 0 {
		i -= len(m.FaviconHash)
		copy(dAtA[i:], m.FaviconHash)
		i = encodeVarintModels(dAtA, i, uint64(len(m.FaviconHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ImageHash) > 0 {
		i -= len(m.ImageHash)
		copy(dAtA[i:], m.ImageHash)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ImageHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentIcon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentIcon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFeaturedRelations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFeaturedRelations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFeaturedRelations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Color) > 0 {
		i -= len(m.Color)
		copy(dAtA[i:], m.Color)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Marks != nil {
		{
			size, err := m.Marks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMarks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMarks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMarks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if m.AddedAt != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.AddedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.Size_ != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Mime) > 0 {
		i -= len(m.Mime)
		copy(dAtA[i:], m.Mime)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Mime)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentSmartblock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentSmartblock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentSmartblock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ActiveView) > 0 {
		i -= len(m.ActiveView)
		copy(dAtA[i:], m.ActiveView)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ActiveView)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Views) > 0 {
		for iNdEx := len(m.Views) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Views[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataviewView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataviewView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataviewView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Sorts) > 0 {
		for iNdEx := len(m.Sorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataviewRelation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataviewRelation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataviewRelation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DateFormat != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.DateFormat))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeFormat != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.TimeFormat))
		i--
		dAtA[i] = 0x30
	}
	if m.DateIncludeTime {
		i--
		if m.DateIncludeTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if m.IsVisible {
		i--
		if m.IsVisible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataviewSort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataviewSort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataviewSort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RelationKey) > 0 {
		i -= len(m.RelationKey)
		copy(dAtA[i:], m.RelationKey)
		i = encodeVarintModels(dAtA, i, uint64(len(m.RelationKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataviewFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataviewFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataviewFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelationProperty) > 0 {
		i -= len(m.RelationProperty)
		copy(dAtA[i:], m.RelationProperty)
		i = encodeVarintModels(dAtA, i, uint64(len(m.RelationProperty)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Condition != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Condition))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RelationKey) > 0 {
		i -= len(m.RelationKey)
		copy(dAtA[i:], m.RelationKey)
		i = encodeVarintModels(dAtA, i, uint64(len(m.RelationKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Operator != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentRelation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentRelation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentRelation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockMetaOnly) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMetaOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockMetaOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountAvatarAvatarOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatarAvatarOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AccountAvatarAvatarOfColor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatarAvatarOfColor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Color)
	copy(dAtA[i:], m.Color)
	i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *LinkPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.FaviconUrl) > 0 {
		i -= len(m.FaviconUrl)
		copy(dAtA[i:], m.FaviconUrl)
		i = encodeVarintModels(dAtA, i, uint64(len(m.FaviconUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Restrictions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Restrictions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Restrictions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dataview) > 0 {
		for iNdEx := len(m.Dataview) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dataview[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Object) > 0 {
		dAtA24 := make([]byte, len(m.Object)*10)
		var j23 int
		for _, num := range m.Object {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintModels(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestrictionsDataviewRestrictions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestrictionsDataviewRestrictions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestrictionsDataviewRestrictions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Restrictions) > 0 {
		dAtA26 := make([]byte, len(m.Restrictions)*10)
		var j25 int
		for _, num := range m.Restrictions {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintModels(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintModels(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Types) > 0 {
		dAtA28 := make([]byte, len(m.Types)*10)
		var j27 int
		for _, num := range m.Types {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintModels(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0x42
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IconEmoji) > 0 {
		i -= len(m.IconEmoji)
		copy(dAtA[i:], m.IconEmoji)
		i = encodeVarintModels(dAtA, i, uint64(len(m.IconEmoji)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Layout != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Layout))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Layout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequiredRelations) > 0 {
		for iNdEx := len(m.RequiredRelations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequiredRelations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelationWithValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationWithValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationWithValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Relation != nil {
		{
			size, err := m.Relation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Relation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Scope != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if m.MaxCount != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MaxCount))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SelectDict) > 0 {
		for iNdEx := len(m.SelectDict) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SelectDict[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.ObjectTypes) > 0 {
		for iNdEx := len(m.ObjectTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ObjectTypes[iNdEx])
			copy(dAtA[i:], m.ObjectTypes[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.ObjectTypes[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Multi {
		i--
		if m.Multi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Hidden {
		i--
		if m.Hidden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.DataSource != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.DataSource))
		i--
		dAtA[i] = 0x28
	}
	if m.DefaultValue != nil {
		{
			size, err := m.DefaultValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Format != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Format))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelationOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelationOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelationOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Scope != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Color) > 0 {
		i -= len(m.Color)
		copy(dAtA[i:], m.Color)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Relations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Relations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Relations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for iNdEx := len(m.Relations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Relations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SmartBlockSnapshotBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.FileKeys != nil {
		l = m.FileKeys.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.ExtraRelations) > 0 {
		for _, e := range m.ExtraRelations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.ObjectTypes) > 0 {
		for _, s := range m.ObjectTypes {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Restrictions != nil {
		l = m.Restrictions.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.ChildrenIds) > 0 {
		for _, s := range m.ChildrenIds {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.BackgroundColor)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Align != 0 {
		n += 1 + sovModels(uint64(m.Align))
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *BlockContentOfSmartblock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Smartblock != nil {
		l = m.Smartblock.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bookmark != nil {
		l = m.Bookmark.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Icon != nil {
		l = m.Icon.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfRelation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Relation != nil {
		l = m.Relation.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContentOfFeaturedRelations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FeaturedRelations != nil {
		l = m.FeaturedRelations.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockRestrictions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *BlockContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *BlockContentLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TargetBlockId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *BlockContentBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ImageHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.FaviconHash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	return n
}

func (m *BlockContentIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentFeaturedRelations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.Marks != nil {
		l = m.Marks.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Checked {
		n += 2
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentTextMarks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *BlockContentTextMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Mime)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovModels(uint64(m.Size_))
	}
	if m.AddedAt != 0 {
		n += 1 + sovModels(uint64(m.AddedAt))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	return n
}

func (m *BlockContentSmartblock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Views) > 0 {
		for _, e := range m.Views {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.ActiveView)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *BlockContentDataviewView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sorts) > 0 {
		for _, e := range m.Sorts {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *BlockContentDataviewRelation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.IsVisible {
		n += 2
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	if m.DateIncludeTime {
		n += 2
	}
	if m.TimeFormat != 0 {
		n += 1 + sovModels(uint64(m.TimeFormat))
	}
	if m.DateFormat != 0 {
		n += 1 + sovModels(uint64(m.DateFormat))
	}
	return n
}

func (m *BlockContentDataviewSort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelationKey)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	return n
}

func (m *BlockContentDataviewFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operator != 0 {
		n += 1 + sovModels(uint64(m.Operator))
	}
	l = len(m.RelationKey)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Condition != 0 {
		n += 1 + sovModels(uint64(m.Condition))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.RelationProperty)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentRelation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockMetaOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovModels(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovModels(uint64(m.To))
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *AccountAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	return n
}

func (m *AccountAvatarAvatarOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *AccountAvatarAvatarOfColor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Color)
	n += 1 + l + sovModels(uint64(l))
	return n
}
func (m *LinkPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.FaviconUrl)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	return n
}

func (m *Restrictions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Object) > 0 {
		l = 0
		for _, e := range m.Object {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	if len(m.Dataview) > 0 {
		for _, e := range m.Dataview {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *RestrictionsDataviewRestrictions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Restrictions) > 0 {
		l = 0
		for _, e := range m.Restrictions {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func (m *ObjectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Layout != 0 {
		n += 1 + sovModels(uint64(m.Layout))
	}
	l = len(m.IconEmoji)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Hidden {
		n += 2
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func (m *Layout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModels(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.RequiredRelations) > 0 {
		for _, e := range m.RequiredRelations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *RelationWithValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Relation != nil {
		l = m.Relation.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Relation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Format != 0 {
		n += 1 + sovModels(uint64(m.Format))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.DefaultValue != nil {
		l = m.DefaultValue.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.DataSource != 0 {
		n += 1 + sovModels(uint64(m.DataSource))
	}
	if m.Hidden {
		n += 2
	}
	if m.ReadOnly {
		n += 2
	}
	if m.Multi {
		n += 2
	}
	if len(m.ObjectTypes) > 0 {
		for _, s := range m.ObjectTypes {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.SelectDict) > 0 {
		for _, e := range m.SelectDict {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.MaxCount != 0 {
		n += 1 + sovModels(uint64(m.MaxCount))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Scope != 0 {
		n += 2 + sovModels(uint64(m.Scope))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}

func (m *RelationOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Color)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Scope != 0 {
		n += 1 + sovModels(uint64(m.Scope))
	}
	return n
}

func (m *Relations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Relations) > 0 {
		for _, e := range m.Relations {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SmartBlockSnapshotBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartBlockSnapshotBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartBlockSnapshotBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &types.Struct{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileKeys == nil {
				m.FileKeys = &types.Struct{}
			}
			if err := m.FileKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraRelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraRelations = append(m.ExtraRelations, &Relation{})
			if err := m.ExtraRelations[len(m.ExtraRelations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTypes = append(m.ObjectTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restrictions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Restrictions == nil {
				m.Restrictions = &BlockRestrictions{}
			}
			if err := m.Restrictions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildrenIds = append(m.ChildrenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackgroundColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackgroundColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Align", wireType)
			}
			m.Align = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Align |= BlockAlign(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smartblock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentSmartblock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfSmartblock{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfText{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfFile{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfLayout{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfDiv{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bookmark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentBookmark{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfBookmark{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentIcon{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfIcon{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentLink{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfLink{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfDataview{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentRelation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfRelation{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeaturedRelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentFeaturedRelations{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfFeaturedRelations{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRestrictions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Restrictions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Restrictions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentLayoutStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBlockId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetBlockId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentLinkStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Div: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Div: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentDivStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentBookmark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bookmark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bookmark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaviconHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaviconHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LinkPreviewType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Icon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Icon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFeaturedRelations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeaturedRelations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeaturedRelations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentTextStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marks == nil {
				m.Marks = &BlockContentTextMarks{}
			}
			if err := m.Marks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMarks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &BlockContentTextMark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentTextMarkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentFileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			m.AddedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentFileState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentSmartblock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Smartblock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Smartblock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Views = append(m.Views, &BlockContentDataviewView{})
			if err := m.Views[len(m.Views)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveView", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveView = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataviewView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentDataviewViewType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sorts = append(m.Sorts, &BlockContentDataviewSort{})
			if err := m.Sorts[len(m.Sorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &BlockContentDataviewFilter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &BlockContentDataviewRelation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataviewRelation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVisible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVisible = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateIncludeTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DateIncludeTime = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeFormat", wireType)
			}
			m.TimeFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeFormat |= BlockContentDataviewRelationTimeFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateFormat", wireType)
			}
			m.DateFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DateFormat |= BlockContentDataviewRelationDateFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataviewSort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentDataviewSortType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataviewFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= BlockContentDataviewFilterOperator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			m.Condition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Condition |= BlockContentDataviewFilterCondition(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationProperty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationProperty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentRelation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMetaOnly) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMetaOnly: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMetaOnly: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &AccountAvatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Avatar = &AccountAvatarAvatarOfImage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &AccountAvatarAvatarOfColor{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaviconUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaviconUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LinkPreviewType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Restrictions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Restrictions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Restrictions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RestrictionsObjectRestriction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= RestrictionsObjectRestriction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Object = append(m.Object, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Object) == 0 {
					m.Object = make([]RestrictionsObjectRestriction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v RestrictionsObjectRestriction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= RestrictionsObjectRestriction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Object = append(m.Object, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dataview = append(m.Dataview, &RestrictionsDataviewRestrictions{})
			if err := m.Dataview[len(m.Dataview)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestrictionsDataviewRestrictions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataviewRestrictions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataviewRestrictions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v RestrictionsDataviewRestriction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= RestrictionsDataviewRestriction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Restrictions = append(m.Restrictions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Restrictions) == 0 {
					m.Restrictions = make([]RestrictionsDataviewRestriction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v RestrictionsDataviewRestriction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= RestrictionsDataviewRestriction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Restrictions = append(m.Restrictions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Restrictions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			m.Layout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layout |= ObjectTypeLayout(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IconEmoji", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IconEmoji = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 8:
			if wireType == 0 {
				var v SmartBlockType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SmartBlockType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]SmartBlockType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SmartBlockType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SmartBlockType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= ObjectTypeLayout(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredRelations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredRelations = append(m.RequiredRelations, &Relation{})
			if err := m.RequiredRelations[len(m.RequiredRelations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationWithValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelationWithValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelationWithValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Relation == nil {
				m.Relation = &Relation{}
			}
			if err := m.Relation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= RelationFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultValue == nil {
				m.DefaultValue = &types.Value{}
			}
			if err := m.DefaultValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			m.DataSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSource |= RelationDataSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hidden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hidden = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multi = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTypes = append(m.ObjectTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectDict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectDict = append(m.SelectDict, &RelationOption{})
			if err := m.SelectDict[len(m.SelectDict)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCount", wireType)
			}
			m.MaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= RelationScope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelationOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= RelationOptionScope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Relations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Relations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Relations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relations = append(m.Relations, &Relation{})
			if err := m.Relations[len(m.Relations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
