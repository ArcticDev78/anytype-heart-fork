// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: block-content.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Block_Header_Type int32

const (
	Block_Header_DASHBOARD Block_Header_Type = 0
	Block_Header_PAGE      Block_Header_Type = 1
	Block_Header_DATAVIEW  Block_Header_Type = 2
	Block_Header_TEXT      Block_Header_Type = 3
	Block_Header_FILE      Block_Header_Type = 4
	Block_Header_PICTURE   Block_Header_Type = 5
	Block_Header_VIDEO     Block_Header_Type = 6
	Block_Header_BOOKMARK  Block_Header_Type = 7
	Block_Header_LAYOUT    Block_Header_Type = 8
	Block_Header_DIV       Block_Header_Type = 9
)

var Block_Header_Type_name = map[int32]string{
	0: "DASHBOARD",
	1: "PAGE",
	2: "DATAVIEW",
	3: "TEXT",
	4: "FILE",
	5: "PICTURE",
	6: "VIDEO",
	7: "BOOKMARK",
	8: "LAYOUT",
	9: "DIV",
}

var Block_Header_Type_value = map[string]int32{
	"DASHBOARD": 0,
	"PAGE":      1,
	"DATAVIEW":  2,
	"TEXT":      3,
	"FILE":      4,
	"PICTURE":   5,
	"VIDEO":     6,
	"BOOKMARK":  7,
	"LAYOUT":    8,
	"DIV":       9,
}

func (x Block_Header_Type) String() string {
	return proto.EnumName(Block_Header_Type_name, int32(x))
}

func (Block_Header_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 0, 0}
}

type Block_ContentLayout_Style int32

const (
	Block_ContentLayout_ROW    Block_ContentLayout_Style = 0
	Block_ContentLayout_COLUMN Block_ContentLayout_Style = 1
)

var Block_ContentLayout_Style_name = map[int32]string{
	0: "ROW",
	1: "COLUMN",
}

var Block_ContentLayout_Style_value = map[string]int32{
	"ROW":    0,
	"COLUMN": 1,
}

func (x Block_ContentLayout_Style) String() string {
	return proto.EnumName(Block_ContentLayout_Style_name, int32(x))
}

func (Block_ContentLayout_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 1, 0}
}

type Block_ContentDashboard_Style int32

const (
	Block_ContentDashboard_MAIN_SCREEN Block_ContentDashboard_Style = 0
)

var Block_ContentDashboard_Style_name = map[int32]string{
	0: "MAIN_SCREEN",
}

var Block_ContentDashboard_Style_value = map[string]int32{
	"MAIN_SCREEN": 0,
}

func (x Block_ContentDashboard_Style) String() string {
	return proto.EnumName(Block_ContentDashboard_Style_name, int32(x))
}

func (Block_ContentDashboard_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 3, 0}
}

type Block_ContentText_Style int32

const (
	Block_ContentText_p     Block_ContentText_Style = 0
	Block_ContentText_h1    Block_ContentText_Style = 1
	Block_ContentText_h2    Block_ContentText_Style = 2
	Block_ContentText_h3    Block_ContentText_Style = 3
	Block_ContentText_h4    Block_ContentText_Style = 4
	Block_ContentText_quote Block_ContentText_Style = 5
	Block_ContentText_code  Block_ContentText_Style = 6
)

var Block_ContentText_Style_name = map[int32]string{
	0: "p",
	1: "h1",
	2: "h2",
	3: "h3",
	4: "h4",
	5: "quote",
	6: "code",
}

var Block_ContentText_Style_value = map[string]int32{
	"p":     0,
	"h1":    1,
	"h2":    2,
	"h3":    3,
	"h4":    4,
	"quote": 5,
	"code":  6,
}

func (x Block_ContentText_Style) String() string {
	return proto.EnumName(Block_ContentText_Style_name, int32(x))
}

func (Block_ContentText_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5, 0}
}

type Block_ContentText_MarkerType int32

const (
	Block_ContentText_none   Block_ContentText_MarkerType = 0
	Block_ContentText_number Block_ContentText_MarkerType = 1
	Block_ContentText_bullet Block_ContentText_MarkerType = 2
)

var Block_ContentText_MarkerType_name = map[int32]string{
	0: "none",
	1: "number",
	2: "bullet",
}

var Block_ContentText_MarkerType_value = map[string]int32{
	"none":   0,
	"number": 1,
	"bullet": 2,
}

func (x Block_ContentText_MarkerType) String() string {
	return proto.EnumName(Block_ContentText_MarkerType_name, int32(x))
}

func (Block_ContentText_MarkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5, 1}
}

type Block_ContentText_Mark_Type int32

const (
	Block_ContentText_Mark_STRIKETHROUGH Block_ContentText_Mark_Type = 0
	Block_ContentText_Mark_KEYBOARD      Block_ContentText_Mark_Type = 1
	Block_ContentText_Mark_ITALIC        Block_ContentText_Mark_Type = 2
	Block_ContentText_Mark_BOLD          Block_ContentText_Mark_Type = 3
	Block_ContentText_Mark_LINK          Block_ContentText_Mark_Type = 4
)

var Block_ContentText_Mark_Type_name = map[int32]string{
	0: "STRIKETHROUGH",
	1: "KEYBOARD",
	2: "ITALIC",
	3: "BOLD",
	4: "LINK",
}

var Block_ContentText_Mark_Type_value = map[string]int32{
	"STRIKETHROUGH": 0,
	"KEYBOARD":      1,
	"ITALIC":        2,
	"BOLD":          3,
	"LINK":          4,
}

func (x Block_ContentText_Mark_Type) String() string {
	return proto.EnumName(Block_ContentText_Mark_Type_name, int32(x))
}

func (Block_ContentText_Mark_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5, 1, 0}
}

type Block_ContentMedia_State int32

const (
	Block_ContentMedia_EMPTY       Block_ContentMedia_State = 0
	Block_ContentMedia_UPLOADING   Block_ContentMedia_State = 1
	Block_ContentMedia_PREVIEW     Block_ContentMedia_State = 2
	Block_ContentMedia_DOWNLOADING Block_ContentMedia_State = 3
	Block_ContentMedia_DONE        Block_ContentMedia_State = 4
)

var Block_ContentMedia_State_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var Block_ContentMedia_State_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x Block_ContentMedia_State) String() string {
	return proto.EnumName(Block_ContentMedia_State_name, int32(x))
}

func (Block_ContentMedia_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 6, 0}
}

type Block_ContentPage_Style int32

const (
	Block_ContentPage_EMPTY    Block_ContentPage_Style = 0
	Block_ContentPage_TASK     Block_ContentPage_Style = 1
	Block_ContentPage_BOOKMARK Block_ContentPage_Style = 2
	Block_ContentPage_SET      Block_ContentPage_Style = 3
)

var Block_ContentPage_Style_name = map[int32]string{
	0: "EMPTY",
	1: "TASK",
	2: "BOOKMARK",
	3: "SET",
}

var Block_ContentPage_Style_value = map[string]int32{
	"EMPTY":    0,
	"TASK":     1,
	"BOOKMARK": 2,
	"SET":      3,
}

func (x Block_ContentPage_Style) String() string {
	return proto.EnumName(Block_ContentPage_Style_name, int32(x))
}

func (Block_ContentPage_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 7, 0}
}

type Block struct {
	Header   *Block_Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Children []string      `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*Block_Dashboard
	//	*Block_Page
	//	*Block_Dataview
	//	*Block_Text
	//	*Block_Media
	//	*Block_Layout
	//	*Block_Div
	Content isBlock_Content `protobuf_oneof:"content"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

type isBlock_Content interface {
	isBlock_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Block_Dashboard struct {
	Dashboard *Block_ContentDashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type Block_Page struct {
	Page *Block_ContentPage `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type Block_Dataview struct {
	Dataview *Block_ContentDataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type Block_Text struct {
	Text *Block_ContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type Block_Media struct {
	Media *Block_ContentMedia `protobuf:"bytes,15,opt,name=media,proto3,oneof" json:"media,omitempty"`
}
type Block_Layout struct {
	Layout *Block_ContentLayout `protobuf:"bytes,16,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type Block_Div struct {
	Div *Block_ContentDiv `protobuf:"bytes,17,opt,name=div,proto3,oneof" json:"div,omitempty"`
}

func (*Block_Dashboard) isBlock_Content() {}
func (*Block_Page) isBlock_Content()      {}
func (*Block_Dataview) isBlock_Content()  {}
func (*Block_Text) isBlock_Content()      {}
func (*Block_Media) isBlock_Content()     {}
func (*Block_Layout) isBlock_Content()    {}
func (*Block_Div) isBlock_Content()       {}

func (m *Block) GetContent() isBlock_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Block) GetHeader() *Block_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Block) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Block) GetDashboard() *Block_ContentDashboard {
	if x, ok := m.GetContent().(*Block_Dashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *Block) GetPage() *Block_ContentPage {
	if x, ok := m.GetContent().(*Block_Page); ok {
		return x.Page
	}
	return nil
}

func (m *Block) GetDataview() *Block_ContentDataview {
	if x, ok := m.GetContent().(*Block_Dataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *Block) GetText() *Block_ContentText {
	if x, ok := m.GetContent().(*Block_Text); ok {
		return x.Text
	}
	return nil
}

func (m *Block) GetMedia() *Block_ContentMedia {
	if x, ok := m.GetContent().(*Block_Media); ok {
		return x.Media
	}
	return nil
}

func (m *Block) GetLayout() *Block_ContentLayout {
	if x, ok := m.GetContent().(*Block_Layout); ok {
		return x.Layout
	}
	return nil
}

func (m *Block) GetDiv() *Block_ContentDiv {
	if x, ok := m.GetContent().(*Block_Div); ok {
		return x.Div
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Block) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Block_Dashboard)(nil),
		(*Block_Page)(nil),
		(*Block_Dataview)(nil),
		(*Block_Text)(nil),
		(*Block_Media)(nil),
		(*Block_Layout)(nil),
		(*Block_Div)(nil),
	}
}

type Block_Header struct {
	Id          string                    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        Block_Header_Type         `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Block_Header_Type" json:"type,omitempty"`
	Fields      *Struct                   `protobuf:"bytes,3,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *Block_Header_Permissions `protobuf:"bytes,4,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Block_Header) Reset()         { *m = Block_Header{} }
func (m *Block_Header) String() string { return proto.CompactTextString(m) }
func (*Block_Header) ProtoMessage()    {}
func (*Block_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 0}
}
func (m *Block_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_Header.Merge(m, src)
}
func (m *Block_Header) XXX_Size() int {
	return m.Size()
}
func (m *Block_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Block_Header proto.InternalMessageInfo

func (m *Block_Header) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block_Header) GetType() Block_Header_Type {
	if m != nil {
		return m.Type
	}
	return Block_Header_DASHBOARD
}

func (m *Block_Header) GetFields() *Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Block_Header) GetPermissions() *Block_Header_Permissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type Block_Header_Permissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *Block_Header_Permissions) Reset()         { *m = Block_Header_Permissions{} }
func (m *Block_Header_Permissions) String() string { return proto.CompactTextString(m) }
func (*Block_Header_Permissions) ProtoMessage()    {}
func (*Block_Header_Permissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 0, 0}
}
func (m *Block_Header_Permissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_Header_Permissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_Header_Permissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_Header_Permissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_Header_Permissions.Merge(m, src)
}
func (m *Block_Header_Permissions) XXX_Size() int {
	return m.Size()
}
func (m *Block_Header_Permissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_Header_Permissions.DiscardUnknown(m)
}

var xxx_messageInfo_Block_Header_Permissions proto.InternalMessageInfo

func (m *Block_Header_Permissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Block_Header_Permissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *Block_Header_Permissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *Block_Header_Permissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *Block_Header_Permissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type Block_ContentLayout struct {
	Style Block_ContentLayout_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Block_ContentLayout_Style" json:"style,omitempty"`
}

func (m *Block_ContentLayout) Reset()         { *m = Block_ContentLayout{} }
func (m *Block_ContentLayout) String() string { return proto.CompactTextString(m) }
func (*Block_ContentLayout) ProtoMessage()    {}
func (*Block_ContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 1}
}
func (m *Block_ContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentLayout.Merge(m, src)
}
func (m *Block_ContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentLayout proto.InternalMessageInfo

func (m *Block_ContentLayout) GetStyle() Block_ContentLayout_Style {
	if m != nil {
		return m.Style
	}
	return Block_ContentLayout_ROW
}

type Block_ContentDiv struct {
}

func (m *Block_ContentDiv) Reset()         { *m = Block_ContentDiv{} }
func (m *Block_ContentDiv) String() string { return proto.CompactTextString(m) }
func (*Block_ContentDiv) ProtoMessage()    {}
func (*Block_ContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 2}
}
func (m *Block_ContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentDiv.Merge(m, src)
}
func (m *Block_ContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentDiv proto.InternalMessageInfo

type Block_ContentDashboard struct {
	Style   Block_ContentDashboard_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Block_ContentDashboard_Style" json:"style,omitempty"`
	Headers []*Block_Header              `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *Block_ContentDashboard) Reset()         { *m = Block_ContentDashboard{} }
func (m *Block_ContentDashboard) String() string { return proto.CompactTextString(m) }
func (*Block_ContentDashboard) ProtoMessage()    {}
func (*Block_ContentDashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 3}
}
func (m *Block_ContentDashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentDashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentDashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentDashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentDashboard.Merge(m, src)
}
func (m *Block_ContentDashboard) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentDashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentDashboard.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentDashboard proto.InternalMessageInfo

func (m *Block_ContentDashboard) GetStyle() Block_ContentDashboard_Style {
	if m != nil {
		return m.Style
	}
	return Block_ContentDashboard_MAIN_SCREEN
}

func (m *Block_ContentDashboard) GetHeaders() []*Block_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

type Block_ContentDataview struct {
}

func (m *Block_ContentDataview) Reset()         { *m = Block_ContentDataview{} }
func (m *Block_ContentDataview) String() string { return proto.CompactTextString(m) }
func (*Block_ContentDataview) ProtoMessage()    {}
func (*Block_ContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 4}
}
func (m *Block_ContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentDataview.Merge(m, src)
}
func (m *Block_ContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentDataview proto.InternalMessageInfo

type Block_ContentText struct {
	Text       string                       `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      Block_ContentText_Style      `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.Block_ContentText_Style" json:"style,omitempty"`
	MarksList  *Block_ContentText_Marks     `protobuf:"bytes,3,opt,name=marksList,proto3" json:"marksList,omitempty"`
	Toggleable bool                         `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	MarkerType Block_ContentText_MarkerType `protobuf:"varint,5,opt,name=markerType,proto3,enum=anytype.Block_ContentText_MarkerType" json:"markerType,omitempty"`
	Checkable  bool                         `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                         `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *Block_ContentText) Reset()         { *m = Block_ContentText{} }
func (m *Block_ContentText) String() string { return proto.CompactTextString(m) }
func (*Block_ContentText) ProtoMessage()    {}
func (*Block_ContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5}
}
func (m *Block_ContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentText.Merge(m, src)
}
func (m *Block_ContentText) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentText.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentText proto.InternalMessageInfo

func (m *Block_ContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Block_ContentText) GetStyle() Block_ContentText_Style {
	if m != nil {
		return m.Style
	}
	return Block_ContentText_p
}

func (m *Block_ContentText) GetMarksList() *Block_ContentText_Marks {
	if m != nil {
		return m.MarksList
	}
	return nil
}

func (m *Block_ContentText) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *Block_ContentText) GetMarkerType() Block_ContentText_MarkerType {
	if m != nil {
		return m.MarkerType
	}
	return Block_ContentText_none
}

func (m *Block_ContentText) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *Block_ContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type Block_ContentText_Marks struct {
	Marks []*Block_ContentText_Mark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *Block_ContentText_Marks) Reset()         { *m = Block_ContentText_Marks{} }
func (m *Block_ContentText_Marks) String() string { return proto.CompactTextString(m) }
func (*Block_ContentText_Marks) ProtoMessage()    {}
func (*Block_ContentText_Marks) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5, 0}
}
func (m *Block_ContentText_Marks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentText_Marks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentText_Marks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentText_Marks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentText_Marks.Merge(m, src)
}
func (m *Block_ContentText_Marks) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentText_Marks) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentText_Marks.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentText_Marks proto.InternalMessageInfo

func (m *Block_ContentText_Marks) GetMarks() []*Block_ContentText_Mark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type Block_ContentText_Mark struct {
	Range *Range                      `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  Block_ContentText_Mark_Type `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Block_ContentText_Mark_Type" json:"type,omitempty"`
	Param string                      `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *Block_ContentText_Mark) Reset()         { *m = Block_ContentText_Mark{} }
func (m *Block_ContentText_Mark) String() string { return proto.CompactTextString(m) }
func (*Block_ContentText_Mark) ProtoMessage()    {}
func (*Block_ContentText_Mark) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 5, 1}
}
func (m *Block_ContentText_Mark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentText_Mark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentText_Mark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentText_Mark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentText_Mark.Merge(m, src)
}
func (m *Block_ContentText_Mark) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentText_Mark) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentText_Mark.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentText_Mark proto.InternalMessageInfo

func (m *Block_ContentText_Mark) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Block_ContentText_Mark) GetType() Block_ContentText_Mark_Type {
	if m != nil {
		return m.Type
	}
	return Block_ContentText_Mark_STRIKETHROUGH
}

func (m *Block_ContentText_Mark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type Block_ContentMedia struct {
	Content []byte                   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	State   Block_ContentMedia_State `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.Block_ContentMedia_State" json:"state,omitempty"`
	// Types that are valid to be assigned to Preview:
	//	*Block_ContentMedia_Video
	//	*Block_ContentMedia_Image
	//	*Block_ContentMedia_File
	Preview isBlock_ContentMedia_Preview `protobuf_oneof:"preview"`
}

func (m *Block_ContentMedia) Reset()         { *m = Block_ContentMedia{} }
func (m *Block_ContentMedia) String() string { return proto.CompactTextString(m) }
func (*Block_ContentMedia) ProtoMessage()    {}
func (*Block_ContentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 6}
}
func (m *Block_ContentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentMedia.Merge(m, src)
}
func (m *Block_ContentMedia) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentMedia proto.InternalMessageInfo

type isBlock_ContentMedia_Preview interface {
	isBlock_ContentMedia_Preview()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Block_ContentMedia_Video struct {
	Video *Block_ContentMedia_VideoPreview `protobuf:"bytes,101,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type Block_ContentMedia_Image struct {
	Image *Block_ContentMedia_ImagePreview `protobuf:"bytes,102,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type Block_ContentMedia_File struct {
	File *Block_ContentMedia_FilePreview `protobuf:"bytes,103,opt,name=file,proto3,oneof" json:"file,omitempty"`
}

func (*Block_ContentMedia_Video) isBlock_ContentMedia_Preview() {}
func (*Block_ContentMedia_Image) isBlock_ContentMedia_Preview() {}
func (*Block_ContentMedia_File) isBlock_ContentMedia_Preview()  {}

func (m *Block_ContentMedia) GetPreview() isBlock_ContentMedia_Preview {
	if m != nil {
		return m.Preview
	}
	return nil
}

func (m *Block_ContentMedia) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Block_ContentMedia) GetState() Block_ContentMedia_State {
	if m != nil {
		return m.State
	}
	return Block_ContentMedia_EMPTY
}

func (m *Block_ContentMedia) GetVideo() *Block_ContentMedia_VideoPreview {
	if x, ok := m.GetPreview().(*Block_ContentMedia_Video); ok {
		return x.Video
	}
	return nil
}

func (m *Block_ContentMedia) GetImage() *Block_ContentMedia_ImagePreview {
	if x, ok := m.GetPreview().(*Block_ContentMedia_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Block_ContentMedia) GetFile() *Block_ContentMedia_FilePreview {
	if x, ok := m.GetPreview().(*Block_ContentMedia_File); ok {
		return x.File
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Block_ContentMedia) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Block_ContentMedia_Video)(nil),
		(*Block_ContentMedia_Image)(nil),
		(*Block_ContentMedia_File)(nil),
	}
}

type Block_ContentMedia_VideoPreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Block_ContentMedia_VideoPreview) Reset()         { *m = Block_ContentMedia_VideoPreview{} }
func (m *Block_ContentMedia_VideoPreview) String() string { return proto.CompactTextString(m) }
func (*Block_ContentMedia_VideoPreview) ProtoMessage()    {}
func (*Block_ContentMedia_VideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 6, 0}
}
func (m *Block_ContentMedia_VideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentMedia_VideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentMedia_VideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentMedia_VideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentMedia_VideoPreview.Merge(m, src)
}
func (m *Block_ContentMedia_VideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentMedia_VideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentMedia_VideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentMedia_VideoPreview proto.InternalMessageInfo

func (m *Block_ContentMedia_VideoPreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Block_ContentMedia_VideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Block_ContentMedia_VideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Block_ContentMedia_ImagePreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Block_ContentMedia_ImagePreview) Reset()         { *m = Block_ContentMedia_ImagePreview{} }
func (m *Block_ContentMedia_ImagePreview) String() string { return proto.CompactTextString(m) }
func (*Block_ContentMedia_ImagePreview) ProtoMessage()    {}
func (*Block_ContentMedia_ImagePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 6, 1}
}
func (m *Block_ContentMedia_ImagePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentMedia_ImagePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentMedia_ImagePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentMedia_ImagePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentMedia_ImagePreview.Merge(m, src)
}
func (m *Block_ContentMedia_ImagePreview) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentMedia_ImagePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentMedia_ImagePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentMedia_ImagePreview proto.InternalMessageInfo

func (m *Block_ContentMedia_ImagePreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Block_ContentMedia_ImagePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Block_ContentMedia_ImagePreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Block_ContentMedia_FilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *Block_ContentMedia_FilePreview) Reset()         { *m = Block_ContentMedia_FilePreview{} }
func (m *Block_ContentMedia_FilePreview) String() string { return proto.CompactTextString(m) }
func (*Block_ContentMedia_FilePreview) ProtoMessage()    {}
func (*Block_ContentMedia_FilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 6, 2}
}
func (m *Block_ContentMedia_FilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentMedia_FilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentMedia_FilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentMedia_FilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentMedia_FilePreview.Merge(m, src)
}
func (m *Block_ContentMedia_FilePreview) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentMedia_FilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentMedia_FilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentMedia_FilePreview proto.InternalMessageInfo

func (m *Block_ContentMedia_FilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Block_ContentMedia_FilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type Block_ContentPage struct {
	Style  Block_ContentPage_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Block_ContentPage_Style" json:"style,omitempty"`
	Blocks []*Block                `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *Block_ContentPage) Reset()         { *m = Block_ContentPage{} }
func (m *Block_ContentPage) String() string { return proto.CompactTextString(m) }
func (*Block_ContentPage) ProtoMessage()    {}
func (*Block_ContentPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ca37ac4b5b7ef96, []int{0, 7}
}
func (m *Block_ContentPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block_ContentPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block_ContentPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block_ContentPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block_ContentPage.Merge(m, src)
}
func (m *Block_ContentPage) XXX_Size() int {
	return m.Size()
}
func (m *Block_ContentPage) XXX_DiscardUnknown() {
	xxx_messageInfo_Block_ContentPage.DiscardUnknown(m)
}

var xxx_messageInfo_Block_ContentPage proto.InternalMessageInfo

func (m *Block_ContentPage) GetStyle() Block_ContentPage_Style {
	if m != nil {
		return m.Style
	}
	return Block_ContentPage_EMPTY
}

func (m *Block_ContentPage) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func init() {
	proto.RegisterEnum("anytype.Block_Header_Type", Block_Header_Type_name, Block_Header_Type_value)
	proto.RegisterEnum("anytype.Block_ContentLayout_Style", Block_ContentLayout_Style_name, Block_ContentLayout_Style_value)
	proto.RegisterEnum("anytype.Block_ContentDashboard_Style", Block_ContentDashboard_Style_name, Block_ContentDashboard_Style_value)
	proto.RegisterEnum("anytype.Block_ContentText_Style", Block_ContentText_Style_name, Block_ContentText_Style_value)
	proto.RegisterEnum("anytype.Block_ContentText_MarkerType", Block_ContentText_MarkerType_name, Block_ContentText_MarkerType_value)
	proto.RegisterEnum("anytype.Block_ContentText_Mark_Type", Block_ContentText_Mark_Type_name, Block_ContentText_Mark_Type_value)
	proto.RegisterEnum("anytype.Block_ContentMedia_State", Block_ContentMedia_State_name, Block_ContentMedia_State_value)
	proto.RegisterEnum("anytype.Block_ContentPage_Style", Block_ContentPage_Style_name, Block_ContentPage_Style_value)
	proto.RegisterType((*Block)(nil), "anytype.Block")
	proto.RegisterType((*Block_Header)(nil), "anytype.Block.Header")
	proto.RegisterType((*Block_Header_Permissions)(nil), "anytype.Block.Header.Permissions")
	proto.RegisterType((*Block_ContentLayout)(nil), "anytype.Block.ContentLayout")
	proto.RegisterType((*Block_ContentDiv)(nil), "anytype.Block.ContentDiv")
	proto.RegisterType((*Block_ContentDashboard)(nil), "anytype.Block.ContentDashboard")
	proto.RegisterType((*Block_ContentDataview)(nil), "anytype.Block.ContentDataview")
	proto.RegisterType((*Block_ContentText)(nil), "anytype.Block.ContentText")
	proto.RegisterType((*Block_ContentText_Marks)(nil), "anytype.Block.ContentText.Marks")
	proto.RegisterType((*Block_ContentText_Mark)(nil), "anytype.Block.ContentText.Mark")
	proto.RegisterType((*Block_ContentMedia)(nil), "anytype.Block.ContentMedia")
	proto.RegisterType((*Block_ContentMedia_VideoPreview)(nil), "anytype.Block.ContentMedia.VideoPreview")
	proto.RegisterType((*Block_ContentMedia_ImagePreview)(nil), "anytype.Block.ContentMedia.ImagePreview")
	proto.RegisterType((*Block_ContentMedia_FilePreview)(nil), "anytype.Block.ContentMedia.FilePreview")
	proto.RegisterType((*Block_ContentPage)(nil), "anytype.Block.ContentPage")
}

func init() { proto.RegisterFile("block-content.proto", fileDescriptor_7ca37ac4b5b7ef96) }

var fileDescriptor_7ca37ac4b5b7ef96 = []byte{
	// 1253 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x73, 0xdb, 0x44,
	0x14, 0x97, 0x6c, 0xc9, 0x7f, 0x9e, 0x9d, 0x64, 0xbb, 0x14, 0x46, 0x88, 0x8c, 0x9b, 0x7a, 0x0a,
	0xcd, 0x25, 0x06, 0x1a, 0x5a, 0x3a, 0x03, 0x14, 0x1c, 0x5b, 0x8d, 0x35, 0x71, 0x2c, 0xcf, 0x5a,
	0x49, 0x29, 0x17, 0x46, 0xb6, 0xb6, 0xb6, 0xa6, 0xb2, 0x64, 0x64, 0x25, 0x6d, 0x66, 0xf8, 0x10,
	0x9c, 0x39, 0xf2, 0x05, 0x38, 0xf1, 0x11, 0x98, 0xe1, 0xd8, 0x23, 0x47, 0x68, 0xbf, 0x03, 0x67,
	0x66, 0x77, 0x25, 0x5b, 0x2e, 0x89, 0x73, 0xe1, 0xa4, 0x7d, 0xbb, 0xbf, 0xdf, 0x7b, 0x6f, 0xf7,
	0xfd, 0x13, 0xbc, 0x33, 0xf4, 0xc3, 0xd1, 0xf3, 0xbd, 0x51, 0x18, 0xc4, 0x34, 0x88, 0x1b, 0xb3,
	0x28, 0x8c, 0x43, 0x5c, 0x74, 0x82, 0x8b, 0xf8, 0x62, 0x46, 0xf5, 0xea, 0x3c, 0x8e, 0xce, 0x46,
	0xc9, 0xb6, 0x7e, 0x73, 0x4c, 0x03, 0x1a, 0x39, 0xfe, 0xde, 0x34, 0x74, 0xa9, 0x3f, 0x17, 0xbb,
	0xf5, 0x7f, 0x6e, 0x82, 0x7a, 0xc0, 0x94, 0xe0, 0x3d, 0x28, 0x4c, 0xa8, 0xe3, 0xd2, 0x48, 0x93,
	0x77, 0xe4, 0xdd, 0xca, 0xbd, 0x77, 0x1b, 0x89, 0x9e, 0x06, 0x3f, 0x6f, 0x74, 0xf8, 0x21, 0x49,
	0x40, 0x58, 0x87, 0xd2, 0x68, 0xe2, 0xf9, 0x6e, 0x44, 0x03, 0x2d, 0xb7, 0x93, 0xdf, 0x2d, 0x93,
	0x85, 0x8c, 0xbf, 0x86, 0xb2, 0xeb, 0xcc, 0x27, 0xc3, 0xd0, 0x89, 0x5c, 0xad, 0xc2, 0xb5, 0xdd,
	0x7a, 0x4b, 0x5b, 0x4b, 0xb8, 0xdc, 0x4e, 0x61, 0x1d, 0x89, 0x2c, 0x39, 0xf8, 0x13, 0x50, 0x66,
	0xce, 0x98, 0x6a, 0x55, 0xce, 0xd5, 0x2f, 0xe7, 0xf6, 0x9d, 0x31, 0xed, 0x48, 0x84, 0x23, 0xf1,
	0x97, 0x50, 0x72, 0x9d, 0xd8, 0x39, 0xf7, 0xe8, 0x0b, 0x6d, 0x83, 0xb3, 0x6a, 0x57, 0x59, 0x14,
	0xa8, 0x8e, 0x44, 0x16, 0x0c, 0x66, 0x2f, 0xa6, 0x2f, 0x63, 0x6d, 0x73, 0x9d, 0x3d, 0x9b, 0xbe,
	0x8c, 0x99, 0x3d, 0x86, 0xc4, 0xfb, 0xa0, 0x4e, 0xa9, 0xeb, 0x39, 0xda, 0x16, 0xa7, 0x7c, 0x70,
	0x39, 0xe5, 0x98, 0x41, 0x3a, 0x12, 0x11, 0x58, 0xfc, 0x00, 0x0a, 0xbe, 0x73, 0x11, 0x9e, 0xc5,
	0x1a, 0xe2, 0xac, 0xed, 0xcb, 0x59, 0x5d, 0x8e, 0xe9, 0x48, 0x24, 0x41, 0xe3, 0x3d, 0xc8, 0xbb,
	0xde, 0xb9, 0x76, 0x83, 0x93, 0xde, 0xbf, 0xe2, 0x5e, 0xde, 0x79, 0x47, 0x22, 0x0c, 0xa7, 0xff,
	0x9a, 0x87, 0x82, 0x88, 0x16, 0xde, 0x84, 0x9c, 0xe7, 0xf2, 0x80, 0x96, 0x49, 0xce, 0x73, 0x71,
	0x03, 0x14, 0x46, 0xd5, 0x72, 0x3b, 0xf2, 0xee, 0xe6, 0x7f, 0x2e, 0x2a, 0x48, 0x0d, 0xfb, 0x62,
	0x46, 0x09, 0xc7, 0xe1, 0xbb, 0x50, 0x78, 0xe6, 0x51, 0xdf, 0x9d, 0x6b, 0x79, 0x6e, 0x7c, 0x6b,
	0xc1, 0x18, 0xf0, 0xdc, 0x22, 0xc9, 0x31, 0x6e, 0x41, 0x65, 0x46, 0xa3, 0xa9, 0x37, 0x9f, 0x7b,
	0x61, 0x30, 0xd7, 0x14, 0x8e, 0xbe, 0x7d, 0xb9, 0xfe, 0xfe, 0x12, 0x48, 0xb2, 0x2c, 0xfd, 0x02,
	0x2a, 0x99, 0x33, 0x8c, 0x41, 0x89, 0xa8, 0x23, 0xdc, 0x2f, 0x11, 0xbe, 0x66, 0x7b, 0xd4, 0xf5,
	0x62, 0x7e, 0x81, 0x12, 0xe1, 0x6b, 0xfc, 0x1e, 0x14, 0x22, 0x3a, 0x0d, 0xcf, 0x29, 0x77, 0xb2,
	0x44, 0x12, 0x89, 0x61, 0xdd, 0xc8, 0x19, 0x73, 0x67, 0x4a, 0x84, 0xaf, 0x19, 0xd6, 0x8d, 0xc2,
	0x99, 0x15, 0x68, 0xaa, 0xc0, 0x0a, 0xa9, 0xfe, 0x23, 0x28, 0xec, 0xda, 0x78, 0x03, 0xca, 0xed,
	0xe6, 0xa0, 0x73, 0x60, 0x35, 0x49, 0x1b, 0x49, 0xb8, 0x04, 0x4a, 0xbf, 0x79, 0x68, 0x20, 0x19,
	0x57, 0xa1, 0xd4, 0x6e, 0xda, 0xcd, 0x53, 0xd3, 0x78, 0x82, 0x72, 0x6c, 0xdf, 0x36, 0xbe, 0xb5,
	0x51, 0x9e, 0xad, 0x1e, 0x9b, 0x5d, 0x03, 0x29, 0xb8, 0x02, 0xc5, 0xbe, 0xd9, 0xb2, 0x4f, 0x88,
	0x81, 0x54, 0x5c, 0x06, 0xf5, 0xd4, 0x6c, 0x1b, 0x16, 0x2a, 0x30, 0xe6, 0x81, 0x65, 0x1d, 0x1d,
	0x37, 0xc9, 0x11, 0x2a, 0x62, 0x80, 0x42, 0xb7, 0xf9, 0xd4, 0x3a, 0xb1, 0x51, 0x09, 0x17, 0x21,
	0xdf, 0x36, 0x4f, 0x51, 0x59, 0x1f, 0xc3, 0xc6, 0x4a, 0xec, 0xf1, 0x43, 0x50, 0xe7, 0xf1, 0x85,
	0x4f, 0xf9, 0xdd, 0x37, 0xef, 0xd5, 0xd7, 0x25, 0x4a, 0x63, 0xc0, 0x90, 0x44, 0x10, 0xea, 0xdb,
	0xa0, 0x72, 0x99, 0x29, 0x27, 0xd6, 0x13, 0x24, 0x31, 0x8b, 0x2d, 0xab, 0x7b, 0x72, 0xdc, 0x43,
	0xb2, 0x5e, 0x05, 0x58, 0xe6, 0x8b, 0xfe, 0xb3, 0x0c, 0xe8, 0xed, 0x42, 0xc4, 0x5f, 0xac, 0x9a,
	0xfe, 0xf0, 0x9a, 0xc2, 0x5d, 0xb1, 0x8e, 0x3f, 0x86, 0xa2, 0xe8, 0x0f, 0x73, 0xde, 0x14, 0xae,
	0xec, 0x22, 0x29, 0xaa, 0xae, 0xa5, 0xee, 0x6e, 0x41, 0xe5, 0xb8, 0x69, 0xf6, 0xbe, 0x1f, 0xb4,
	0x88, 0x61, 0xf4, 0x90, 0xa4, 0xdf, 0x80, 0xad, 0xb7, 0x4a, 0x56, 0xff, 0x4d, 0x85, 0x4a, 0xa6,
	0x18, 0x59, 0x80, 0x79, 0xd9, 0x8a, 0xfc, 0x16, 0x85, 0xf9, 0x20, 0x75, 0x5f, 0xa4, 0xf8, 0xce,
	0xd5, 0xb5, 0xbc, 0xea, 0xf9, 0x23, 0x28, 0x4f, 0x9d, 0xe8, 0xf9, 0xbc, 0xeb, 0xcd, 0xe3, 0x24,
	0xd9, 0xd7, 0x71, 0x8f, 0x19, 0x96, 0x2c, 0x29, 0xb8, 0x06, 0x10, 0x87, 0xe3, 0xb1, 0x4f, 0x9d,
	0xa1, 0x4f, 0x93, 0x94, 0xcb, 0xec, 0x60, 0x03, 0x80, 0x81, 0x69, 0xc4, 0xd2, 0x8c, 0x27, 0xdf,
	0x95, 0x6f, 0xbb, 0x30, 0x20, 0xc0, 0x24, 0x43, 0xc4, 0xdb, 0x50, 0x1e, 0x4d, 0xe8, 0xe8, 0x39,
	0xb7, 0x52, 0xe0, 0x56, 0x96, 0x1b, 0x58, 0x83, 0x22, 0x17, 0xa8, 0xab, 0x15, 0xf9, 0x59, 0x2a,
	0xea, 0x8f, 0x40, 0xe5, 0x2e, 0xe3, 0xfb, 0xa0, 0x72, 0xa7, 0x35, 0x99, 0xc7, 0xe7, 0xd6, 0x35,
	0x2e, 0x10, 0x81, 0xd6, 0x7f, 0x97, 0x41, 0x61, 0x32, 0xbe, 0x03, 0x6a, 0xe4, 0x04, 0x63, 0x9a,
	0x4c, 0x89, 0xcd, 0x05, 0x9f, 0xb0, 0x5d, 0x22, 0x0e, 0xf1, 0xc3, 0x95, 0x3e, 0x73, 0xe7, 0x1a,
	0x23, 0xd9, 0x8e, 0x73, 0x13, 0xd4, 0x99, 0x13, 0x39, 0x53, 0x1e, 0x83, 0x32, 0x11, 0x42, 0xfd,
	0x30, 0x29, 0xcf, 0x1b, 0xb0, 0x31, 0xb0, 0x89, 0x79, 0x64, 0xd8, 0x1d, 0x62, 0x9d, 0x1c, 0x76,
	0x90, 0xc4, 0xca, 0xeb, 0xc8, 0x78, 0x2a, 0x0a, 0x56, 0x66, 0xc9, 0x6e, 0xda, 0xcd, 0xae, 0xd9,
	0x12, 0x45, 0x7a, 0x60, 0x75, 0xdb, 0xa2, 0x48, 0xbb, 0x66, 0xef, 0x08, 0x29, 0xf5, 0x56, 0x9a,
	0x6f, 0x2a, 0xc8, 0x33, 0x24, 0xe1, 0x02, 0xe4, 0x26, 0x9f, 0x22, 0x99, 0x7f, 0xef, 0xa1, 0x1c,
	0xff, 0xee, 0xa3, 0x3c, 0xff, 0x7e, 0x86, 0x14, 0x56, 0xc7, 0x3f, 0x9c, 0x85, 0x31, 0x45, 0x2a,
	0x53, 0x32, 0x0a, 0x5d, 0x8a, 0x0a, 0xf5, 0x06, 0xc0, 0x32, 0x3c, 0x6c, 0x3f, 0x08, 0x03, 0x2a,
	0x2a, 0x2d, 0x38, 0x9b, 0x0e, 0x69, 0x24, 0x1c, 0x19, 0x9e, 0xf9, 0x3e, 0x8d, 0x51, 0x4e, 0xff,
	0x5b, 0x81, 0x6a, 0x76, 0x22, 0xf0, 0x38, 0x09, 0x99, 0x3f, 0x63, 0x95, 0xa4, 0x22, 0xfe, 0x9c,
	0xa5, 0xaf, 0x13, 0xa7, 0x2f, 0x77, 0x7b, 0xcd, 0x5c, 0x69, 0x0c, 0x18, 0x90, 0x08, 0x3c, 0xfe,
	0x06, 0xd4, 0x73, 0xcf, 0xa5, 0xa1, 0x46, 0x79, 0x5c, 0x76, 0xd7, 0x11, 0x4f, 0x19, 0xb0, 0x1f,
	0xd1, 0x64, 0x0e, 0x0a, 0x22, 0xd3, 0xe0, 0x4d, 0xd9, 0xd4, 0x7d, 0x76, 0xbd, 0x06, 0x93, 0x01,
	0x33, 0x1a, 0x38, 0x11, 0x7f, 0x05, 0xca, 0x33, 0xcf, 0xa7, 0xda, 0x98, 0x2b, 0xb8, 0xbb, 0x4e,
	0xc1, 0x63, 0xcf, 0xcf, 0xf0, 0x39, 0x4d, 0x3f, 0x85, 0x6a, 0xd6, 0x33, 0x96, 0xeb, 0xf1, 0xe4,
	0x6c, 0x3a, 0x0c, 0x1c, 0xcf, 0x4f, 0xde, 0x69, 0xb9, 0xc1, 0x8a, 0x3f, 0x70, 0xa6, 0xe2, 0xa1,
	0xca, 0x84, 0xaf, 0x59, 0xf2, 0xbc, 0xf0, 0xdc, 0x78, 0xc2, 0x93, 0x47, 0x25, 0x42, 0x60, 0x7a,
	0xb3, 0xfe, 0xfe, 0x6f, 0x7a, 0xef, 0x43, 0x25, 0x73, 0x8d, 0x05, 0x51, 0xce, 0x10, 0x31, 0x28,
	0xde, 0x28, 0x0c, 0x52, 0x65, 0x6c, 0x5d, 0x37, 0x59, 0x0a, 0xb2, 0x90, 0x95, 0x41, 0x35, 0x8e,
	0xfb, 0xf6, 0x53, 0x24, 0xb1, 0xb1, 0x73, 0xd2, 0xef, 0x5a, 0xcd, 0xb6, 0xd9, 0x3b, 0x44, 0x32,
	0x1f, 0x25, 0xc4, 0x48, 0x66, 0xcd, 0x16, 0x54, 0xda, 0xd6, 0x93, 0x5e, 0x7a, 0xca, 0xb3, 0xb9,
	0x6d, 0xf5, 0x0c, 0xa4, 0x1c, 0x94, 0xa1, 0x38, 0x13, 0xd6, 0xf5, 0x5f, 0xe4, 0x45, 0x6f, 0x64,
	0x3f, 0x46, 0xcb, 0x3e, 0x28, 0xaf, 0xeb, 0x83, 0x0c, 0xba, 0xda, 0x07, 0x3f, 0x82, 0x02, 0xff,
	0xa9, 0x4c, 0x1b, 0xf8, 0xe6, 0x2a, 0x91, 0x24, 0xa7, 0xf5, 0xfd, 0xb4, 0x90, 0x32, 0xb7, 0x60,
	0x53, 0xb1, 0x39, 0x38, 0x12, 0xd3, 0x72, 0x31, 0xf3, 0x72, 0x6c, 0x14, 0x0d, 0x0c, 0x1b, 0xe5,
	0x99, 0xbf, 0x49, 0xa2, 0x1f, 0x6c, 0xff, 0xf1, 0xba, 0x26, 0xbf, 0x7a, 0x5d, 0x93, 0xff, 0x7a,
	0x5d, 0x93, 0x7f, 0x7a, 0x53, 0x93, 0x5e, 0xbd, 0xa9, 0x49, 0x7f, 0xbe, 0xa9, 0x49, 0xdf, 0xe5,
	0x66, 0xc3, 0x61, 0x81, 0xff, 0x9d, 0xee, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x26, 0x74, 0x06,
	0x4a, 0xe1, 0x0a, 0x00, 0x00,
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Children[iNdEx])
			copy(dAtA[i:], m.Children[iNdEx])
			i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Children[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_Dashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Dashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Block_Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Block_Dataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Dataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Block_Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Block_Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Block_Layout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Layout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Block_Div) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Div) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Block_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_Header_Permissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_Header_Permissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_Header_Permissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Block_ContentDashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBlockContent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Style != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Block_ContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MarkerType != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.MarkerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MarksList != nil {
		{
			size, err := m.MarksList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentText_Marks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentText_Marks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentText_Marks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBlockContent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentText_Mark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentText_Mark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentText_Mark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size := m.Preview.Size()
			i -= size
			if _, err := m.Preview.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.State != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentMedia_Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Block_ContentMedia_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Block_ContentMedia_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlockContent(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Block_ContentMedia_VideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentMedia_VideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_VideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentMedia_ImagePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentMedia_ImagePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_ImagePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentMedia_FilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentMedia_FilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentMedia_FilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlockContent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block_ContentPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block_ContentPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block_ContentPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBlockContent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Style != 0 {
		i = encodeVarintBlockContent(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBlockContent(dAtA []byte, offset int, v uint64) int {
	offset -= sovBlockContent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 1 + l + sovBlockContent(uint64(l))
		}
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *Block_Dashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Dataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Layout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Div) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovBlockContent(uint64(m.Type))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}

func (m *Block_Header_Permissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *Block_ContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlockContent(uint64(m.Style))
	}
	return n
}

func (m *Block_ContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Block_ContentDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlockContent(uint64(m.Style))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovBlockContent(uint64(l))
		}
	}
	return n
}

func (m *Block_ContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Block_ContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovBlockContent(uint64(m.Style))
	}
	if m.MarksList != nil {
		l = m.MarksList.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.MarkerType != 0 {
		n += 1 + sovBlockContent(uint64(m.MarkerType))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *Block_ContentText_Marks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovBlockContent(uint64(l))
		}
	}
	return n
}

func (m *Block_ContentText_Mark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovBlockContent(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}

func (m *Block_ContentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBlockContent(uint64(m.State))
	}
	if m.Preview != nil {
		n += m.Preview.Size()
	}
	return n
}

func (m *Block_ContentMedia_Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_ContentMedia_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_ContentMedia_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovBlockContent(uint64(l))
	}
	return n
}
func (m *Block_ContentMedia_VideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBlockContent(uint64(m.Width))
	}
	return n
}

func (m *Block_ContentMedia_ImagePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBlockContent(uint64(m.Width))
	}
	return n
}

func (m *Block_ContentMedia_FilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBlockContent(uint64(l))
	}
	return n
}

func (m *Block_ContentPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlockContent(uint64(m.Style))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovBlockContent(uint64(l))
		}
	}
	return n
}

func sovBlockContent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBlockContent(x uint64) (n int) {
	return sovBlockContent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Block_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentDashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Dashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentPage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Page{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Dataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Text{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentMedia{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Media{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Layout{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Block_Div{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Block_Header_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &Block_Header_Permissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_Header_Permissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentLayout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentLayout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Block_ContentLayout_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDiv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDiv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentDashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Block_ContentDashboard_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Block_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Block_ContentText_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarksList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarksList == nil {
				m.MarksList = &Block_ContentText_Marks{}
			}
			if err := m.MarksList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerType", wireType)
			}
			m.MarkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkerType |= Block_ContentText_MarkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentText_Marks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &Block_ContentText_Mark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentText_Mark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Block_ContentText_Mark_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Block_ContentMedia_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentMedia_VideoPreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Block_ContentMedia_Video{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentMedia_ImagePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Block_ContentMedia_Image{v}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Block_ContentMedia_FilePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Block_ContentMedia_File{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentMedia_VideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentMedia_ImagePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentMedia_FilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block_ContentPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Block_ContentPage_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlockContent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlockContent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlockContent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlockContent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBlockContent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBlockContent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlockContent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBlockContent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBlockContent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBlockContent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBlockContent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBlockContent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBlockContent = fmt.Errorf("proto: unexpected end of group")
)
