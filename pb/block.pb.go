// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: block.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_struct "github.com/gogo/protobuf/types/struct"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BlockContentLayoutStyle int32

const (
	BlockContentLayout_ROW    BlockContentLayoutStyle = 0
	BlockContentLayout_COLUMN BlockContentLayoutStyle = 1
)

var BlockContentLayoutStyle_name = map[int32]string{
	0: "ROW",
	1: "COLUMN",
}

var BlockContentLayoutStyle_value = map[string]int32{
	"ROW":    0,
	"COLUMN": 1,
}

func (x BlockContentLayoutStyle) String() string {
	return proto.EnumName(BlockContentLayoutStyle_name, int32(x))
}

func (BlockContentLayoutStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 0, 0}
}

type BlockContentDashboardStyle int32

const (
	BlockContentDashboard_MAIN_SCREEN BlockContentDashboardStyle = 0
)

var BlockContentDashboardStyle_name = map[int32]string{
	0: "MAIN_SCREEN",
}

var BlockContentDashboardStyle_value = map[string]int32{
	"MAIN_SCREEN": 0,
}

func (x BlockContentDashboardStyle) String() string {
	return proto.EnumName(BlockContentDashboardStyle_name, int32(x))
}

func (BlockContentDashboardStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 2, 0}
}

type BlockContentTextStyle int32

const (
	BlockContentText_p     BlockContentTextStyle = 0
	BlockContentText_h1    BlockContentTextStyle = 1
	BlockContentText_h2    BlockContentTextStyle = 2
	BlockContentText_h3    BlockContentTextStyle = 3
	BlockContentText_h4    BlockContentTextStyle = 4
	BlockContentText_quote BlockContentTextStyle = 5
	BlockContentText_code  BlockContentTextStyle = 6
)

var BlockContentTextStyle_name = map[int32]string{
	0: "p",
	1: "h1",
	2: "h2",
	3: "h3",
	4: "h4",
	5: "quote",
	6: "code",
}

var BlockContentTextStyle_value = map[string]int32{
	"p":     0,
	"h1":    1,
	"h2":    2,
	"h3":    3,
	"h4":    4,
	"quote": 5,
	"code":  6,
}

func (x BlockContentTextStyle) String() string {
	return proto.EnumName(BlockContentTextStyle_name, int32(x))
}

func (BlockContentTextStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4, 0}
}

type BlockContentTextMarkerType int32

const (
	BlockContentText_none   BlockContentTextMarkerType = 0
	BlockContentText_number BlockContentTextMarkerType = 1
	BlockContentText_bullet BlockContentTextMarkerType = 2
)

var BlockContentTextMarkerType_name = map[int32]string{
	0: "none",
	1: "number",
	2: "bullet",
}

var BlockContentTextMarkerType_value = map[string]int32{
	"none":   0,
	"number": 1,
	"bullet": 2,
}

func (x BlockContentTextMarkerType) String() string {
	return proto.EnumName(BlockContentTextMarkerType_name, int32(x))
}

func (BlockContentTextMarkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4, 1}
}

type BlockContentTextMarkType int32

const (
	BlockContentTextMark_STRIKETHROUGH BlockContentTextMarkType = 0
	BlockContentTextMark_KEYBOARD      BlockContentTextMarkType = 1
	BlockContentTextMark_ITALIC        BlockContentTextMarkType = 2
	BlockContentTextMark_BOLD          BlockContentTextMarkType = 3
	BlockContentTextMark_LINK          BlockContentTextMarkType = 4
)

var BlockContentTextMarkType_name = map[int32]string{
	0: "STRIKETHROUGH",
	1: "KEYBOARD",
	2: "ITALIC",
	3: "BOLD",
	4: "LINK",
}

var BlockContentTextMarkType_value = map[string]int32{
	"STRIKETHROUGH": 0,
	"KEYBOARD":      1,
	"ITALIC":        2,
	"BOLD":          3,
	"LINK":          4,
}

func (x BlockContentTextMarkType) String() string {
	return proto.EnumName(BlockContentTextMarkType_name, int32(x))
}

func (BlockContentTextMarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4, 1, 0}
}

type BlockContentVideoState int32

const (
	BlockContentVideo_EMPTY       BlockContentVideoState = 0
	BlockContentVideo_UPLOADING   BlockContentVideoState = 1
	BlockContentVideo_PREVIEW     BlockContentVideoState = 2
	BlockContentVideo_DOWNLOADING BlockContentVideoState = 3
	BlockContentVideo_DONE        BlockContentVideoState = 4
)

var BlockContentVideoState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var BlockContentVideoState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x BlockContentVideoState) String() string {
	return proto.EnumName(BlockContentVideoState_name, int32(x))
}

func (BlockContentVideoState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 5, 0}
}

type BlockContentImageState int32

const (
	BlockContentImage_EMPTY       BlockContentImageState = 0
	BlockContentImage_UPLOADING   BlockContentImageState = 1
	BlockContentImage_PREVIEW     BlockContentImageState = 2
	BlockContentImage_DOWNLOADING BlockContentImageState = 3
	BlockContentImage_DONE        BlockContentImageState = 4
)

var BlockContentImageState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var BlockContentImageState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x BlockContentImageState) String() string {
	return proto.EnumName(BlockContentImageState_name, int32(x))
}

func (BlockContentImageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 6, 0}
}

type BlockContentFileState int32

const (
	BlockContentFile_EMPTY       BlockContentFileState = 0
	BlockContentFile_UPLOADING   BlockContentFileState = 1
	BlockContentFile_PREVIEW     BlockContentFileState = 2
	BlockContentFile_DOWNLOADING BlockContentFileState = 3
	BlockContentFile_DONE        BlockContentFileState = 4
)

var BlockContentFileState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var BlockContentFileState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x BlockContentFileState) String() string {
	return proto.EnumName(BlockContentFileState_name, int32(x))
}

func (BlockContentFileState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 7, 0}
}

type BlockContentPageStyle int32

const (
	BlockContentPage_EMPTY    BlockContentPageStyle = 0
	BlockContentPage_TASK     BlockContentPageStyle = 1
	BlockContentPage_BOOKMARK BlockContentPageStyle = 2
	BlockContentPage_SET      BlockContentPageStyle = 3
)

var BlockContentPageStyle_name = map[int32]string{
	0: "EMPTY",
	1: "TASK",
	2: "BOOKMARK",
	3: "SET",
}

var BlockContentPageStyle_value = map[string]int32{
	"EMPTY":    0,
	"TASK":     1,
	"BOOKMARK": 2,
	"SET":      3,
}

func (x BlockContentPageStyle) String() string {
	return proto.EnumName(BlockContentPageStyle_name, int32(x))
}

func (BlockContentPageStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 8, 0}
}

type Block struct {
	Id          string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields      *_struct.Struct   `protobuf:"bytes,2,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *BlockPermissions `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
	ChildrenIds []string          `protobuf:"bytes,4,rep,name=childrenIds,proto3" json:"childrenIds,omitempty"`
	BlockById   map[string]*Block `protobuf:"bytes,5,rep,name=blockById,proto3" json:"blockById,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Types that are valid to be assigned to Content:
	//	*BlockContentOfDashboard
	//	*BlockContentOfPage
	//	*BlockContentOfDataview
	//	*BlockContentOfText
	//	*BlockContentOfVideo
	//	*BlockContentOfImage
	//	*BlockContentOfFile
	//	*BlockContentOfLayout
	//	*BlockContentOfDiv
	Content IsBlockContent `protobuf_oneof:"content"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

type IsBlockContent interface {
	IsBlockContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BlockContentOfDashboard struct {
	Dashboard *BlockContentDashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type BlockContentOfPage struct {
	Page *BlockContentPage `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type BlockContentOfDataview struct {
	Dataview *BlockContentDataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type BlockContentOfText struct {
	Text *BlockContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type BlockContentOfVideo struct {
	Video *BlockContentVideo `protobuf:"bytes,15,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type BlockContentOfImage struct {
	Image *BlockContentImage `protobuf:"bytes,16,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type BlockContentOfFile struct {
	File *BlockContentFile `protobuf:"bytes,17,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type BlockContentOfLayout struct {
	Layout *BlockContentLayout `protobuf:"bytes,18,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type BlockContentOfDiv struct {
	Div *BlockContentDiv `protobuf:"bytes,19,opt,name=div,proto3,oneof" json:"div,omitempty"`
}

func (*BlockContentOfDashboard) IsBlockContent() {}
func (*BlockContentOfPage) IsBlockContent()      {}
func (*BlockContentOfDataview) IsBlockContent()  {}
func (*BlockContentOfText) IsBlockContent()      {}
func (*BlockContentOfVideo) IsBlockContent()     {}
func (*BlockContentOfImage) IsBlockContent()     {}
func (*BlockContentOfFile) IsBlockContent()      {}
func (*BlockContentOfLayout) IsBlockContent()    {}
func (*BlockContentOfDiv) IsBlockContent()       {}

func (m *Block) GetContent() IsBlockContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Block) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block) GetFields() *_struct.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Block) GetPermissions() *BlockPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Block) GetChildrenIds() []string {
	if m != nil {
		return m.ChildrenIds
	}
	return nil
}

func (m *Block) GetBlockById() map[string]*Block {
	if m != nil {
		return m.BlockById
	}
	return nil
}

func (m *Block) GetDashboard() *BlockContentDashboard {
	if x, ok := m.GetContent().(*BlockContentOfDashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *Block) GetPage() *BlockContentPage {
	if x, ok := m.GetContent().(*BlockContentOfPage); ok {
		return x.Page
	}
	return nil
}

func (m *Block) GetDataview() *BlockContentDataview {
	if x, ok := m.GetContent().(*BlockContentOfDataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *Block) GetText() *BlockContentText {
	if x, ok := m.GetContent().(*BlockContentOfText); ok {
		return x.Text
	}
	return nil
}

func (m *Block) GetVideo() *BlockContentVideo {
	if x, ok := m.GetContent().(*BlockContentOfVideo); ok {
		return x.Video
	}
	return nil
}

func (m *Block) GetImage() *BlockContentImage {
	if x, ok := m.GetContent().(*BlockContentOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *Block) GetFile() *BlockContentFile {
	if x, ok := m.GetContent().(*BlockContentOfFile); ok {
		return x.File
	}
	return nil
}

func (m *Block) GetLayout() *BlockContentLayout {
	if x, ok := m.GetContent().(*BlockContentOfLayout); ok {
		return x.Layout
	}
	return nil
}

func (m *Block) GetDiv() *BlockContentDiv {
	if x, ok := m.GetContent().(*BlockContentOfDiv); ok {
		return x.Div
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Block) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BlockContentOfDashboard)(nil),
		(*BlockContentOfPage)(nil),
		(*BlockContentOfDataview)(nil),
		(*BlockContentOfText)(nil),
		(*BlockContentOfVideo)(nil),
		(*BlockContentOfImage)(nil),
		(*BlockContentOfFile)(nil),
		(*BlockContentOfLayout)(nil),
		(*BlockContentOfDiv)(nil),
	}
}

type BlockPermissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *BlockPermissions) Reset()         { *m = BlockPermissions{} }
func (m *BlockPermissions) String() string { return proto.CompactTextString(m) }
func (*BlockPermissions) ProtoMessage()    {}
func (*BlockPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 1}
}
func (m *BlockPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockPermissions.Merge(m, src)
}
func (m *BlockPermissions) XXX_Size() int {
	return m.Size()
}
func (m *BlockPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_BlockPermissions proto.InternalMessageInfo

func (m *BlockPermissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *BlockPermissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *BlockPermissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *BlockPermissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *BlockPermissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type BlockContent struct {
}

func (m *BlockContent) Reset()         { *m = BlockContent{} }
func (m *BlockContent) String() string { return proto.CompactTextString(m) }
func (*BlockContent) ProtoMessage()    {}
func (*BlockContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2}
}
func (m *BlockContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContent.Merge(m, src)
}
func (m *BlockContent) XXX_Size() int {
	return m.Size()
}
func (m *BlockContent) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContent.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContent proto.InternalMessageInfo

type BlockContentLayout struct {
	Style BlockContentLayoutStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.BlockContentLayoutStyle" json:"style,omitempty"`
}

func (m *BlockContentLayout) Reset()         { *m = BlockContentLayout{} }
func (m *BlockContentLayout) String() string { return proto.CompactTextString(m) }
func (*BlockContentLayout) ProtoMessage()    {}
func (*BlockContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 0}
}
func (m *BlockContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentLayout.Merge(m, src)
}
func (m *BlockContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentLayout proto.InternalMessageInfo

func (m *BlockContentLayout) GetStyle() BlockContentLayoutStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentLayout_ROW
}

type BlockContentDiv struct {
}

func (m *BlockContentDiv) Reset()         { *m = BlockContentDiv{} }
func (m *BlockContentDiv) String() string { return proto.CompactTextString(m) }
func (*BlockContentDiv) ProtoMessage()    {}
func (*BlockContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 1}
}
func (m *BlockContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDiv.Merge(m, src)
}
func (m *BlockContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDiv proto.InternalMessageInfo

type BlockContentDashboard struct {
	Style BlockContentDashboardStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.BlockContentDashboardStyle" json:"style,omitempty"`
}

func (m *BlockContentDashboard) Reset()         { *m = BlockContentDashboard{} }
func (m *BlockContentDashboard) String() string { return proto.CompactTextString(m) }
func (*BlockContentDashboard) ProtoMessage()    {}
func (*BlockContentDashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 2}
}
func (m *BlockContentDashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDashboard.Merge(m, src)
}
func (m *BlockContentDashboard) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDashboard.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDashboard proto.InternalMessageInfo

func (m *BlockContentDashboard) GetStyle() BlockContentDashboardStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentDashboard_MAIN_SCREEN
}

type BlockContentDataview struct {
}

func (m *BlockContentDataview) Reset()         { *m = BlockContentDataview{} }
func (m *BlockContentDataview) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataview) ProtoMessage()    {}
func (*BlockContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 3}
}
func (m *BlockContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataview.Merge(m, src)
}
func (m *BlockContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataview proto.InternalMessageInfo

type BlockContentText struct {
	Text       string                     `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      BlockContentTextStyle      `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.BlockContentTextStyle" json:"style,omitempty"`
	MarksList  *BlockContentTextMarks     `protobuf:"bytes,3,opt,name=marksList,proto3" json:"marksList,omitempty"`
	Toggleable bool                       `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	MarkerType BlockContentTextMarkerType `protobuf:"varint,5,opt,name=markerType,proto3,enum=anytype.BlockContentTextMarkerType" json:"markerType,omitempty"`
	Checkable  bool                       `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                       `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *BlockContentText) Reset()         { *m = BlockContentText{} }
func (m *BlockContentText) String() string { return proto.CompactTextString(m) }
func (*BlockContentText) ProtoMessage()    {}
func (*BlockContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4}
}
func (m *BlockContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentText.Merge(m, src)
}
func (m *BlockContentText) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentText.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentText proto.InternalMessageInfo

func (m *BlockContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *BlockContentText) GetStyle() BlockContentTextStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentText_p
}

func (m *BlockContentText) GetMarksList() *BlockContentTextMarks {
	if m != nil {
		return m.MarksList
	}
	return nil
}

func (m *BlockContentText) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *BlockContentText) GetMarkerType() BlockContentTextMarkerType {
	if m != nil {
		return m.MarkerType
	}
	return BlockContentText_none
}

func (m *BlockContentText) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *BlockContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type BlockContentTextMarks struct {
	Marks []*BlockContentTextMark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *BlockContentTextMarks) Reset()         { *m = BlockContentTextMarks{} }
func (m *BlockContentTextMarks) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMarks) ProtoMessage()    {}
func (*BlockContentTextMarks) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4, 0}
}
func (m *BlockContentTextMarks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMarks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMarks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMarks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMarks.Merge(m, src)
}
func (m *BlockContentTextMarks) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMarks) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMarks.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMarks proto.InternalMessageInfo

func (m *BlockContentTextMarks) GetMarks() []*BlockContentTextMark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type BlockContentTextMark struct {
	Range *Range                   `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  BlockContentTextMarkType `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.BlockContentTextMarkType" json:"type,omitempty"`
	Param string                   `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *BlockContentTextMark) Reset()         { *m = BlockContentTextMark{} }
func (m *BlockContentTextMark) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMark) ProtoMessage()    {}
func (*BlockContentTextMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 4, 1}
}
func (m *BlockContentTextMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMark.Merge(m, src)
}
func (m *BlockContentTextMark) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMark) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMark.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMark proto.InternalMessageInfo

func (m *BlockContentTextMark) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *BlockContentTextMark) GetType() BlockContentTextMarkType {
	if m != nil {
		return m.Type
	}
	return BlockContentTextMark_STRIKETHROUGH
}

func (m *BlockContentTextMark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type BlockContentVideo struct {
	LocalFilePath string                    `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         BlockContentVideoState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.BlockContentVideoState" json:"state,omitempty"`
	Preview       *BlockContentVideoPreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *BlockContentVideo) Reset()         { *m = BlockContentVideo{} }
func (m *BlockContentVideo) String() string { return proto.CompactTextString(m) }
func (*BlockContentVideo) ProtoMessage()    {}
func (*BlockContentVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 5}
}
func (m *BlockContentVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentVideo.Merge(m, src)
}
func (m *BlockContentVideo) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentVideo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentVideo proto.InternalMessageInfo

func (m *BlockContentVideo) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentVideo) GetState() BlockContentVideoState {
	if m != nil {
		return m.State
	}
	return BlockContentVideo_EMPTY
}

func (m *BlockContentVideo) GetPreview() *BlockContentVideoPreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type BlockContentVideoPreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *BlockContentVideoPreview) Reset()         { *m = BlockContentVideoPreview{} }
func (m *BlockContentVideoPreview) String() string { return proto.CompactTextString(m) }
func (*BlockContentVideoPreview) ProtoMessage()    {}
func (*BlockContentVideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 5, 0}
}
func (m *BlockContentVideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentVideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentVideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentVideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentVideoPreview.Merge(m, src)
}
func (m *BlockContentVideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentVideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentVideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentVideoPreview proto.InternalMessageInfo

func (m *BlockContentVideoPreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *BlockContentVideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentVideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type BlockContentImage struct {
	LocalFilePath string                    `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         BlockContentImageState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.BlockContentImageState" json:"state,omitempty"`
	Preview       *BlockContentImagePreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *BlockContentImage) Reset()         { *m = BlockContentImage{} }
func (m *BlockContentImage) String() string { return proto.CompactTextString(m) }
func (*BlockContentImage) ProtoMessage()    {}
func (*BlockContentImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 6}
}
func (m *BlockContentImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentImage.Merge(m, src)
}
func (m *BlockContentImage) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentImage) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentImage.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentImage proto.InternalMessageInfo

func (m *BlockContentImage) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentImage) GetState() BlockContentImageState {
	if m != nil {
		return m.State
	}
	return BlockContentImage_EMPTY
}

func (m *BlockContentImage) GetPreview() *BlockContentImagePreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type BlockContentImagePreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *BlockContentImagePreview) Reset()         { *m = BlockContentImagePreview{} }
func (m *BlockContentImagePreview) String() string { return proto.CompactTextString(m) }
func (*BlockContentImagePreview) ProtoMessage()    {}
func (*BlockContentImagePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 6, 0}
}
func (m *BlockContentImagePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentImagePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentImagePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentImagePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentImagePreview.Merge(m, src)
}
func (m *BlockContentImagePreview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentImagePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentImagePreview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentImagePreview proto.InternalMessageInfo

func (m *BlockContentImagePreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *BlockContentImagePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentImagePreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type BlockContentFile struct {
	LocalFilePath string                   `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         BlockContentFileState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.BlockContentFileState" json:"state,omitempty"`
	Preview       *BlockContentFilePreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *BlockContentFile) Reset()         { *m = BlockContentFile{} }
func (m *BlockContentFile) String() string { return proto.CompactTextString(m) }
func (*BlockContentFile) ProtoMessage()    {}
func (*BlockContentFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 7}
}
func (m *BlockContentFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFile.Merge(m, src)
}
func (m *BlockContentFile) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFile) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFile.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFile proto.InternalMessageInfo

func (m *BlockContentFile) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentFile) GetState() BlockContentFileState {
	if m != nil {
		return m.State
	}
	return BlockContentFile_EMPTY
}

func (m *BlockContentFile) GetPreview() *BlockContentFilePreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type BlockContentFilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *BlockContentFilePreview) Reset()         { *m = BlockContentFilePreview{} }
func (m *BlockContentFilePreview) String() string { return proto.CompactTextString(m) }
func (*BlockContentFilePreview) ProtoMessage()    {}
func (*BlockContentFilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 7, 0}
}
func (m *BlockContentFilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFilePreview.Merge(m, src)
}
func (m *BlockContentFilePreview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFilePreview proto.InternalMessageInfo

func (m *BlockContentFilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentFilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type BlockContentPage struct {
	Style BlockContentPageStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.BlockContentPageStyle" json:"style,omitempty"`
}

func (m *BlockContentPage) Reset()         { *m = BlockContentPage{} }
func (m *BlockContentPage) String() string { return proto.CompactTextString(m) }
func (*BlockContentPage) ProtoMessage()    {}
func (*BlockContentPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{0, 2, 8}
}
func (m *BlockContentPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentPage.Merge(m, src)
}
func (m *BlockContentPage) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentPage) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentPage.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentPage proto.InternalMessageInfo

func (m *BlockContentPage) GetStyle() BlockContentPageStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentPage_EMPTY
}

type Range struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e550b1f5926e92d, []int{1}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Range) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

func init() {
	proto.RegisterEnum("anytype.BlockContentLayoutStyle", BlockContentLayoutStyle_name, BlockContentLayoutStyle_value)
	proto.RegisterEnum("anytype.BlockContentDashboardStyle", BlockContentDashboardStyle_name, BlockContentDashboardStyle_value)
	proto.RegisterEnum("anytype.BlockContentTextStyle", BlockContentTextStyle_name, BlockContentTextStyle_value)
	proto.RegisterEnum("anytype.BlockContentTextMarkerType", BlockContentTextMarkerType_name, BlockContentTextMarkerType_value)
	proto.RegisterEnum("anytype.BlockContentTextMarkType", BlockContentTextMarkType_name, BlockContentTextMarkType_value)
	proto.RegisterEnum("anytype.BlockContentVideoState", BlockContentVideoState_name, BlockContentVideoState_value)
	proto.RegisterEnum("anytype.BlockContentImageState", BlockContentImageState_name, BlockContentImageState_value)
	proto.RegisterEnum("anytype.BlockContentFileState", BlockContentFileState_name, BlockContentFileState_value)
	proto.RegisterEnum("anytype.BlockContentPageStyle", BlockContentPageStyle_name, BlockContentPageStyle_value)
	proto.RegisterType((*Block)(nil), "anytype.Block")
	proto.RegisterMapType((map[string]*Block)(nil), "anytype.Block.BlockByIdEntry")
	proto.RegisterType((*BlockPermissions)(nil), "anytype.Block.Permissions")
	proto.RegisterType((*BlockContent)(nil), "anytype.Block.Content")
	proto.RegisterType((*BlockContentLayout)(nil), "anytype.Block.Content.Layout")
	proto.RegisterType((*BlockContentDiv)(nil), "anytype.Block.Content.Div")
	proto.RegisterType((*BlockContentDashboard)(nil), "anytype.Block.Content.Dashboard")
	proto.RegisterType((*BlockContentDataview)(nil), "anytype.Block.Content.Dataview")
	proto.RegisterType((*BlockContentText)(nil), "anytype.Block.Content.Text")
	proto.RegisterType((*BlockContentTextMarks)(nil), "anytype.Block.Content.Text.Marks")
	proto.RegisterType((*BlockContentTextMark)(nil), "anytype.Block.Content.Text.Mark")
	proto.RegisterType((*BlockContentVideo)(nil), "anytype.Block.Content.Video")
	proto.RegisterType((*BlockContentVideoPreview)(nil), "anytype.Block.Content.Video.Preview")
	proto.RegisterType((*BlockContentImage)(nil), "anytype.Block.Content.Image")
	proto.RegisterType((*BlockContentImagePreview)(nil), "anytype.Block.Content.Image.Preview")
	proto.RegisterType((*BlockContentFile)(nil), "anytype.Block.Content.File")
	proto.RegisterType((*BlockContentFilePreview)(nil), "anytype.Block.Content.File.Preview")
	proto.RegisterType((*BlockContentPage)(nil), "anytype.Block.Content.Page")
	proto.RegisterType((*Range)(nil), "anytype.Range")
}

func init() { proto.RegisterFile("block.proto", fileDescriptor_8e550b1f5926e92d) }

var fileDescriptor_8e550b1f5926e92d = []byte{
	// 1237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xd1, 0x8e, 0xd3, 0x46,
	0x17, 0xb6, 0x1d, 0x3b, 0x89, 0x4f, 0xd8, 0xc5, 0xcc, 0xff, 0x8b, 0x5a, 0xee, 0xb2, 0x0d, 0x81,
	0x56, 0x2b, 0x55, 0x32, 0x62, 0x41, 0x05, 0x5a, 0x28, 0xdd, 0x6c, 0x02, 0x89, 0x36, 0x9b, 0xa4,
	0x93, 0x00, 0xa2, 0x37, 0x95, 0x13, 0xcf, 0x26, 0xd6, 0x3a, 0x76, 0xea, 0x4c, 0x02, 0x79, 0x8b,
	0x3e, 0x43, 0x5f, 0xa1, 0xcf, 0x40, 0xd5, 0x4b, 0x2e, 0x7b, 0x59, 0xc1, 0x0b, 0xf4, 0x11, 0xaa,
	0x39, 0x13, 0x6f, 0x12, 0xda, 0x0d, 0x55, 0xc5, 0x4d, 0xaf, 0x3c, 0x73, 0xe6, 0xfb, 0xe6, 0x9c,
	0xf9, 0xce, 0x39, 0x33, 0x86, 0x42, 0x2f, 0x8c, 0xfb, 0xa7, 0xee, 0x38, 0x89, 0x79, 0x4c, 0x72,
	0x5e, 0x34, 0xe7, 0xf3, 0x31, 0x73, 0x76, 0x06, 0x71, 0x3c, 0x08, 0xd9, 0x0d, 0x34, 0xf7, 0xa6,
	0x27, 0x37, 0x26, 0x3c, 0x99, 0xf6, 0xb9, 0x84, 0x95, 0xfe, 0xb8, 0x0c, 0x46, 0x59, 0xd0, 0xc8,
	0x36, 0x68, 0x81, 0x6f, 0xab, 0x45, 0x75, 0xcf, 0xa4, 0x5a, 0xe0, 0x93, 0x1b, 0x90, 0x3d, 0x09,
	0x58, 0xe8, 0x4f, 0x6c, 0xad, 0xa8, 0xee, 0x15, 0xf6, 0x3f, 0x72, 0xe5, 0x46, 0x6e, 0xba, 0x91,
	0xdb, 0xc1, 0x8d, 0xe8, 0x02, 0x46, 0xee, 0x43, 0x61, 0xcc, 0x92, 0x51, 0x30, 0x99, 0x04, 0x71,
	0x34, 0xb1, 0x33, 0xc8, 0x72, 0xdc, 0x45, 0x1c, 0x2e, 0x7a, 0x71, 0xdb, 0x4b, 0x04, 0x5d, 0x85,
	0x93, 0x22, 0x14, 0xfa, 0xc3, 0x20, 0xf4, 0x13, 0x16, 0xd5, 0xfd, 0x89, 0xad, 0x17, 0x33, 0x7b,
	0x26, 0x5d, 0x35, 0x91, 0xaf, 0xc0, 0xc4, 0x03, 0x96, 0xe7, 0x75, 0xdf, 0x36, 0x8a, 0x99, 0xbd,
	0xc2, 0xfe, 0x95, 0x77, 0x76, 0x2f, 0xa7, 0xeb, 0xd5, 0x88, 0x27, 0x73, 0xba, 0xc4, 0x93, 0x6f,
	0xc0, 0xf4, 0xbd, 0xc9, 0xb0, 0x17, 0x7b, 0x89, 0x6f, 0x17, 0x30, 0xb4, 0xe2, 0x3b, 0xe4, 0xc3,
	0x38, 0xe2, 0x2c, 0xe2, 0x6e, 0x25, 0xc5, 0xd5, 0x14, 0xba, 0x24, 0x91, 0x9b, 0xa0, 0x8f, 0xbd,
	0x01, 0xb3, 0x2f, 0x20, 0xf9, 0xe3, 0x73, 0xc8, 0x6d, 0x6f, 0xc0, 0x6a, 0x0a, 0x45, 0x28, 0x79,
	0x00, 0x79, 0xdf, 0xe3, 0xde, 0x2c, 0x60, 0x2f, 0xec, 0x2d, 0xa4, 0x7d, 0x72, 0xae, 0x4f, 0x09,
	0xab, 0x29, 0xf4, 0x8c, 0x22, 0x3c, 0x72, 0xf6, 0x92, 0xdb, 0xdb, 0x1b, 0x3d, 0x76, 0xd9, 0x4b,
	0x2e, 0x3c, 0x0a, 0x28, 0xb9, 0x0d, 0xc6, 0x2c, 0xf0, 0x59, 0x6c, 0x5f, 0x44, 0xce, 0xce, 0x39,
	0x9c, 0xa7, 0x02, 0x53, 0x53, 0xa8, 0x04, 0x0b, 0x56, 0x30, 0x12, 0x67, 0xb3, 0x36, 0xb2, 0xea,
	0x23, 0x79, 0x38, 0x09, 0x16, 0xe1, 0x9d, 0x04, 0x21, 0xb3, 0x2f, 0x6d, 0x0c, 0xef, 0x51, 0x10,
	0xa2, 0x20, 0x02, 0x4a, 0xee, 0x40, 0x36, 0xf4, 0xe6, 0xf1, 0x94, 0xdb, 0x04, 0x49, 0x57, 0xce,
	0x21, 0x35, 0x10, 0x54, 0x53, 0xe8, 0x02, 0x4e, 0x5c, 0xc8, 0xf8, 0xc1, 0xcc, 0xfe, 0xdf, 0xdf,
	0xd6, 0xd4, 0x99, 0x88, 0xc1, 0xac, 0xa6, 0x50, 0x01, 0x74, 0x1a, 0xb0, 0xbd, 0x5e, 0x0b, 0xc4,
	0x82, 0xcc, 0x29, 0x9b, 0x2f, 0xea, 0x5b, 0x0c, 0xc9, 0x75, 0x30, 0x66, 0x5e, 0x38, 0x65, 0x8b,
	0xfa, 0xde, 0x5e, 0xdf, 0x95, 0xca, 0xc5, 0x2f, 0xb5, 0xbb, 0xaa, 0x33, 0x87, 0xc2, 0x4a, 0xdd,
	0x12, 0x02, 0x7a, 0xc2, 0x3c, 0xd9, 0x2b, 0x79, 0x8a, 0x63, 0x61, 0x63, 0x7e, 0xc0, 0x71, 0xaf,
	0x3c, 0xc5, 0x31, 0xb9, 0x0c, 0xd9, 0x84, 0x8d, 0xe2, 0x19, 0xc3, 0x5e, 0xc8, 0xd3, 0xc5, 0x4c,
	0x60, 0xfd, 0xc4, 0x1b, 0xd8, 0xba, 0xc4, 0x8a, 0xb1, 0xc0, 0xfa, 0x49, 0x3c, 0x6e, 0x45, 0xb6,
	0x21, 0xb1, 0x72, 0xe6, 0xbc, 0xba, 0x08, 0xb9, 0xc5, 0xf9, 0x1c, 0x0f, 0xb2, 0x52, 0x18, 0x72,
	0x0f, 0x8c, 0x09, 0x9f, 0x87, 0x0c, 0x43, 0xd8, 0xde, 0xbf, 0xb6, 0x51, 0x46, 0xb7, 0x23, 0xa0,
	0x54, 0x32, 0x4a, 0x3b, 0x60, 0xe0, 0x9c, 0xe4, 0x20, 0x43, 0x5b, 0xcf, 0x2c, 0x85, 0x00, 0x64,
	0x0f, 0x5b, 0x8d, 0x27, 0xc7, 0x4d, 0x4b, 0x75, 0x0c, 0xc8, 0x54, 0x82, 0x99, 0xd3, 0x07, 0xf3,
	0xac, 0x0b, 0xc8, 0xfd, 0x75, 0x67, 0x9f, 0xbd, 0xaf, 0x6d, 0xd6, 0xfd, 0xd9, 0xa9, 0xbf, 0x8b,
	0x50, 0x38, 0x3e, 0xa8, 0x37, 0xbf, 0xef, 0x1c, 0xd2, 0x6a, 0xb5, 0x69, 0x29, 0x0e, 0x40, 0x3e,
	0x2d, 0x7b, 0xe7, 0x67, 0x03, 0x74, 0x51, 0xc8, 0x42, 0x1b, 0xac, 0x79, 0x99, 0x27, 0x59, 0xd4,
	0x77, 0xd2, 0x00, 0x34, 0x0c, 0xe0, 0xea, 0x86, 0x46, 0x58, 0xf3, 0x4d, 0x1e, 0x82, 0x39, 0xf2,
	0x92, 0xd3, 0x49, 0x23, 0x98, 0xf0, 0xc5, 0x7d, 0xb4, 0x91, 0x7c, 0x2c, 0xc0, 0x74, 0xc9, 0x21,
	0xbb, 0x00, 0x3c, 0x1e, 0x0c, 0x42, 0xe6, 0xf5, 0x42, 0xb6, 0xc8, 0xd7, 0x8a, 0x85, 0x3c, 0x02,
	0x10, 0x60, 0x96, 0x74, 0xe7, 0x63, 0x86, 0x99, 0x3b, 0x5f, 0x9f, 0x33, 0x0f, 0x12, 0x4d, 0x57,
	0x98, 0x64, 0x07, 0xcc, 0xfe, 0x90, 0xf5, 0x4f, 0xd1, 0x4d, 0x16, 0xdd, 0x2c, 0x0d, 0xc4, 0x86,
	0x1c, 0x4e, 0x98, 0x6f, 0xe7, 0x70, 0x2d, 0x9d, 0x3a, 0x0f, 0xc1, 0xc0, 0x98, 0xc9, 0x17, 0x60,
	0x60, 0xd4, 0xb6, 0x8a, 0xf7, 0x62, 0xf1, 0x7d, 0x31, 0x50, 0x09, 0x77, 0x7e, 0x51, 0x41, 0x17,
	0x73, 0xd1, 0x0c, 0x89, 0x17, 0x0d, 0x64, 0x92, 0x57, 0x9b, 0x81, 0x0a, 0x2b, 0x95, 0x8b, 0xe4,
	0x1e, 0xe8, 0xc2, 0xb8, 0x48, 0xc4, 0xa7, 0xef, 0xf3, 0xe2, 0xe2, 0x41, 0x91, 0x42, 0xfe, 0x0f,
	0xc6, 0xd8, 0x4b, 0xbc, 0x11, 0xe6, 0xc1, 0xa4, 0x72, 0x52, 0x7a, 0x0c, 0x3a, 0x0a, 0x70, 0x09,
	0xb6, 0x3a, 0x5d, 0x5a, 0x3f, 0xaa, 0x76, 0x6b, 0xb4, 0xf5, 0xe4, 0x71, 0xcd, 0x52, 0xc8, 0x05,
	0xc8, 0x1f, 0x55, 0x9f, 0x97, 0x5b, 0x07, 0xb4, 0x62, 0xa9, 0xa2, 0x48, 0xeb, 0xdd, 0x83, 0x46,
	0xfd, 0xd0, 0xd2, 0x48, 0x1e, 0xf4, 0x72, 0xab, 0x51, 0xb1, 0x32, 0x62, 0xd4, 0xa8, 0x37, 0x8f,
	0x2c, 0xbd, 0x74, 0x98, 0x96, 0x99, 0x01, 0xea, 0xd8, 0x52, 0x48, 0x16, 0xb4, 0xe1, 0x4d, 0x4b,
	0xc5, 0xef, 0xbe, 0xa5, 0xe1, 0xf7, 0x96, 0x95, 0xc1, 0xef, 0x6d, 0x4b, 0x27, 0x26, 0x18, 0x3f,
	0x4c, 0x63, 0xce, 0x2c, 0x43, 0x6c, 0xd2, 0x8f, 0x7d, 0x66, 0x65, 0x4b, 0x2e, 0xc0, 0x32, 0x41,
	0xc2, 0x1e, 0xc5, 0x11, 0x93, 0x1d, 0x12, 0x4d, 0x47, 0x3d, 0x96, 0xc8, 0x40, 0x7a, 0xd3, 0x30,
	0x64, 0xdc, 0xd2, 0x9c, 0x57, 0x1a, 0x18, 0x78, 0x95, 0x92, 0xeb, 0xb0, 0x15, 0xc6, 0x7d, 0x2f,
	0x14, 0xb7, 0x5d, 0xdb, 0xe3, 0xc3, 0x45, 0xfd, 0xae, 0x1b, 0xc9, 0x5d, 0x51, 0xc8, 0x1e, 0x4f,
	0xf5, 0x2b, 0x6d, 0xba, 0x9d, 0xdd, 0x8e, 0x40, 0x52, 0x49, 0x20, 0x5f, 0x43, 0x6e, 0x9c, 0x30,
	0x7c, 0x48, 0x64, 0x1d, 0x5f, 0xdf, 0xc8, 0x6d, 0x4b, 0x2c, 0x4d, 0x49, 0xce, 0xb7, 0x90, 0x5b,
	0xd8, 0x44, 0xad, 0xf1, 0xe1, 0x74, 0xd4, 0x8b, 0xbc, 0x20, 0xc4, 0x30, 0x2f, 0xd0, 0xa5, 0x41,
	0xf4, 0x5f, 0xe4, 0x8d, 0x64, 0x84, 0x26, 0xc5, 0xb1, 0x48, 0xdd, 0x8b, 0xc0, 0xe7, 0x43, 0x74,
	0x6d, 0x50, 0x39, 0x29, 0xd5, 0x85, 0xe2, 0x22, 0x36, 0x13, 0x8c, 0xea, 0x71, 0xbb, 0xfb, 0xdc,
	0x52, 0xc8, 0x16, 0x98, 0x4f, 0xda, 0x8d, 0xd6, 0x41, 0xa5, 0xde, 0x7c, 0x6c, 0xa9, 0xa4, 0x00,
	0xb9, 0x36, 0xad, 0x3e, 0xad, 0x57, 0x9f, 0x59, 0x9a, 0xe8, 0xff, 0x4a, 0xeb, 0x59, 0x33, 0x5d,
	0xc5, 0xe4, 0x55, 0x5a, 0xcd, 0xaa, 0xa5, 0xa3, 0x8e, 0xf8, 0xb8, 0x7c, 0x58, 0x1d, 0x71, 0xcb,
	0x7f, 0xa9, 0xa3, 0xe4, 0xfe, 0xc7, 0x74, 0xfc, 0x49, 0x03, 0x5d, 0x88, 0xf4, 0x0f, 0x65, 0xbc,
	0xb3, 0x2e, 0xe3, 0xd5, 0x0d, 0x2f, 0xf8, 0xba, 0x8a, 0x0f, 0xde, 0x55, 0xf1, 0xda, 0x26, 0xea,
	0x5f, 0x44, 0xbc, 0xb9, 0x14, 0x31, 0x95, 0x49, 0x5d, 0x91, 0x89, 0x80, 0x1e, 0xf4, 0xe3, 0x28,
	0x95, 0x4e, 0x8c, 0x3f, 0xa4, 0x48, 0x1c, 0x74, 0xf1, 0x93, 0xb6, 0x7c, 0x55, 0xd4, 0x8d, 0xa7,
	0x6f, 0xcb, 0x1a, 0x5a, 0x79, 0xd1, 0x6e, 0xa5, 0x57, 0xcd, 0x4a, 0x2c, 0x79, 0xd0, 0xbb, 0x07,
	0x9d, 0x23, 0x4b, 0x15, 0xd7, 0x56, 0xb9, 0xd5, 0x3a, 0x3a, 0x3e, 0xa0, 0x47, 0x96, 0x26, 0x1e,
	0xd9, 0x4e, 0xb5, 0x6b, 0x65, 0xca, 0x26, 0xe4, 0xfa, 0x72, 0xc7, 0xd2, 0xe7, 0x60, 0xe0, 0xa5,
	0x2a, 0x0e, 0x7a, 0x92, 0xc4, 0x23, 0x0c, 0xc0, 0xa0, 0x38, 0x16, 0x7f, 0xe1, 0x3c, 0xc6, 0xa3,
	0x1b, 0x54, 0xe3, 0x71, 0x79, 0xe7, 0xd7, 0x37, 0xbb, 0xea, 0xeb, 0x37, 0xbb, 0xea, 0xef, 0x6f,
	0x76, 0xd5, 0x1f, 0xdf, 0xee, 0x2a, 0xaf, 0xdf, 0xee, 0x2a, 0xbf, 0xbd, 0xdd, 0x55, 0xbe, 0xd3,
	0xc6, 0xbd, 0x5e, 0x16, 0xff, 0xc5, 0x6f, 0xfd, 0x19, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x6d, 0xbc,
	0xd8, 0xfa, 0x0b, 0x00, 0x00,
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.BlockById) > 0 {
		for k := range m.BlockById {
			v := m.BlockById[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBlock(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBlock(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBlock(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ChildrenIds) > 0 {
		for iNdEx := len(m.ChildrenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChildrenIds[iNdEx])
			copy(dAtA[i:], m.ChildrenIds[iNdEx])
			i = encodeVarintBlock(dAtA, i, uint64(len(m.ChildrenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentOfDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *BlockContentOfDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentOfDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *BlockPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentDashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MarkerType != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.MarkerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MarksList != nil {
		{
			size, err := m.MarksList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMarks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMarks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMarks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBlock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentVideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentVideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentVideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentImagePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentImagePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentImagePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBlock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBlock(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintBlock(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBlock(dAtA []byte, offset int, v uint64) int {
	offset -= sovBlock(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	if len(m.ChildrenIds) > 0 {
		for _, s := range m.ChildrenIds {
			l = len(s)
			n += 1 + l + sovBlock(uint64(l))
		}
	}
	if len(m.BlockById) > 0 {
		for k, v := range m.BlockById {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBlock(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBlock(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBlock(uint64(mapEntrySize))
		}
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *BlockContentOfDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockContentOfDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovBlock(uint64(l))
	}
	return n
}
func (m *BlockPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *BlockContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlock(uint64(m.Style))
	}
	return n
}

func (m *BlockContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlock(uint64(m.Style))
	}
	return n
}

func (m *BlockContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovBlock(uint64(m.Style))
	}
	if m.MarksList != nil {
		l = m.MarksList.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.MarkerType != 0 {
		n += 1 + sovBlock(uint64(m.MarkerType))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *BlockContentTextMarks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovBlock(uint64(l))
		}
	}
	return n
}

func (m *BlockContentTextMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovBlock(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}

func (m *BlockContentVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBlock(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}

func (m *BlockContentVideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBlock(uint64(m.Width))
	}
	return n
}

func (m *BlockContentImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBlock(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}

func (m *BlockContentImagePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovBlock(uint64(m.Width))
	}
	return n
}

func (m *BlockContentFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBlock(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}

func (m *BlockContentFilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovBlock(uint64(l))
	}
	return n
}

func (m *BlockContentPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovBlock(uint64(m.Style))
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovBlock(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovBlock(uint64(m.To))
	}
	return n
}

func sovBlock(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBlock(x uint64) (n int) {
	return sovBlock(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &_struct.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &BlockPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildrenIds = append(m.ChildrenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockById", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockById == nil {
				m.BlockById = make(map[string]*Block)
			}
			var mapkey string
			var mapvalue *Block
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBlock
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBlock
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBlock
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBlock
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBlock
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBlock
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBlock
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Block{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBlock(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBlock
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlockById[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfDashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentPage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfPage{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfDataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfText{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfVideo{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfImage{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfFile{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfLayout{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockContentOfDiv{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentLayoutStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Div: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Div: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentDashboardStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentTextStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarksList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarksList == nil {
				m.MarksList = &BlockContentTextMarks{}
			}
			if err := m.MarksList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerType", wireType)
			}
			m.MarkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkerType |= BlockContentTextMarkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMarks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &BlockContentTextMark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentTextMarkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentVideoState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &BlockContentVideoPreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentVideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentImageState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &BlockContentImagePreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentImagePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentFileState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &BlockContentFilePreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBlock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBlock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentPageStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBlock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBlock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBlock(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBlock
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBlock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBlock
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBlock
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBlock
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBlock        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBlock          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBlock = fmt.Errorf("proto: unexpected end of group")
)
