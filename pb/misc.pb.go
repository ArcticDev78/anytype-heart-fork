// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: misc.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetVersionResponse_Error_Code int32

const (
	GetVersionResponse_Error_NULL             GetVersionResponse_Error_Code = 0
	GetVersionResponse_Error_UNKNOWN_ERROR    GetVersionResponse_Error_Code = 1
	GetVersionResponse_Error_BAD_INPUT        GetVersionResponse_Error_Code = 2
	GetVersionResponse_Error_VERSION_IS_EMPTY GetVersionResponse_Error_Code = 3
	GetVersionResponse_Error_NOT_FOUND        GetVersionResponse_Error_Code = 101
	GetVersionResponse_Error_TIMEOUT          GetVersionResponse_Error_Code = 102
)

var GetVersionResponse_Error_Code_name = map[int32]string{
	0:   "NULL",
	1:   "UNKNOWN_ERROR",
	2:   "BAD_INPUT",
	3:   "VERSION_IS_EMPTY",
	101: "NOT_FOUND",
	102: "TIMEOUT",
}

var GetVersionResponse_Error_Code_value = map[string]int32{
	"NULL":             0,
	"UNKNOWN_ERROR":    1,
	"BAD_INPUT":        2,
	"VERSION_IS_EMPTY": 3,
	"NOT_FOUND":        101,
	"TIMEOUT":          102,
}

func (x GetVersionResponse_Error_Code) String() string {
	return proto.EnumName(GetVersionResponse_Error_Code_name, int32(x))
}

func (GetVersionResponse_Error_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{1, 0, 0}
}

type LogRequest_Level int32

const (
	LogRequest_DEBUG   LogRequest_Level = 0
	LogRequest_ERROR   LogRequest_Level = 1
	LogRequest_FATAL   LogRequest_Level = 2
	LogRequest_INFO    LogRequest_Level = 3
	LogRequest_PANIC   LogRequest_Level = 4
	LogRequest_WARNING LogRequest_Level = 5
)

var LogRequest_Level_name = map[int32]string{
	0: "DEBUG",
	1: "ERROR",
	2: "FATAL",
	3: "INFO",
	4: "PANIC",
	5: "WARNING",
}

var LogRequest_Level_value = map[string]int32{
	"DEBUG":   0,
	"ERROR":   1,
	"FATAL":   2,
	"INFO":    3,
	"PANIC":   4,
	"WARNING": 5,
}

func (x LogRequest_Level) String() string {
	return proto.EnumName(LogRequest_Level_name, int32(x))
}

func (LogRequest_Level) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{2, 0}
}

type LogResponse_Error_Code int32

const (
	LogResponse_Error_NULL          LogResponse_Error_Code = 0
	LogResponse_Error_UNKNOWN_ERROR LogResponse_Error_Code = 1
	LogResponse_Error_BAD_INPUT     LogResponse_Error_Code = 2
	LogResponse_Error_NOT_FOUND     LogResponse_Error_Code = 101
	LogResponse_Error_TIMEOUT       LogResponse_Error_Code = 102
)

var LogResponse_Error_Code_name = map[int32]string{
	0:   "NULL",
	1:   "UNKNOWN_ERROR",
	2:   "BAD_INPUT",
	101: "NOT_FOUND",
	102: "TIMEOUT",
}

var LogResponse_Error_Code_value = map[string]int32{
	"NULL":          0,
	"UNKNOWN_ERROR": 1,
	"BAD_INPUT":     2,
	"NOT_FOUND":     101,
	"TIMEOUT":       102,
}

func (x LogResponse_Error_Code) String() string {
	return proto.EnumName(LogResponse_Error_Code_name, int32(x))
}

func (LogResponse_Error_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{3, 0, 0}
}

type GetVersionRequest struct {
}

func (m *GetVersionRequest) Reset()         { *m = GetVersionRequest{} }
func (m *GetVersionRequest) String() string { return proto.CompactTextString(m) }
func (*GetVersionRequest) ProtoMessage()    {}
func (*GetVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{0}
}
func (m *GetVersionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionRequest.Merge(m, src)
}
func (m *GetVersionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionRequest proto.InternalMessageInfo

type GetVersionResponse struct {
	Error   *GetVersionResponse_Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Version string                    `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *GetVersionResponse) Reset()         { *m = GetVersionResponse{} }
func (m *GetVersionResponse) String() string { return proto.CompactTextString(m) }
func (*GetVersionResponse) ProtoMessage()    {}
func (*GetVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{1}
}
func (m *GetVersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionResponse.Merge(m, src)
}
func (m *GetVersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionResponse proto.InternalMessageInfo

func (m *GetVersionResponse) GetError() *GetVersionResponse_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *GetVersionResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type GetVersionResponse_Error struct {
	Code        GetVersionResponse_Error_Code `protobuf:"varint,1,opt,name=code,proto3,enum=anytype.GetVersionResponse_Error_Code" json:"code,omitempty"`
	Description string                        `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *GetVersionResponse_Error) Reset()         { *m = GetVersionResponse_Error{} }
func (m *GetVersionResponse_Error) String() string { return proto.CompactTextString(m) }
func (*GetVersionResponse_Error) ProtoMessage()    {}
func (*GetVersionResponse_Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{1, 0}
}
func (m *GetVersionResponse_Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVersionResponse_Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVersionResponse_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVersionResponse_Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVersionResponse_Error.Merge(m, src)
}
func (m *GetVersionResponse_Error) XXX_Size() int {
	return m.Size()
}
func (m *GetVersionResponse_Error) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVersionResponse_Error.DiscardUnknown(m)
}

var xxx_messageInfo_GetVersionResponse_Error proto.InternalMessageInfo

func (m *GetVersionResponse_Error) GetCode() GetVersionResponse_Error_Code {
	if m != nil {
		return m.Code
	}
	return GetVersionResponse_Error_NULL
}

func (m *GetVersionResponse_Error) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type LogRequest struct {
	Message string           `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Level   LogRequest_Level `protobuf:"varint,2,opt,name=level,proto3,enum=anytype.LogRequest_Level" json:"level,omitempty"`
}

func (m *LogRequest) Reset()         { *m = LogRequest{} }
func (m *LogRequest) String() string { return proto.CompactTextString(m) }
func (*LogRequest) ProtoMessage()    {}
func (*LogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{2}
}
func (m *LogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogRequest.Merge(m, src)
}
func (m *LogRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogRequest proto.InternalMessageInfo

func (m *LogRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *LogRequest) GetLevel() LogRequest_Level {
	if m != nil {
		return m.Level
	}
	return LogRequest_DEBUG
}

type LogResponse struct {
	Error *LogResponse_Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *LogResponse) Reset()         { *m = LogResponse{} }
func (m *LogResponse) String() string { return proto.CompactTextString(m) }
func (*LogResponse) ProtoMessage()    {}
func (*LogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{3}
}
func (m *LogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogResponse.Merge(m, src)
}
func (m *LogResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogResponse proto.InternalMessageInfo

func (m *LogResponse) GetError() *LogResponse_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type LogResponse_Error struct {
	Code        LogResponse_Error_Code `protobuf:"varint,1,opt,name=code,proto3,enum=anytype.LogResponse_Error_Code" json:"code,omitempty"`
	Description string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *LogResponse_Error) Reset()         { *m = LogResponse_Error{} }
func (m *LogResponse_Error) String() string { return proto.CompactTextString(m) }
func (*LogResponse_Error) ProtoMessage()    {}
func (*LogResponse_Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d3ba2f07ad357c5, []int{3, 0}
}
func (m *LogResponse_Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogResponse_Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogResponse_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogResponse_Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogResponse_Error.Merge(m, src)
}
func (m *LogResponse_Error) XXX_Size() int {
	return m.Size()
}
func (m *LogResponse_Error) XXX_DiscardUnknown() {
	xxx_messageInfo_LogResponse_Error.DiscardUnknown(m)
}

var xxx_messageInfo_LogResponse_Error proto.InternalMessageInfo

func (m *LogResponse_Error) GetCode() LogResponse_Error_Code {
	if m != nil {
		return m.Code
	}
	return LogResponse_Error_NULL
}

func (m *LogResponse_Error) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func init() {
	proto.RegisterEnum("anytype.GetVersionResponse_Error_Code", GetVersionResponse_Error_Code_name, GetVersionResponse_Error_Code_value)
	proto.RegisterEnum("anytype.LogRequest_Level", LogRequest_Level_name, LogRequest_Level_value)
	proto.RegisterEnum("anytype.LogResponse_Error_Code", LogResponse_Error_Code_name, LogResponse_Error_Code_value)
	proto.RegisterType((*GetVersionRequest)(nil), "anytype.GetVersionRequest")
	proto.RegisterType((*GetVersionResponse)(nil), "anytype.GetVersionResponse")
	proto.RegisterType((*GetVersionResponse_Error)(nil), "anytype.GetVersionResponse.Error")
	proto.RegisterType((*LogRequest)(nil), "anytype.LogRequest")
	proto.RegisterType((*LogResponse)(nil), "anytype.LogResponse")
	proto.RegisterType((*LogResponse_Error)(nil), "anytype.LogResponse.Error")
}

func init() { proto.RegisterFile("misc.proto", fileDescriptor_2d3ba2f07ad357c5) }

var fileDescriptor_2d3ba2f07ad357c5 = []byte{
	// 448 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0x4d, 0x6e, 0xd3, 0x40,
	0x14, 0x80, 0x3d, 0x6e, 0x4c, 0xf0, 0xb3, 0x5a, 0x4d, 0x07, 0x16, 0x21, 0x42, 0x26, 0x78, 0x81,
	0xba, 0x32, 0x28, 0x5d, 0x20, 0xb1, 0x73, 0x1a, 0x27, 0x32, 0xb8, 0xe3, 0x68, 0x6a, 0xb7, 0x82,
	0x8d, 0xd5, 0xc6, 0x43, 0x15, 0xa9, 0xcd, 0x18, 0x8f, 0xa9, 0xd4, 0x5b, 0x70, 0x07, 0xf6, 0xec,
	0xb8, 0x03, 0x12, 0x9b, 0x2e, 0x59, 0xa2, 0xe4, 0x02, 0x1c, 0x01, 0x8d, 0x9d, 0xb4, 0x89, 0xf8,
	0x13, 0xdd, 0xf9, 0x3d, 0x7f, 0xef, 0xcf, 0x9f, 0x0c, 0x70, 0x3e, 0x91, 0x63, 0x37, 0x2f, 0x44,
	0x29, 0x48, 0xf3, 0x78, 0x7a, 0x59, 0x5e, 0xe6, 0xdc, 0xb9, 0x07, 0xdb, 0x43, 0x5e, 0x1e, 0xf2,
	0x42, 0x4e, 0xc4, 0x94, 0xf1, 0x77, 0xef, 0xb9, 0x2c, 0x9d, 0xcf, 0x3a, 0x90, 0xd5, 0xac, 0xcc,
	0xc5, 0x54, 0x72, 0xf2, 0x1c, 0x0c, 0x5e, 0x14, 0xa2, 0x68, 0xa1, 0x0e, 0xda, 0xb1, 0xba, 0x8f,
	0xdd, 0x45, 0x13, 0xf7, 0x57, 0xd6, 0xf5, 0x15, 0xc8, 0x6a, 0x9e, 0xb4, 0xa0, 0x79, 0x51, 0xbf,
	0x6f, 0xe9, 0x1d, 0xb4, 0x63, 0xb2, 0x65, 0xd8, 0xfe, 0x8a, 0xc0, 0xa8, 0x50, 0xf2, 0x02, 0x1a,
	0x63, 0x91, 0xf1, 0xaa, 0xf7, 0x56, 0xf7, 0xc9, 0x3f, 0x7b, 0xbb, 0x7b, 0x22, 0xe3, 0xac, 0xaa,
	0x21, 0x1d, 0xb0, 0x32, 0x2e, 0xc7, 0xc5, 0x24, 0x2f, 0x6f, 0x66, 0xac, 0xa6, 0x9c, 0x0c, 0x1a,
	0x8a, 0x27, 0x77, 0xa1, 0x41, 0x93, 0x30, 0xc4, 0x1a, 0xd9, 0x86, 0xcd, 0x84, 0xbe, 0xa2, 0xd1,
	0x11, 0x4d, 0x7d, 0xc6, 0x22, 0x86, 0x11, 0xd9, 0x04, 0xb3, 0xe7, 0xf5, 0xd3, 0x80, 0x8e, 0x92,
	0x18, 0xeb, 0xe4, 0x3e, 0xe0, 0x43, 0x9f, 0x1d, 0x04, 0x11, 0x4d, 0x83, 0x83, 0xd4, 0xdf, 0x1f,
	0xc5, 0xaf, 0xf1, 0x86, 0x82, 0x68, 0x14, 0xa7, 0x83, 0x28, 0xa1, 0x7d, 0xcc, 0x89, 0x05, 0xcd,
	0x38, 0xd8, 0xf7, 0xa3, 0x24, 0xc6, 0x6f, 0x9d, 0x8f, 0x08, 0x20, 0x14, 0xa7, 0x8b, 0xcf, 0xa8,
	0xce, 0x3e, 0xe7, 0x52, 0x1e, 0x9f, 0xd6, 0x57, 0x99, 0x6c, 0x19, 0x92, 0xa7, 0x60, 0x9c, 0xf1,
	0x0b, 0x7e, 0x56, 0xad, 0xba, 0xd5, 0x7d, 0x70, 0x7d, 0xed, 0x4d, 0xb5, 0x1b, 0x2a, 0x80, 0xd5,
	0x9c, 0xf3, 0x12, 0x8c, 0x2a, 0x26, 0x26, 0x18, 0x7d, 0xbf, 0x97, 0x0c, 0xb1, 0xa6, 0x1e, 0x97,
	0x9b, 0x9b, 0x60, 0x0c, 0xbc, 0xd8, 0x0b, 0xb1, 0xae, 0x2e, 0x0c, 0xe8, 0x20, 0xc2, 0x1b, 0x2a,
	0x39, 0xf2, 0x68, 0xb0, 0x87, 0x1b, 0x6a, 0xcb, 0x23, 0x8f, 0xd1, 0x80, 0x0e, 0xb1, 0xe1, 0xfc,
	0x40, 0x60, 0x55, 0x73, 0x16, 0x5a, 0x9f, 0xad, 0x6b, 0x6d, 0xaf, 0x2f, 0xf3, 0x1b, 0x9f, 0xed,
	0x4f, 0xd7, 0xd6, 0x76, 0xd7, 0xac, 0x3d, 0xfa, 0x73, 0xe9, 0xff, 0xe9, 0xa2, 0xb7, 0xd0, 0xf5,
	0x17, 0x31, 0xbd, 0x87, 0x5f, 0x66, 0x36, 0xba, 0x9a, 0xd9, 0xe8, 0xfb, 0xcc, 0x46, 0x1f, 0xe6,
	0xb6, 0x76, 0x35, 0xb7, 0xb5, 0x6f, 0x73, 0x5b, 0x7b, 0xa3, 0xe7, 0x27, 0x27, 0x77, 0xaa, 0x7f,
	0x62, 0xf7, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x41, 0xb2, 0x2c, 0x21, 0x03, 0x00, 0x00,
}

func (m *GetVersionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMisc(dAtA, i, uint64(m.Error.Size()))
		n1, err1 := m.Error.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMisc(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *GetVersionResponse_Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVersionResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMisc(dAtA, i, uint64(m.Code))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMisc(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *LogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMisc(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMisc(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *LogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMisc(dAtA, i, uint64(m.Error.Size()))
		n2, err2 := m.Error.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *LogResponse_Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMisc(dAtA, i, uint64(m.Code))
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMisc(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func encodeVarintMisc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetVersionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetVersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovMisc(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMisc(uint64(l))
	}
	return n
}

func (m *GetVersionResponse_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMisc(uint64(m.Code))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMisc(uint64(l))
	}
	return n
}

func (m *LogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMisc(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMisc(uint64(m.Level))
	}
	return n
}

func (m *LogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovMisc(uint64(l))
	}
	return n
}

func (m *LogResponse_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMisc(uint64(m.Code))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMisc(uint64(l))
	}
	return n
}

func sovMisc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMisc(x uint64) (n int) {
	return sovMisc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetVersionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVersionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVersionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &GetVersionResponse_Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVersionResponse_Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= GetVersionResponse_Error_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= LogRequest_Level(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &LogResponse_Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogResponse_Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= LogResponse_Error_Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMisc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMisc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMisc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMisc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMisc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMisc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMisc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMisc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMisc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMisc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMisc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMisc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMisc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMisc   = fmt.Errorf("proto: integer overflow")
)
