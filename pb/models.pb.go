// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ModelBlockPosition int32

const (
	ModelBlock_BEFORE ModelBlockPosition = 0
	ModelBlock_AFTER  ModelBlockPosition = 1
)

var ModelBlockPosition_name = map[int32]string{
	0: "BEFORE",
	1: "AFTER",
}

var ModelBlockPosition_value = map[string]int32{
	"BEFORE": 0,
	"AFTER":  1,
}

func (x ModelBlockPosition) String() string {
	return proto.EnumName(ModelBlockPosition_name, int32(x))
}

func (ModelBlockPosition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0}
}

type ModelBlockContentLayoutStyle int32

const (
	ModelBlockContentLayout_ROW    ModelBlockContentLayoutStyle = 0
	ModelBlockContentLayout_COLUMN ModelBlockContentLayoutStyle = 1
)

var ModelBlockContentLayoutStyle_name = map[int32]string{
	0: "ROW",
	1: "COLUMN",
}

var ModelBlockContentLayoutStyle_value = map[string]int32{
	"ROW":    0,
	"COLUMN": 1,
}

func (x ModelBlockContentLayoutStyle) String() string {
	return proto.EnumName(ModelBlockContentLayoutStyle_name, int32(x))
}

func (ModelBlockContentLayoutStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 0, 0}
}

type ModelBlockContentDashboardStyle int32

const (
	ModelBlockContentDashboard_MAIN_SCREEN ModelBlockContentDashboardStyle = 0
)

var ModelBlockContentDashboardStyle_name = map[int32]string{
	0: "MAIN_SCREEN",
}

var ModelBlockContentDashboardStyle_value = map[string]int32{
	"MAIN_SCREEN": 0,
}

func (x ModelBlockContentDashboardStyle) String() string {
	return proto.EnumName(ModelBlockContentDashboardStyle_name, int32(x))
}

func (ModelBlockContentDashboardStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 3, 0}
}

type ModelBlockContentTextStyle int32

const (
	ModelBlockContentText_p     ModelBlockContentTextStyle = 0
	ModelBlockContentText_h1    ModelBlockContentTextStyle = 1
	ModelBlockContentText_h2    ModelBlockContentTextStyle = 2
	ModelBlockContentText_h3    ModelBlockContentTextStyle = 3
	ModelBlockContentText_h4    ModelBlockContentTextStyle = 4
	ModelBlockContentText_quote ModelBlockContentTextStyle = 5
	ModelBlockContentText_code  ModelBlockContentTextStyle = 6
)

var ModelBlockContentTextStyle_name = map[int32]string{
	0: "p",
	1: "h1",
	2: "h2",
	3: "h3",
	4: "h4",
	5: "quote",
	6: "code",
}

var ModelBlockContentTextStyle_value = map[string]int32{
	"p":     0,
	"h1":    1,
	"h2":    2,
	"h3":    3,
	"h4":    4,
	"quote": 5,
	"code":  6,
}

func (x ModelBlockContentTextStyle) String() string {
	return proto.EnumName(ModelBlockContentTextStyle_name, int32(x))
}

func (ModelBlockContentTextStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 0}
}

type ModelBlockContentTextMarkerType int32

const (
	ModelBlockContentText_none   ModelBlockContentTextMarkerType = 0
	ModelBlockContentText_number ModelBlockContentTextMarkerType = 1
	ModelBlockContentText_bullet ModelBlockContentTextMarkerType = 2
)

var ModelBlockContentTextMarkerType_name = map[int32]string{
	0: "none",
	1: "number",
	2: "bullet",
}

var ModelBlockContentTextMarkerType_value = map[string]int32{
	"none":   0,
	"number": 1,
	"bullet": 2,
}

func (x ModelBlockContentTextMarkerType) String() string {
	return proto.EnumName(ModelBlockContentTextMarkerType_name, int32(x))
}

func (ModelBlockContentTextMarkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 1}
}

type ModelBlockContentTextMarkType int32

const (
	ModelBlockContentTextMark_STRIKETHROUGH ModelBlockContentTextMarkType = 0
	ModelBlockContentTextMark_KEYBOARD      ModelBlockContentTextMarkType = 1
	ModelBlockContentTextMark_ITALIC        ModelBlockContentTextMarkType = 2
	ModelBlockContentTextMark_BOLD          ModelBlockContentTextMarkType = 3
	ModelBlockContentTextMark_LINK          ModelBlockContentTextMarkType = 4
)

var ModelBlockContentTextMarkType_name = map[int32]string{
	0: "STRIKETHROUGH",
	1: "KEYBOARD",
	2: "ITALIC",
	3: "BOLD",
	4: "LINK",
}

var ModelBlockContentTextMarkType_value = map[string]int32{
	"STRIKETHROUGH": 0,
	"KEYBOARD":      1,
	"ITALIC":        2,
	"BOLD":          3,
	"LINK":          4,
}

func (x ModelBlockContentTextMarkType) String() string {
	return proto.EnumName(ModelBlockContentTextMarkType_name, int32(x))
}

func (ModelBlockContentTextMarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 0, 0}
}

type ModelBlockContentVideoState int32

const (
	ModelBlockContentVideo_EMPTY       ModelBlockContentVideoState = 0
	ModelBlockContentVideo_UPLOADING   ModelBlockContentVideoState = 1
	ModelBlockContentVideo_PREVIEW     ModelBlockContentVideoState = 2
	ModelBlockContentVideo_DOWNLOADING ModelBlockContentVideoState = 3
	ModelBlockContentVideo_DONE        ModelBlockContentVideoState = 4
)

var ModelBlockContentVideoState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var ModelBlockContentVideoState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x ModelBlockContentVideoState) String() string {
	return proto.EnumName(ModelBlockContentVideoState_name, int32(x))
}

func (ModelBlockContentVideoState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 6, 0}
}

type ModelBlockContentImageState int32

const (
	ModelBlockContentImage_EMPTY       ModelBlockContentImageState = 0
	ModelBlockContentImage_UPLOADING   ModelBlockContentImageState = 1
	ModelBlockContentImage_PREVIEW     ModelBlockContentImageState = 2
	ModelBlockContentImage_DOWNLOADING ModelBlockContentImageState = 3
	ModelBlockContentImage_DONE        ModelBlockContentImageState = 4
)

var ModelBlockContentImageState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var ModelBlockContentImageState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x ModelBlockContentImageState) String() string {
	return proto.EnumName(ModelBlockContentImageState_name, int32(x))
}

func (ModelBlockContentImageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 7, 0}
}

type ModelBlockContentFileState int32

const (
	ModelBlockContentFile_EMPTY       ModelBlockContentFileState = 0
	ModelBlockContentFile_UPLOADING   ModelBlockContentFileState = 1
	ModelBlockContentFile_PREVIEW     ModelBlockContentFileState = 2
	ModelBlockContentFile_DOWNLOADING ModelBlockContentFileState = 3
	ModelBlockContentFile_DONE        ModelBlockContentFileState = 4
)

var ModelBlockContentFileState_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var ModelBlockContentFileState_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x ModelBlockContentFileState) String() string {
	return proto.EnumName(ModelBlockContentFileState_name, int32(x))
}

func (ModelBlockContentFileState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 8, 0}
}

type ModelBlockContentPageStyle int32

const (
	ModelBlockContentPage_EMPTY    ModelBlockContentPageStyle = 0
	ModelBlockContentPage_TASK     ModelBlockContentPageStyle = 1
	ModelBlockContentPage_BOOKMARK ModelBlockContentPageStyle = 2
	ModelBlockContentPage_SET      ModelBlockContentPageStyle = 3
)

var ModelBlockContentPageStyle_name = map[int32]string{
	0: "EMPTY",
	1: "TASK",
	2: "BOOKMARK",
	3: "SET",
}

var ModelBlockContentPageStyle_value = map[string]int32{
	"EMPTY":    0,
	"TASK":     1,
	"BOOKMARK": 2,
	"SET":      3,
}

func (x ModelBlockContentPageStyle) String() string {
	return proto.EnumName(ModelBlockContentPageStyle_name, int32(x))
}

func (ModelBlockContentPageStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 9, 0}
}

type ModelImageSize int32

const (
	ModelImage_LARGE ModelImageSize = 0
	ModelImage_SMALL ModelImageSize = 1
	ModelImage_THUMB ModelImageSize = 2
)

var ModelImageSize_name = map[int32]string{
	0: "LARGE",
	1: "SMALL",
	2: "THUMB",
}

var ModelImageSize_value = map[string]int32{
	"LARGE": 0,
	"SMALL": 1,
	"THUMB": 2,
}

func (x ModelImageSize) String() string {
	return proto.EnumName(ModelImageSize_name, int32(x))
}

func (ModelImageSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 3, 0}
}

type ModelVideoSize int32

const (
	ModelVideo_SD_360p   ModelVideoSize = 0
	ModelVideo_SD_480p   ModelVideoSize = 1
	ModelVideo_HD_720p   ModelVideoSize = 2
	ModelVideo_HD_1080p  ModelVideoSize = 3
	ModelVideo_UHD_1440p ModelVideoSize = 4
	ModelVideo_UHD_2160p ModelVideoSize = 5
)

var ModelVideoSize_name = map[int32]string{
	0: "SD_360p",
	1: "SD_480p",
	2: "HD_720p",
	3: "HD_1080p",
	4: "UHD_1440p",
	5: "UHD_2160p",
}

var ModelVideoSize_value = map[string]int32{
	"SD_360p":   0,
	"SD_480p":   1,
	"HD_720p":   2,
	"HD_1080p":  3,
	"UHD_1440p": 4,
	"UHD_2160p": 5,
}

func (x ModelVideoSize) String() string {
	return proto.EnumName(ModelVideoSize_name, int32(x))
}

func (ModelVideoSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 4, 0}
}

type Model struct {
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type ModelBlock struct {
	Id          string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields      *types.Struct          `protobuf:"bytes,2,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *ModelBlockPermissions `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
	ChildrenIds []string               `protobuf:"bytes,4,rep,name=childrenIds,proto3" json:"childrenIds,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*ModelBlockContentOfDashboard
	//	*ModelBlockContentOfPage
	//	*ModelBlockContentOfDataview
	//	*ModelBlockContentOfText
	//	*ModelBlockContentOfVideo
	//	*ModelBlockContentOfImage
	//	*ModelBlockContentOfFile
	//	*ModelBlockContentOfLayout
	//	*ModelBlockContentOfDiv
	//	*ModelBlockContentOfBookmark
	Content isModelBlockContent `protobuf_oneof:"content"`
}

func (m *ModelBlock) Reset()         { *m = ModelBlock{} }
func (m *ModelBlock) String() string { return proto.CompactTextString(m) }
func (*ModelBlock) ProtoMessage()    {}
func (*ModelBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0}
}
func (m *ModelBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlock.Merge(m, src)
}
func (m *ModelBlock) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlock.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlock proto.InternalMessageInfo

type isModelBlockContent interface {
	isModelBlockContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModelBlockContentOfDashboard struct {
	Dashboard *ModelBlockContentDashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type ModelBlockContentOfPage struct {
	Page *ModelBlockContentPage `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type ModelBlockContentOfDataview struct {
	Dataview *ModelBlockContentDataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type ModelBlockContentOfText struct {
	Text *ModelBlockContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type ModelBlockContentOfVideo struct {
	Video *ModelBlockContentVideo `protobuf:"bytes,15,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type ModelBlockContentOfImage struct {
	Image *ModelBlockContentImage `protobuf:"bytes,16,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type ModelBlockContentOfFile struct {
	File *ModelBlockContentFile `protobuf:"bytes,17,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type ModelBlockContentOfLayout struct {
	Layout *ModelBlockContentLayout `protobuf:"bytes,18,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type ModelBlockContentOfDiv struct {
	Div *ModelBlockContentDiv `protobuf:"bytes,19,opt,name=div,proto3,oneof" json:"div,omitempty"`
}
type ModelBlockContentOfBookmark struct {
	Bookmark *ModelBlockContentBookmark `protobuf:"bytes,20,opt,name=bookmark,proto3,oneof" json:"bookmark,omitempty"`
}

func (*ModelBlockContentOfDashboard) isModelBlockContent() {}
func (*ModelBlockContentOfPage) isModelBlockContent()      {}
func (*ModelBlockContentOfDataview) isModelBlockContent()  {}
func (*ModelBlockContentOfText) isModelBlockContent()      {}
func (*ModelBlockContentOfVideo) isModelBlockContent()     {}
func (*ModelBlockContentOfImage) isModelBlockContent()     {}
func (*ModelBlockContentOfFile) isModelBlockContent()      {}
func (*ModelBlockContentOfLayout) isModelBlockContent()    {}
func (*ModelBlockContentOfDiv) isModelBlockContent()       {}
func (*ModelBlockContentOfBookmark) isModelBlockContent()  {}

func (m *ModelBlock) GetContent() isModelBlockContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *ModelBlock) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModelBlock) GetFields() *types.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *ModelBlock) GetPermissions() *ModelBlockPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *ModelBlock) GetChildrenIds() []string {
	if m != nil {
		return m.ChildrenIds
	}
	return nil
}

func (m *ModelBlock) GetDashboard() *ModelBlockContentDashboard {
	if x, ok := m.GetContent().(*ModelBlockContentOfDashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *ModelBlock) GetPage() *ModelBlockContentPage {
	if x, ok := m.GetContent().(*ModelBlockContentOfPage); ok {
		return x.Page
	}
	return nil
}

func (m *ModelBlock) GetDataview() *ModelBlockContentDataview {
	if x, ok := m.GetContent().(*ModelBlockContentOfDataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *ModelBlock) GetText() *ModelBlockContentText {
	if x, ok := m.GetContent().(*ModelBlockContentOfText); ok {
		return x.Text
	}
	return nil
}

func (m *ModelBlock) GetVideo() *ModelBlockContentVideo {
	if x, ok := m.GetContent().(*ModelBlockContentOfVideo); ok {
		return x.Video
	}
	return nil
}

func (m *ModelBlock) GetImage() *ModelBlockContentImage {
	if x, ok := m.GetContent().(*ModelBlockContentOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *ModelBlock) GetFile() *ModelBlockContentFile {
	if x, ok := m.GetContent().(*ModelBlockContentOfFile); ok {
		return x.File
	}
	return nil
}

func (m *ModelBlock) GetLayout() *ModelBlockContentLayout {
	if x, ok := m.GetContent().(*ModelBlockContentOfLayout); ok {
		return x.Layout
	}
	return nil
}

func (m *ModelBlock) GetDiv() *ModelBlockContentDiv {
	if x, ok := m.GetContent().(*ModelBlockContentOfDiv); ok {
		return x.Div
	}
	return nil
}

func (m *ModelBlock) GetBookmark() *ModelBlockContentBookmark {
	if x, ok := m.GetContent().(*ModelBlockContentOfBookmark); ok {
		return x.Bookmark
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModelBlock) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModelBlockContentOfDashboard)(nil),
		(*ModelBlockContentOfPage)(nil),
		(*ModelBlockContentOfDataview)(nil),
		(*ModelBlockContentOfText)(nil),
		(*ModelBlockContentOfVideo)(nil),
		(*ModelBlockContentOfImage)(nil),
		(*ModelBlockContentOfFile)(nil),
		(*ModelBlockContentOfLayout)(nil),
		(*ModelBlockContentOfDiv)(nil),
		(*ModelBlockContentOfBookmark)(nil),
	}
}

type ModelBlockPermissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *ModelBlockPermissions) Reset()         { *m = ModelBlockPermissions{} }
func (m *ModelBlockPermissions) String() string { return proto.CompactTextString(m) }
func (*ModelBlockPermissions) ProtoMessage()    {}
func (*ModelBlockPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0}
}
func (m *ModelBlockPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockPermissions.Merge(m, src)
}
func (m *ModelBlockPermissions) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockPermissions proto.InternalMessageInfo

func (m *ModelBlockPermissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *ModelBlockPermissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *ModelBlockPermissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *ModelBlockPermissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *ModelBlockPermissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type ModelBlockContent struct {
}

func (m *ModelBlockContent) Reset()         { *m = ModelBlockContent{} }
func (m *ModelBlockContent) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContent) ProtoMessage()    {}
func (*ModelBlockContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1}
}
func (m *ModelBlockContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContent.Merge(m, src)
}
func (m *ModelBlockContent) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContent) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContent.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContent proto.InternalMessageInfo

//
// Layout have no visual representation, but affects on blocks, that it contains.
// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
type ModelBlockContentLayout struct {
	Style ModelBlockContentLayoutStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.ModelBlockContentLayoutStyle" json:"style,omitempty"`
}

func (m *ModelBlockContentLayout) Reset()         { *m = ModelBlockContentLayout{} }
func (m *ModelBlockContentLayout) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentLayout) ProtoMessage()    {}
func (*ModelBlockContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 0}
}
func (m *ModelBlockContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentLayout.Merge(m, src)
}
func (m *ModelBlockContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentLayout proto.InternalMessageInfo

func (m *ModelBlockContentLayout) GetStyle() ModelBlockContentLayoutStyle {
	if m != nil {
		return m.Style
	}
	return ModelBlockContentLayout_ROW
}

//
// Divider: block, that contains only one horizontal thin line
type ModelBlockContentDiv struct {
}

func (m *ModelBlockContentDiv) Reset()         { *m = ModelBlockContentDiv{} }
func (m *ModelBlockContentDiv) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentDiv) ProtoMessage()    {}
func (*ModelBlockContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 1}
}
func (m *ModelBlockContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentDiv.Merge(m, src)
}
func (m *ModelBlockContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentDiv proto.InternalMessageInfo

//
// Bookmark is to keep a web-link and to preview a content.
type ModelBlockContentBookmark struct {
}

func (m *ModelBlockContentBookmark) Reset()         { *m = ModelBlockContentBookmark{} }
func (m *ModelBlockContentBookmark) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentBookmark) ProtoMessage()    {}
func (*ModelBlockContentBookmark) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 2}
}
func (m *ModelBlockContentBookmark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentBookmark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentBookmark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentBookmark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentBookmark.Merge(m, src)
}
func (m *ModelBlockContentBookmark) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentBookmark) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentBookmark.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentBookmark proto.InternalMessageInfo

//
// Block type to organize pages on the main screen (main purpose)
// It also can be mounted on a page.
type ModelBlockContentDashboard struct {
	Style ModelBlockContentDashboardStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.ModelBlockContentDashboardStyle" json:"style,omitempty"`
}

func (m *ModelBlockContentDashboard) Reset()         { *m = ModelBlockContentDashboard{} }
func (m *ModelBlockContentDashboard) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentDashboard) ProtoMessage()    {}
func (*ModelBlockContentDashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 3}
}
func (m *ModelBlockContentDashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentDashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentDashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentDashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentDashboard.Merge(m, src)
}
func (m *ModelBlockContentDashboard) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentDashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentDashboard.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentDashboard proto.InternalMessageInfo

func (m *ModelBlockContentDashboard) GetStyle() ModelBlockContentDashboardStyle {
	if m != nil {
		return m.Style
	}
	return ModelBlockContentDashboard_MAIN_SCREEN
}

type ModelBlockContentDataview struct {
}

func (m *ModelBlockContentDataview) Reset()         { *m = ModelBlockContentDataview{} }
func (m *ModelBlockContentDataview) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentDataview) ProtoMessage()    {}
func (*ModelBlockContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4}
}
func (m *ModelBlockContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentDataview.Merge(m, src)
}
func (m *ModelBlockContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentDataview proto.InternalMessageInfo

type ModelBlockContentText struct {
	Text       string                          `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      ModelBlockContentTextStyle      `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.ModelBlockContentTextStyle" json:"style,omitempty"`
	MarksList  *ModelBlockContentTextMarks     `protobuf:"bytes,3,opt,name=marksList,proto3" json:"marksList,omitempty"`
	Toggleable bool                            `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	MarkerType ModelBlockContentTextMarkerType `protobuf:"varint,5,opt,name=markerType,proto3,enum=anytype.ModelBlockContentTextMarkerType" json:"markerType,omitempty"`
	Checkable  bool                            `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                            `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *ModelBlockContentText) Reset()         { *m = ModelBlockContentText{} }
func (m *ModelBlockContentText) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentText) ProtoMessage()    {}
func (*ModelBlockContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5}
}
func (m *ModelBlockContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentText.Merge(m, src)
}
func (m *ModelBlockContentText) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentText.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentText proto.InternalMessageInfo

func (m *ModelBlockContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ModelBlockContentText) GetStyle() ModelBlockContentTextStyle {
	if m != nil {
		return m.Style
	}
	return ModelBlockContentText_p
}

func (m *ModelBlockContentText) GetMarksList() *ModelBlockContentTextMarks {
	if m != nil {
		return m.MarksList
	}
	return nil
}

func (m *ModelBlockContentText) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *ModelBlockContentText) GetMarkerType() ModelBlockContentTextMarkerType {
	if m != nil {
		return m.MarkerType
	}
	return ModelBlockContentText_none
}

func (m *ModelBlockContentText) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *ModelBlockContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type ModelBlockContentTextMark struct {
	Range *ModelRange                   `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  ModelBlockContentTextMarkType `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.ModelBlockContentTextMarkType" json:"type,omitempty"`
	Param string                        `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *ModelBlockContentTextMark) Reset()         { *m = ModelBlockContentTextMark{} }
func (m *ModelBlockContentTextMark) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentTextMark) ProtoMessage()    {}
func (*ModelBlockContentTextMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 0}
}
func (m *ModelBlockContentTextMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentTextMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentTextMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentTextMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentTextMark.Merge(m, src)
}
func (m *ModelBlockContentTextMark) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentTextMark) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentTextMark.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentTextMark proto.InternalMessageInfo

func (m *ModelBlockContentTextMark) GetRange() *ModelRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *ModelBlockContentTextMark) GetType() ModelBlockContentTextMarkType {
	if m != nil {
		return m.Type
	}
	return ModelBlockContentTextMark_STRIKETHROUGH
}

func (m *ModelBlockContentTextMark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type ModelBlockContentTextMarks struct {
	Marks []*ModelBlockContentTextMark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *ModelBlockContentTextMarks) Reset()         { *m = ModelBlockContentTextMarks{} }
func (m *ModelBlockContentTextMarks) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentTextMarks) ProtoMessage()    {}
func (*ModelBlockContentTextMarks) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 1}
}
func (m *ModelBlockContentTextMarks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentTextMarks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentTextMarks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentTextMarks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentTextMarks.Merge(m, src)
}
func (m *ModelBlockContentTextMarks) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentTextMarks) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentTextMarks.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentTextMarks proto.InternalMessageInfo

func (m *ModelBlockContentTextMarks) GetMarks() []*ModelBlockContentTextMark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type ModelBlockContentVideo struct {
	LocalFilePath string                         `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         ModelBlockContentVideoState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.ModelBlockContentVideoState" json:"state,omitempty"`
	Preview       *ModelBlockContentVideoPreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *ModelBlockContentVideo) Reset()         { *m = ModelBlockContentVideo{} }
func (m *ModelBlockContentVideo) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentVideo) ProtoMessage()    {}
func (*ModelBlockContentVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 6}
}
func (m *ModelBlockContentVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentVideo.Merge(m, src)
}
func (m *ModelBlockContentVideo) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentVideo.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentVideo proto.InternalMessageInfo

func (m *ModelBlockContentVideo) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *ModelBlockContentVideo) GetState() ModelBlockContentVideoState {
	if m != nil {
		return m.State
	}
	return ModelBlockContentVideo_EMPTY
}

func (m *ModelBlockContentVideo) GetPreview() *ModelBlockContentVideoPreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type ModelBlockContentVideoPreview struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon  string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
	Width int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *ModelBlockContentVideoPreview) Reset()         { *m = ModelBlockContentVideoPreview{} }
func (m *ModelBlockContentVideoPreview) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentVideoPreview) ProtoMessage()    {}
func (*ModelBlockContentVideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 6, 0}
}
func (m *ModelBlockContentVideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentVideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentVideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentVideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentVideoPreview.Merge(m, src)
}
func (m *ModelBlockContentVideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentVideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentVideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentVideoPreview proto.InternalMessageInfo

func (m *ModelBlockContentVideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelBlockContentVideoPreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ModelBlockContentVideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type ModelBlockContentImage struct {
	LocalFilePath string                         `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         ModelBlockContentImageState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.ModelBlockContentImageState" json:"state,omitempty"`
	Preview       *ModelBlockContentImagePreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *ModelBlockContentImage) Reset()         { *m = ModelBlockContentImage{} }
func (m *ModelBlockContentImage) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentImage) ProtoMessage()    {}
func (*ModelBlockContentImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 7}
}
func (m *ModelBlockContentImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentImage.Merge(m, src)
}
func (m *ModelBlockContentImage) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentImage) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentImage.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentImage proto.InternalMessageInfo

func (m *ModelBlockContentImage) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *ModelBlockContentImage) GetState() ModelBlockContentImageState {
	if m != nil {
		return m.State
	}
	return ModelBlockContentImage_EMPTY
}

func (m *ModelBlockContentImage) GetPreview() *ModelBlockContentImagePreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type ModelBlockContentImagePreview struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon  string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
	Width int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *ModelBlockContentImagePreview) Reset()         { *m = ModelBlockContentImagePreview{} }
func (m *ModelBlockContentImagePreview) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentImagePreview) ProtoMessage()    {}
func (*ModelBlockContentImagePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 7, 0}
}
func (m *ModelBlockContentImagePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentImagePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentImagePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentImagePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentImagePreview.Merge(m, src)
}
func (m *ModelBlockContentImagePreview) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentImagePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentImagePreview.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentImagePreview proto.InternalMessageInfo

func (m *ModelBlockContentImagePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelBlockContentImagePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *ModelBlockContentImagePreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type ModelBlockContentFile struct {
	LocalFilePath string                        `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         ModelBlockContentFileState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.ModelBlockContentFileState" json:"state,omitempty"`
	Preview       *ModelBlockContentFilePreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *ModelBlockContentFile) Reset()         { *m = ModelBlockContentFile{} }
func (m *ModelBlockContentFile) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentFile) ProtoMessage()    {}
func (*ModelBlockContentFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 8}
}
func (m *ModelBlockContentFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentFile.Merge(m, src)
}
func (m *ModelBlockContentFile) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentFile) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentFile.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentFile proto.InternalMessageInfo

func (m *ModelBlockContentFile) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *ModelBlockContentFile) GetState() ModelBlockContentFileState {
	if m != nil {
		return m.State
	}
	return ModelBlockContentFile_EMPTY
}

func (m *ModelBlockContentFile) GetPreview() *ModelBlockContentFilePreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type ModelBlockContentFilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *ModelBlockContentFilePreview) Reset()         { *m = ModelBlockContentFilePreview{} }
func (m *ModelBlockContentFilePreview) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentFilePreview) ProtoMessage()    {}
func (*ModelBlockContentFilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 8, 0}
}
func (m *ModelBlockContentFilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentFilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentFilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentFilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentFilePreview.Merge(m, src)
}
func (m *ModelBlockContentFilePreview) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentFilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentFilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentFilePreview proto.InternalMessageInfo

func (m *ModelBlockContentFilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelBlockContentFilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type ModelBlockContentPage struct {
	Style ModelBlockContentPageStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.ModelBlockContentPageStyle" json:"style,omitempty"`
}

func (m *ModelBlockContentPage) Reset()         { *m = ModelBlockContentPage{} }
func (m *ModelBlockContentPage) String() string { return proto.CompactTextString(m) }
func (*ModelBlockContentPage) ProtoMessage()    {}
func (*ModelBlockContentPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 9}
}
func (m *ModelBlockContentPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelBlockContentPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelBlockContentPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelBlockContentPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelBlockContentPage.Merge(m, src)
}
func (m *ModelBlockContentPage) XXX_Size() int {
	return m.Size()
}
func (m *ModelBlockContentPage) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelBlockContentPage.DiscardUnknown(m)
}

var xxx_messageInfo_ModelBlockContentPage proto.InternalMessageInfo

func (m *ModelBlockContentPage) GetStyle() ModelBlockContentPageStyle {
	if m != nil {
		return m.Style
	}
	return ModelBlockContentPage_EMPTY
}

//
// General purpose structure, uses in Mark.
type ModelRange struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *ModelRange) Reset()         { *m = ModelRange{} }
func (m *ModelRange) String() string { return proto.CompactTextString(m) }
func (*ModelRange) ProtoMessage()    {}
func (*ModelRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 1}
}
func (m *ModelRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelRange.Merge(m, src)
}
func (m *ModelRange) XXX_Size() int {
	return m.Size()
}
func (m *ModelRange) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelRange.DiscardUnknown(m)
}

var xxx_messageInfo_ModelRange proto.InternalMessageInfo

func (m *ModelRange) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ModelRange) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

//*
// Contains basic information about a user account
type ModelAccount struct {
	Id     string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Avatar *ModelAccountAvatar `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *ModelAccount) Reset()         { *m = ModelAccount{} }
func (m *ModelAccount) String() string { return proto.CompactTextString(m) }
func (*ModelAccount) ProtoMessage()    {}
func (*ModelAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2}
}
func (m *ModelAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAccount.Merge(m, src)
}
func (m *ModelAccount) XXX_Size() int {
	return m.Size()
}
func (m *ModelAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAccount proto.InternalMessageInfo

func (m *ModelAccount) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModelAccount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ModelAccount) GetAvatar() *ModelAccountAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

//*
// Avatar of a user's account. It could be an image or color
type ModelAccountAvatar struct {
	// Types that are valid to be assigned to Avatar:
	//	*ModelAccountAvatarAvatarOfImage
	//	*ModelAccountAvatarAvatarOfColor
	Avatar isModelAccountAvatarAvatar `protobuf_oneof:"avatar"`
}

func (m *ModelAccountAvatar) Reset()         { *m = ModelAccountAvatar{} }
func (m *ModelAccountAvatar) String() string { return proto.CompactTextString(m) }
func (*ModelAccountAvatar) ProtoMessage()    {}
func (*ModelAccountAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2, 0}
}
func (m *ModelAccountAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelAccountAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelAccountAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelAccountAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAccountAvatar.Merge(m, src)
}
func (m *ModelAccountAvatar) XXX_Size() int {
	return m.Size()
}
func (m *ModelAccountAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAccountAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAccountAvatar proto.InternalMessageInfo

type isModelAccountAvatarAvatar interface {
	isModelAccountAvatarAvatar()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModelAccountAvatarAvatarOfImage struct {
	Image *ModelImage `protobuf:"bytes,1,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type ModelAccountAvatarAvatarOfColor struct {
	Color string `protobuf:"bytes,2,opt,name=color,proto3,oneof" json:"color,omitempty"`
}

func (*ModelAccountAvatarAvatarOfImage) isModelAccountAvatarAvatar() {}
func (*ModelAccountAvatarAvatarOfColor) isModelAccountAvatarAvatar() {}

func (m *ModelAccountAvatar) GetAvatar() isModelAccountAvatarAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *ModelAccountAvatar) GetImage() *ModelImage {
	if x, ok := m.GetAvatar().(*ModelAccountAvatarAvatarOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *ModelAccountAvatar) GetColor() string {
	if x, ok := m.GetAvatar().(*ModelAccountAvatarAvatarOfColor); ok {
		return x.Color
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModelAccountAvatar) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModelAccountAvatarAvatarOfImage)(nil),
		(*ModelAccountAvatarAvatarOfColor)(nil),
	}
}

type ModelImage struct {
	Id    string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []ModelImageSize `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.ModelImageSize" json:"sizes,omitempty"`
}

func (m *ModelImage) Reset()         { *m = ModelImage{} }
func (m *ModelImage) String() string { return proto.CompactTextString(m) }
func (*ModelImage) ProtoMessage()    {}
func (*ModelImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 3}
}
func (m *ModelImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelImage.Merge(m, src)
}
func (m *ModelImage) XXX_Size() int {
	return m.Size()
}
func (m *ModelImage) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelImage.DiscardUnknown(m)
}

var xxx_messageInfo_ModelImage proto.InternalMessageInfo

func (m *ModelImage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModelImage) GetSizes() []ModelImageSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

type ModelVideo struct {
	Id    string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []ModelVideoSize `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.ModelVideoSize" json:"sizes,omitempty"`
}

func (m *ModelVideo) Reset()         { *m = ModelVideo{} }
func (m *ModelVideo) String() string { return proto.CompactTextString(m) }
func (*ModelVideo) ProtoMessage()    {}
func (*ModelVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 4}
}
func (m *ModelVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelVideo.Merge(m, src)
}
func (m *ModelVideo) XXX_Size() int {
	return m.Size()
}
func (m *ModelVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelVideo.DiscardUnknown(m)
}

var xxx_messageInfo_ModelVideo proto.InternalMessageInfo

func (m *ModelVideo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ModelVideo) GetSizes() []ModelVideoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func init() {
	proto.RegisterEnum("anytype.ModelBlockPosition", ModelBlockPosition_name, ModelBlockPosition_value)
	proto.RegisterEnum("anytype.ModelBlockContentLayoutStyle", ModelBlockContentLayoutStyle_name, ModelBlockContentLayoutStyle_value)
	proto.RegisterEnum("anytype.ModelBlockContentDashboardStyle", ModelBlockContentDashboardStyle_name, ModelBlockContentDashboardStyle_value)
	proto.RegisterEnum("anytype.ModelBlockContentTextStyle", ModelBlockContentTextStyle_name, ModelBlockContentTextStyle_value)
	proto.RegisterEnum("anytype.ModelBlockContentTextMarkerType", ModelBlockContentTextMarkerType_name, ModelBlockContentTextMarkerType_value)
	proto.RegisterEnum("anytype.ModelBlockContentTextMarkType", ModelBlockContentTextMarkType_name, ModelBlockContentTextMarkType_value)
	proto.RegisterEnum("anytype.ModelBlockContentVideoState", ModelBlockContentVideoState_name, ModelBlockContentVideoState_value)
	proto.RegisterEnum("anytype.ModelBlockContentImageState", ModelBlockContentImageState_name, ModelBlockContentImageState_value)
	proto.RegisterEnum("anytype.ModelBlockContentFileState", ModelBlockContentFileState_name, ModelBlockContentFileState_value)
	proto.RegisterEnum("anytype.ModelBlockContentPageStyle", ModelBlockContentPageStyle_name, ModelBlockContentPageStyle_value)
	proto.RegisterEnum("anytype.ModelImageSize", ModelImageSize_name, ModelImageSize_value)
	proto.RegisterEnum("anytype.ModelVideoSize", ModelVideoSize_name, ModelVideoSize_value)
	proto.RegisterType((*Model)(nil), "anytype.Model")
	proto.RegisterType((*ModelBlock)(nil), "anytype.Model.Block")
	proto.RegisterType((*ModelBlockPermissions)(nil), "anytype.Model.Block.Permissions")
	proto.RegisterType((*ModelBlockContent)(nil), "anytype.Model.Block.Content")
	proto.RegisterType((*ModelBlockContentLayout)(nil), "anytype.Model.Block.Content.Layout")
	proto.RegisterType((*ModelBlockContentDiv)(nil), "anytype.Model.Block.Content.Div")
	proto.RegisterType((*ModelBlockContentBookmark)(nil), "anytype.Model.Block.Content.Bookmark")
	proto.RegisterType((*ModelBlockContentDashboard)(nil), "anytype.Model.Block.Content.Dashboard")
	proto.RegisterType((*ModelBlockContentDataview)(nil), "anytype.Model.Block.Content.Dataview")
	proto.RegisterType((*ModelBlockContentText)(nil), "anytype.Model.Block.Content.Text")
	proto.RegisterType((*ModelBlockContentTextMark)(nil), "anytype.Model.Block.Content.Text.Mark")
	proto.RegisterType((*ModelBlockContentTextMarks)(nil), "anytype.Model.Block.Content.Text.Marks")
	proto.RegisterType((*ModelBlockContentVideo)(nil), "anytype.Model.Block.Content.Video")
	proto.RegisterType((*ModelBlockContentVideoPreview)(nil), "anytype.Model.Block.Content.Video.Preview")
	proto.RegisterType((*ModelBlockContentImage)(nil), "anytype.Model.Block.Content.Image")
	proto.RegisterType((*ModelBlockContentImagePreview)(nil), "anytype.Model.Block.Content.Image.Preview")
	proto.RegisterType((*ModelBlockContentFile)(nil), "anytype.Model.Block.Content.File")
	proto.RegisterType((*ModelBlockContentFilePreview)(nil), "anytype.Model.Block.Content.File.Preview")
	proto.RegisterType((*ModelBlockContentPage)(nil), "anytype.Model.Block.Content.Page")
	proto.RegisterType((*ModelRange)(nil), "anytype.Model.Range")
	proto.RegisterType((*ModelAccount)(nil), "anytype.Model.Account")
	proto.RegisterType((*ModelAccountAvatar)(nil), "anytype.Model.Account.Avatar")
	proto.RegisterType((*ModelImage)(nil), "anytype.Model.Image")
	proto.RegisterType((*ModelVideo)(nil), "anytype.Model.Video")
}

func init() { proto.RegisterFile("models.proto", fileDescriptor_0b5431a010549573) }

var fileDescriptor_0b5431a010549573 = []byte{
	// 1424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x26, 0x29, 0x52, 0x8f, 0xa3, 0xd8, 0x99, 0xcc, 0x0d, 0x12, 0x5e, 0x5e, 0x5f, 0xc3, 0xd1,
	0x7d, 0xc4, 0x79, 0x80, 0xf1, 0xab, 0x4d, 0x51, 0x34, 0x0d, 0x24, 0x4b, 0xb6, 0x04, 0x4b, 0x96,
	0x30, 0x92, 0x93, 0xa6, 0x1b, 0x83, 0x12, 0xc7, 0x32, 0x61, 0x4a, 0x54, 0x28, 0xda, 0x89, 0xf3,
	0x2b, 0xba, 0xeb, 0x0f, 0xe8, 0xbe, 0x3f, 0xa1, 0xdb, 0x76, 0x19, 0x74, 0xd3, 0x02, 0xdd, 0x14,
	0xc9, 0xb6, 0x3f, 0xa2, 0x38, 0x33, 0xa4, 0x2d, 0x3b, 0x81, 0xad, 0xa0, 0xed, 0xa2, 0x2b, 0xce,
	0x19, 0x9e, 0xef, 0x9c, 0xc3, 0xef, 0x3c, 0x66, 0x08, 0x57, 0x06, 0x81, 0xcb, 0xfd, 0xb1, 0x3d,
	0x0a, 0x83, 0x28, 0xa0, 0x19, 0x67, 0x78, 0x1c, 0x1d, 0x8f, 0xb8, 0x35, 0xd7, 0x0f, 0x82, 0xbe,
	0xcf, 0x1f, 0x88, 0xed, 0xee, 0xe1, 0xde, 0x83, 0x71, 0x14, 0x1e, 0xf6, 0x22, 0xa9, 0x56, 0xf8,
	0xed, 0x5f, 0x60, 0x34, 0x10, 0x67, 0xfd, 0x72, 0x13, 0x8c, 0x92, 0x1f, 0xf4, 0x0e, 0xe8, 0x2c,
	0x68, 0x9e, 0x6b, 0xaa, 0x0b, 0xea, 0x62, 0x8e, 0x69, 0x9e, 0x4b, 0x1f, 0x40, 0x7a, 0xcf, 0xe3,
	0xbe, 0x3b, 0x36, 0xb5, 0x05, 0x75, 0x31, 0xbf, 0x72, 0xd3, 0x96, 0x26, 0xed, 0xc4, 0xa4, 0xdd,
	0x16, 0x26, 0x59, 0xac, 0x46, 0x4b, 0x90, 0x1f, 0xf1, 0x70, 0xe0, 0x8d, 0xc7, 0x5e, 0x30, 0x1c,
	0x9b, 0x29, 0x81, 0x5a, 0xb0, 0xe3, 0x88, 0x6c, 0xe1, 0xcf, 0x16, 0xbe, 0xec, 0xd6, 0xa9, 0x1e,
	0x9b, 0x04, 0xd1, 0x05, 0xc8, 0xf7, 0xf6, 0x3d, 0xdf, 0x0d, 0xf9, 0xb0, 0xe6, 0x8e, 0x4d, 0x7d,
	0x21, 0xb5, 0x98, 0x63, 0x93, 0x5b, 0x74, 0x03, 0x72, 0xae, 0x33, 0xde, 0xef, 0x06, 0x4e, 0xe8,
	0x9a, 0x79, 0xe1, 0xe3, 0xff, 0xef, 0xf5, 0xb1, 0x1e, 0x0c, 0x23, 0x3e, 0x8c, 0xec, 0x72, 0xa2,
	0x5d, 0x55, 0xd8, 0x29, 0x94, 0x3e, 0x04, 0x7d, 0xe4, 0xf4, 0xb9, 0x79, 0x45, 0x98, 0xb8, 0x75,
	0xa1, 0x89, 0x96, 0xd3, 0xe7, 0x55, 0x85, 0x09, 0x00, 0x5d, 0x87, 0xac, 0xeb, 0x44, 0xce, 0x91,
	0xc7, 0x5f, 0x98, 0x33, 0x02, 0xfc, 0xbf, 0x4b, 0xfc, 0x4b, 0xe5, 0xaa, 0xc2, 0x4e, 0x80, 0xe8,
	0x3d, 0xe2, 0x2f, 0x23, 0x73, 0x76, 0x0a, 0xef, 0x1d, 0xfe, 0x32, 0x42, 0xef, 0x08, 0xa0, 0x9f,
	0x82, 0x71, 0xe4, 0xb9, 0x3c, 0x30, 0xaf, 0x0a, 0x64, 0xe1, 0x42, 0xe4, 0x13, 0xd4, 0xac, 0x2a,
	0x4c, 0x42, 0x10, 0xeb, 0x0d, 0xf0, 0x9b, 0xc9, 0x14, 0xd8, 0xda, 0x40, 0x7e, 0xb4, 0x84, 0x60,
	0xc0, 0x7b, 0x9e, 0xcf, 0xcd, 0x6b, 0x53, 0x04, 0xbc, 0xe1, 0xf9, 0x82, 0x2e, 0x04, 0xd0, 0x47,
	0x90, 0xf6, 0x9d, 0xe3, 0xe0, 0x30, 0x32, 0xa9, 0x80, 0xfe, 0xe7, 0x42, 0x68, 0x5d, 0xa8, 0x56,
	0x15, 0x16, 0x83, 0xe8, 0x1a, 0xa4, 0x5c, 0xef, 0xc8, 0xfc, 0xc7, 0x05, 0xc5, 0x74, 0x42, 0xb4,
	0x77, 0x54, 0x55, 0x18, 0xaa, 0x63, 0x8e, 0xba, 0x41, 0x70, 0x30, 0x70, 0xc2, 0x03, 0xf3, 0xfa,
	0x14, 0x39, 0x2a, 0xc5, 0xca, 0x98, 0xa3, 0x04, 0x68, 0x1d, 0x43, 0x7e, 0xa2, 0x4e, 0x29, 0x05,
	0x3d, 0xe4, 0x8e, 0xec, 0x90, 0x2c, 0x13, 0x6b, 0xdc, 0xe3, 0xae, 0x17, 0x89, 0x0e, 0xc9, 0x32,
	0xb1, 0xa6, 0x37, 0x20, 0x1d, 0xf2, 0x41, 0x70, 0xc4, 0x45, 0x07, 0x64, 0x59, 0x2c, 0xa1, 0xae,
	0x1b, 0x3a, 0x7d, 0x53, 0x97, 0xba, 0xb8, 0x46, 0x5d, 0x37, 0x0c, 0x46, 0xcd, 0xa1, 0x69, 0x48,
	0x5d, 0x29, 0x59, 0x5f, 0x13, 0xc8, 0xc4, 0xb1, 0x59, 0x7d, 0x48, 0x4b, 0x56, 0xe8, 0x63, 0x30,
	0xc6, 0xd1, 0xb1, 0xcf, 0x45, 0x08, 0xb3, 0x2b, 0x77, 0xa6, 0x60, 0xd2, 0x6e, 0x23, 0x80, 0x49,
	0x5c, 0x61, 0x0e, 0x0c, 0x21, 0xd3, 0x0c, 0xa4, 0x58, 0xf3, 0x29, 0x51, 0x28, 0x40, 0x7a, 0xbd,
	0x59, 0xdf, 0x69, 0x6c, 0x13, 0xd5, 0x32, 0x20, 0x55, 0xf6, 0x8e, 0x2c, 0x80, 0x6c, 0x42, 0x87,
	0xe5, 0x41, 0xee, 0xa4, 0x7d, 0x68, 0xe9, 0xac, 0xfb, 0xfb, 0xd3, 0x75, 0xdd, 0xd9, 0x08, 0xcc,
	0x24, 0x82, 0xab, 0x90, 0x6f, 0x14, 0x6b, 0xdb, 0xbb, 0xed, 0x75, 0x56, 0xa9, 0x6c, 0x13, 0x05,
	0xdd, 0x26, 0x9d, 0x62, 0xfd, 0x64, 0x80, 0x8e, 0x55, 0x8f, 0x9c, 0x89, 0x36, 0x91, 0x53, 0x49,
	0x76, 0xc0, 0xa3, 0x24, 0x0c, 0x4d, 0x84, 0x71, 0xfb, 0xd2, 0xde, 0x39, 0x13, 0x01, 0xad, 0x40,
	0x0e, 0x3f, 0x6d, 0x5c, 0xf7, 0xc6, 0x51, 0x3c, 0xa3, 0xa6, 0x30, 0xd1, 0x40, 0x08, 0x3b, 0x45,
	0xd2, 0x79, 0x80, 0x28, 0xe8, 0xf7, 0x7d, 0xee, 0x74, 0x7d, 0x1e, 0xe7, 0x74, 0x62, 0x87, 0xd6,
	0x01, 0x50, 0x99, 0x87, 0x9d, 0xe3, 0x11, 0x17, 0xd9, 0xbd, 0x8c, 0xb1, 0x13, 0x3f, 0x12, 0xc3,
	0x26, 0xf0, 0x74, 0x0e, 0x72, 0xbd, 0x7d, 0xde, 0x3b, 0x10, 0xce, 0xd2, 0xc2, 0xd9, 0xe9, 0x06,
	0x35, 0x21, 0x23, 0x04, 0xee, 0x9a, 0x19, 0xf1, 0x2e, 0x11, 0xad, 0x1f, 0x55, 0xd0, 0xd1, 0x24,
	0xbd, 0x0b, 0x46, 0xe8, 0x0c, 0xfb, 0x32, 0x77, 0xf9, 0x95, 0xeb, 0xe7, 0x22, 0x61, 0xf8, 0x8e,
	0x49, 0x15, 0xfa, 0x18, 0x74, 0x7c, 0x15, 0xf3, 0x7b, 0x6f, 0xba, 0xa0, 0x6d, 0x11, 0xb3, 0x00,
	0xd2, 0xeb, 0x60, 0x8c, 0x9c, 0xd0, 0x19, 0x08, 0x7a, 0x73, 0x4c, 0x0a, 0x85, 0x4d, 0xd0, 0xc5,
	0xb7, 0x5c, 0x83, 0x99, 0x76, 0x87, 0xd5, 0xb6, 0x2a, 0x9d, 0x2a, 0x6b, 0xee, 0x6c, 0x56, 0x89,
	0x42, 0xaf, 0x40, 0x76, 0xab, 0xf2, 0xac, 0xd4, 0x2c, 0xb2, 0x32, 0x51, 0xb1, 0x26, 0x6b, 0x9d,
	0x62, 0xbd, 0xb6, 0x4e, 0x34, 0x9a, 0x05, 0xbd, 0xd4, 0xac, 0x97, 0x49, 0x0a, 0x57, 0xf5, 0xda,
	0xf6, 0x16, 0xd1, 0xad, 0x0a, 0x18, 0x22, 0x1d, 0xf4, 0x33, 0x30, 0x44, 0x42, 0x4c, 0x75, 0x21,
	0x75, 0xe9, 0x31, 0x70, 0x12, 0x29, 0x93, 0xa0, 0xc2, 0x7a, 0x52, 0x8a, 0x06, 0xa8, 0x23, 0xa2,
	0xd0, 0x34, 0x68, 0xfb, 0xcb, 0x44, 0x15, 0xcf, 0x15, 0xa2, 0x89, 0xe7, 0x2a, 0x49, 0x89, 0xe7,
	0x1a, 0xd1, 0x69, 0x0e, 0x8c, 0xe7, 0x87, 0x41, 0xc4, 0x89, 0x81, 0xb1, 0xf4, 0x02, 0x97, 0x93,
	0x74, 0xc1, 0x06, 0x38, 0x4d, 0x19, 0xee, 0x0f, 0x83, 0x21, 0x97, 0x7d, 0x35, 0x3c, 0x1c, 0x74,
	0x79, 0x28, 0xbf, 0xa7, 0x7b, 0xe8, 0xfb, 0x3c, 0x22, 0x9a, 0xf5, 0xbd, 0x06, 0x86, 0x98, 0xca,
	0xf4, 0xbf, 0x30, 0xe3, 0x07, 0x3d, 0xc7, 0xc7, 0x61, 0xd9, 0x72, 0xa2, 0xfd, 0xb8, 0xc6, 0xcf,
	0x6e, 0xd2, 0xcf, 0xb1, 0xd8, 0x9d, 0x28, 0x49, 0xc6, 0xe2, 0xe5, 0xe3, 0xde, 0x6e, 0xa3, 0x3e,
	0x93, 0x30, 0x5a, 0x86, 0xcc, 0x28, 0xe4, 0xe2, 0xac, 0x92, 0xb5, 0x7e, 0x77, 0x0a, 0x0b, 0x2d,
	0x89, 0x60, 0x09, 0xd4, 0xda, 0x84, 0x4c, 0xbc, 0x87, 0x1d, 0x39, 0x74, 0x06, 0x3c, 0xe9, 0x48,
	0x5c, 0xe3, 0x9e, 0xd7, 0x0b, 0x86, 0x22, 0xc6, 0x1c, 0x13, 0x6b, 0xac, 0x81, 0x17, 0x9e, 0x1b,
	0xed, 0x0b, 0xb7, 0x06, 0x93, 0x42, 0xa1, 0x86, 0x9c, 0x63, 0x5c, 0x39, 0x30, 0x2a, 0x8d, 0x56,
	0xe7, 0x19, 0x51, 0xe8, 0x0c, 0xe4, 0x76, 0x5a, 0xf5, 0x66, 0xb1, 0x5c, 0xdb, 0xde, 0x24, 0x2a,
	0xcd, 0x43, 0xa6, 0xc5, 0x2a, 0x4f, 0x6a, 0x95, 0xa7, 0x44, 0xc3, 0x29, 0x51, 0x6e, 0x3e, 0xdd,
	0x4e, 0xde, 0x8a, 0x2a, 0x28, 0x37, 0xb7, 0x2b, 0x44, 0x17, 0x4c, 0x8a, 0x33, 0xea, 0xaf, 0x60,
	0x52, 0x18, 0xfe, 0x43, 0x4c, 0x4a, 0x0b, 0x7f, 0x0b, 0x26, 0xbf, 0xd5, 0x40, 0x47, 0x9a, 0xa6,
	0x24, 0xf2, 0xd1, 0x59, 0x22, 0x6f, 0x5f, 0x7a, 0x15, 0x38, 0xcb, 0xe3, 0xfa, 0x79, 0x1e, 0xef,
	0x5c, 0x6e, 0xe0, 0x1d, 0x1a, 0x97, 0x3f, 0x98, 0xc6, 0x3f, 0x93, 0xb0, 0x57, 0xa0, 0xe3, 0x8d,
	0xf0, 0xf4, 0x24, 0x52, 0xa7, 0x60, 0xa2, 0x25, 0x2b, 0x6a, 0xe2, 0x2c, 0x5c, 0x4d, 0x06, 0xd0,
	0x44, 0x44, 0x59, 0xd0, 0x3b, 0xc5, 0xf6, 0x16, 0x51, 0x71, 0x26, 0x96, 0x9a, 0xcd, 0xad, 0x46,
	0x91, 0x6d, 0x11, 0x0d, 0x0f, 0xec, 0x76, 0xa5, 0x43, 0x52, 0x85, 0x5b, 0x90, 0x6d, 0x05, 0x63,
	0x2f, 0xf2, 0x82, 0x21, 0x0e, 0x96, 0x52, 0x65, 0xa3, 0xc9, 0x2a, 0x44, 0x41, 0x1b, 0xc5, 0x8d,
	0x4e, 0x85, 0x11, 0xb5, 0x94, 0x83, 0x4c, 0x2f, 0xbe, 0x3b, 0xdc, 0x03, 0x43, 0x8c, 0x76, 0x64,
	0x64, 0x2f, 0x0c, 0x06, 0x22, 0x52, 0x83, 0x89, 0x35, 0x5e, 0xf8, 0xa3, 0x40, 0x70, 0x64, 0x30,
	0x2d, 0x0a, 0xac, 0xef, 0x54, 0xc8, 0x14, 0x7b, 0xbd, 0xe0, 0x70, 0x18, 0xbd, 0xf3, 0x33, 0x90,
	0xb0, 0xac, 0x4d, 0xb0, 0xfc, 0x11, 0xa4, 0x9d, 0x23, 0x27, 0x72, 0xc2, 0x38, 0x91, 0xff, 0x3e,
	0xf7, 0xfd, 0xb1, 0x2d, 0xbb, 0x28, 0x94, 0x58, 0xac, 0x6c, 0x7d, 0x01, 0x69, 0xb9, 0x43, 0xef,
	0x27, 0xf7, 0xd1, 0xf7, 0x1f, 0x4a, 0xe7, 0x6e, 0xa0, 0x37, 0xc0, 0xe8, 0x05, 0x7e, 0x10, 0xca,
	0x18, 0x70, 0x5f, 0x88, 0xa5, 0x6c, 0x12, 0x86, 0xf5, 0x3c, 0x99, 0x08, 0xef, 0xfe, 0xca, 0x18,
	0x63, 0xef, 0x15, 0xc7, 0x3f, 0x99, 0xd4, 0xe2, 0xec, 0xca, 0x3f, 0xdf, 0xe7, 0xc8, 0x6e, 0x7b,
	0xaf, 0x30, 0x35, 0xa8, 0x57, 0xb8, 0x0d, 0x3a, 0x8a, 0xc8, 0x6a, 0xbd, 0xc8, 0x36, 0x63, 0x82,
	0xdb, 0x8d, 0x62, 0xbd, 0x4e, 0x54, 0x5c, 0x76, 0xaa, 0x3b, 0x8d, 0x12, 0xd1, 0xac, 0x6f, 0xd4,
	0x64, 0x9e, 0x7f, 0xa0, 0xcf, 0x78, 0x56, 0x4f, 0xf8, 0x7c, 0x16, 0xfb, 0xcc, 0x43, 0xa6, 0x5d,
	0xde, 0x5d, 0xfd, 0x78, 0x09, 0x0f, 0x25, 0x29, 0xac, 0x7d, 0xb2, 0x34, 0x92, 0xf5, 0x59, 0x2d,
	0xef, 0x3e, 0x5c, 0x59, 0x1a, 0x11, 0x0d, 0xeb, 0xa3, 0x5a, 0xde, 0x5d, 0x5e, 0xc2, 0x57, 0x29,
	0x51, 0xc9, 0x28, 0xae, 0xad, 0x2d, 0x8d, 0x88, 0x9e, 0x88, 0x2b, 0xcb, 0x68, 0xc5, 0x28, 0xcd,
	0xfd, 0xf0, 0x66, 0x5e, 0x7d, 0xfd, 0x66, 0x5e, 0xfd, 0xf5, 0xcd, 0xbc, 0xfa, 0xd5, 0xdb, 0x79,
	0xe5, 0xf5, 0xdb, 0x79, 0xe5, 0xe7, 0xb7, 0xf3, 0xca, 0x97, 0xda, 0xa8, 0xdb, 0x4d, 0x8b, 0x1f,
	0xba, 0xd5, 0xdf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x80, 0x67, 0x69, 0x4d, 0x4a, 0x0e, 0x00, 0x00,
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ChildrenIds) > 0 {
		for iNdEx := len(m.ChildrenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChildrenIds[iNdEx])
			copy(dAtA[i:], m.ChildrenIds[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.ChildrenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentOfDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockContentOfBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentOfBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bookmark != nil {
		{
			size, err := m.Bookmark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ModelBlockPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentBookmark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentDashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MarkerType != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MarkerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MarksList != nil {
		{
			size, err := m.MarksList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentTextMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentTextMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentTextMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentTextMarks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentTextMarks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentTextMarks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentVideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentVideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentVideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentImagePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentImagePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentImagePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentFilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentFilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentFilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelBlockContentPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelBlockContentPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelBlockContentPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModelAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelAccountAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelAccountAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAccountAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModelAccountAvatarAvatarOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAccountAvatarAvatarOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ModelAccountAvatarAvatarOfColor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelAccountAvatarAvatarOfColor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Color)
	copy(dAtA[i:], m.Color)
	i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ModelImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		dAtA21 := make([]byte, len(m.Sizes)*10)
		var j20 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintModels(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		dAtA23 := make([]byte, len(m.Sizes)*10)
		var j22 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintModels(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.ChildrenIds) > 0 {
		for _, s := range m.ChildrenIds {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *ModelBlockContentOfDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockContentOfBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bookmark != nil {
		l = m.Bookmark.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelBlockPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *ModelBlockContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelBlockContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *ModelBlockContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelBlockContentBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelBlockContentDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *ModelBlockContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ModelBlockContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.MarksList != nil {
		l = m.MarksList.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.MarkerType != 0 {
		n += 1 + sovModels(uint64(m.MarkerType))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *ModelBlockContentTextMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelBlockContentTextMarks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *ModelBlockContentVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelBlockContentVideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *ModelBlockContentImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelBlockContentImagePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *ModelBlockContentFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelBlockContentFilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelBlockContentPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *ModelRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovModels(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovModels(uint64(m.To))
	}
	return n
}

func (m *ModelAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *ModelAccountAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	return n
}

func (m *ModelAccountAvatarAvatarOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *ModelAccountAvatarAvatarOfColor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Color)
	n += 1 + l + sovModels(uint64(l))
	return n
}
func (m *ModelImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func (m *ModelVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &ModelBlockPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildrenIds = append(m.ChildrenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentDashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfDashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentPage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfPage{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfDataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfText{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfVideo{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfImage{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfFile{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfLayout{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfDiv{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bookmark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelBlockContentBookmark{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &ModelBlockContentOfBookmark{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= ModelBlockContentLayoutStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Div: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Div: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentBookmark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bookmark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bookmark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentDashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= ModelBlockContentDashboardStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= ModelBlockContentTextStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarksList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarksList == nil {
				m.MarksList = &ModelBlockContentTextMarks{}
			}
			if err := m.MarksList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerType", wireType)
			}
			m.MarkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkerType |= ModelBlockContentTextMarkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentTextMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &ModelRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ModelBlockContentTextMarkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentTextMarks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &ModelBlockContentTextMark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ModelBlockContentVideoState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &ModelBlockContentVideoPreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentVideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ModelBlockContentImageState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &ModelBlockContentImagePreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentImagePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ModelBlockContentFileState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &ModelBlockContentFilePreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentFilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelBlockContentPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= ModelBlockContentPageStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &ModelAccountAvatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelAccountAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ModelImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Avatar = &ModelAccountAvatarAvatarOfImage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &ModelAccountAvatarAvatarOfColor{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v ModelImageSize
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ModelImageSize(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]ModelImageSize, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ModelImageSize
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ModelImageSize(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v ModelVideoSize
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ModelVideoSize(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]ModelVideoSize, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ModelVideoSize
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ModelVideoSize(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
