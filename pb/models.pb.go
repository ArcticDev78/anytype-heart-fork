// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Model_Block_Header_Type int32

const (
	Model_Block_Header_DASHBOARD Model_Block_Header_Type = 0
	Model_Block_Header_PAGE      Model_Block_Header_Type = 1
	Model_Block_Header_DATAVIEW  Model_Block_Header_Type = 2
	Model_Block_Header_TEXT      Model_Block_Header_Type = 3
	Model_Block_Header_FILE      Model_Block_Header_Type = 4
	Model_Block_Header_PICTURE   Model_Block_Header_Type = 5
	Model_Block_Header_VIDEO     Model_Block_Header_Type = 6
	Model_Block_Header_BOOKMARK  Model_Block_Header_Type = 7
	Model_Block_Header_LAYOUT    Model_Block_Header_Type = 8
	Model_Block_Header_DIV       Model_Block_Header_Type = 9
)

var Model_Block_Header_Type_name = map[int32]string{
	0: "DASHBOARD",
	1: "PAGE",
	2: "DATAVIEW",
	3: "TEXT",
	4: "FILE",
	5: "PICTURE",
	6: "VIDEO",
	7: "BOOKMARK",
	8: "LAYOUT",
	9: "DIV",
}

var Model_Block_Header_Type_value = map[string]int32{
	"DASHBOARD": 0,
	"PAGE":      1,
	"DATAVIEW":  2,
	"TEXT":      3,
	"FILE":      4,
	"PICTURE":   5,
	"VIDEO":     6,
	"BOOKMARK":  7,
	"LAYOUT":    8,
	"DIV":       9,
}

func (x Model_Block_Header_Type) String() string {
	return proto.EnumName(Model_Block_Header_Type_name, int32(x))
}

func (Model_Block_Header_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0, 0}
}

type Model_Block_Content_Layout_Style int32

const (
	Model_Block_Content_Layout_ROW    Model_Block_Content_Layout_Style = 0
	Model_Block_Content_Layout_COLUMN Model_Block_Content_Layout_Style = 1
)

var Model_Block_Content_Layout_Style_name = map[int32]string{
	0: "ROW",
	1: "COLUMN",
}

var Model_Block_Content_Layout_Style_value = map[string]int32{
	"ROW":    0,
	"COLUMN": 1,
}

func (x Model_Block_Content_Layout_Style) String() string {
	return proto.EnumName(Model_Block_Content_Layout_Style_name, int32(x))
}

func (Model_Block_Content_Layout_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 0, 0}
}

type Model_Block_Content_Dashboard_Style int32

const (
	Model_Block_Content_Dashboard_MAIN_SCREEN Model_Block_Content_Dashboard_Style = 0
)

var Model_Block_Content_Dashboard_Style_name = map[int32]string{
	0: "MAIN_SCREEN",
}

var Model_Block_Content_Dashboard_Style_value = map[string]int32{
	"MAIN_SCREEN": 0,
}

func (x Model_Block_Content_Dashboard_Style) String() string {
	return proto.EnumName(Model_Block_Content_Dashboard_Style_name, int32(x))
}

func (Model_Block_Content_Dashboard_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 2, 0}
}

type Model_Block_Content_Text_Style int32

const (
	Model_Block_Content_Text_p     Model_Block_Content_Text_Style = 0
	Model_Block_Content_Text_h1    Model_Block_Content_Text_Style = 1
	Model_Block_Content_Text_h2    Model_Block_Content_Text_Style = 2
	Model_Block_Content_Text_h3    Model_Block_Content_Text_Style = 3
	Model_Block_Content_Text_h4    Model_Block_Content_Text_Style = 4
	Model_Block_Content_Text_quote Model_Block_Content_Text_Style = 5
	Model_Block_Content_Text_code  Model_Block_Content_Text_Style = 6
)

var Model_Block_Content_Text_Style_name = map[int32]string{
	0: "p",
	1: "h1",
	2: "h2",
	3: "h3",
	4: "h4",
	5: "quote",
	6: "code",
}

var Model_Block_Content_Text_Style_value = map[string]int32{
	"p":     0,
	"h1":    1,
	"h2":    2,
	"h3":    3,
	"h4":    4,
	"quote": 5,
	"code":  6,
}

func (x Model_Block_Content_Text_Style) String() string {
	return proto.EnumName(Model_Block_Content_Text_Style_name, int32(x))
}

func (Model_Block_Content_Text_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4, 0}
}

type Model_Block_Content_Text_MarkerType int32

const (
	Model_Block_Content_Text_none   Model_Block_Content_Text_MarkerType = 0
	Model_Block_Content_Text_number Model_Block_Content_Text_MarkerType = 1
	Model_Block_Content_Text_bullet Model_Block_Content_Text_MarkerType = 2
)

var Model_Block_Content_Text_MarkerType_name = map[int32]string{
	0: "none",
	1: "number",
	2: "bullet",
}

var Model_Block_Content_Text_MarkerType_value = map[string]int32{
	"none":   0,
	"number": 1,
	"bullet": 2,
}

func (x Model_Block_Content_Text_MarkerType) String() string {
	return proto.EnumName(Model_Block_Content_Text_MarkerType_name, int32(x))
}

func (Model_Block_Content_Text_MarkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4, 1}
}

type Model_Block_Content_Text_Mark_Type int32

const (
	Model_Block_Content_Text_Mark_STRIKETHROUGH Model_Block_Content_Text_Mark_Type = 0
	Model_Block_Content_Text_Mark_KEYBOARD      Model_Block_Content_Text_Mark_Type = 1
	Model_Block_Content_Text_Mark_ITALIC        Model_Block_Content_Text_Mark_Type = 2
	Model_Block_Content_Text_Mark_BOLD          Model_Block_Content_Text_Mark_Type = 3
	Model_Block_Content_Text_Mark_LINK          Model_Block_Content_Text_Mark_Type = 4
)

var Model_Block_Content_Text_Mark_Type_name = map[int32]string{
	0: "STRIKETHROUGH",
	1: "KEYBOARD",
	2: "ITALIC",
	3: "BOLD",
	4: "LINK",
}

var Model_Block_Content_Text_Mark_Type_value = map[string]int32{
	"STRIKETHROUGH": 0,
	"KEYBOARD":      1,
	"ITALIC":        2,
	"BOLD":          3,
	"LINK":          4,
}

func (x Model_Block_Content_Text_Mark_Type) String() string {
	return proto.EnumName(Model_Block_Content_Text_Mark_Type_name, int32(x))
}

func (Model_Block_Content_Text_Mark_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4, 1, 0}
}

type Model_Block_Content_Media_State int32

const (
	Model_Block_Content_Media_EMPTY       Model_Block_Content_Media_State = 0
	Model_Block_Content_Media_UPLOADING   Model_Block_Content_Media_State = 1
	Model_Block_Content_Media_PREVIEW     Model_Block_Content_Media_State = 2
	Model_Block_Content_Media_DOWNLOADING Model_Block_Content_Media_State = 3
	Model_Block_Content_Media_DONE        Model_Block_Content_Media_State = 4
)

var Model_Block_Content_Media_State_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var Model_Block_Content_Media_State_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x Model_Block_Content_Media_State) String() string {
	return proto.EnumName(Model_Block_Content_Media_State_name, int32(x))
}

func (Model_Block_Content_Media_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 0}
}

type Model_Block_Content_Page_Style int32

const (
	Model_Block_Content_Page_EMPTY    Model_Block_Content_Page_Style = 0
	Model_Block_Content_Page_TASK     Model_Block_Content_Page_Style = 1
	Model_Block_Content_Page_BOOKMARK Model_Block_Content_Page_Style = 2
	Model_Block_Content_Page_SET      Model_Block_Content_Page_Style = 3
)

var Model_Block_Content_Page_Style_name = map[int32]string{
	0: "EMPTY",
	1: "TASK",
	2: "BOOKMARK",
	3: "SET",
}

var Model_Block_Content_Page_Style_value = map[string]int32{
	"EMPTY":    0,
	"TASK":     1,
	"BOOKMARK": 2,
	"SET":      3,
}

func (x Model_Block_Content_Page_Style) String() string {
	return proto.EnumName(Model_Block_Content_Page_Style_name, int32(x))
}

func (Model_Block_Content_Page_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 6, 0}
}

// `NullValue` is a singleton enumeration to represent the null value for the
type Model_Struct_NullValue int32

const (
	Model_Struct_NULL_VALUE Model_Struct_NullValue = 0
)

var Model_Struct_NullValue_name = map[int32]string{
	0: "NULL_VALUE",
}

var Model_Struct_NullValue_value = map[string]int32{
	"NULL_VALUE": 0,
}

func (x Model_Struct_NullValue) String() string {
	return proto.EnumName(Model_Struct_NullValue_name, int32(x))
}

func (Model_Struct_NullValue) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2, 0}
}

type Model_Image_Size int32

const (
	Model_Image_LARGE Model_Image_Size = 0
	Model_Image_SMALL Model_Image_Size = 1
	Model_Image_THUMB Model_Image_Size = 2
)

var Model_Image_Size_name = map[int32]string{
	0: "LARGE",
	1: "SMALL",
	2: "THUMB",
}

var Model_Image_Size_value = map[string]int32{
	"LARGE": 0,
	"SMALL": 1,
	"THUMB": 2,
}

func (x Model_Image_Size) String() string {
	return proto.EnumName(Model_Image_Size_name, int32(x))
}

func (Model_Image_Size) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 4, 0}
}

type Model_Video_Size int32

const (
	Model_Video_SD_360p   Model_Video_Size = 0
	Model_Video_SD_480p   Model_Video_Size = 1
	Model_Video_HD_720p   Model_Video_Size = 2
	Model_Video_HD_1080p  Model_Video_Size = 3
	Model_Video_UHD_1440p Model_Video_Size = 4
	Model_Video_UHD_2160p Model_Video_Size = 5
)

var Model_Video_Size_name = map[int32]string{
	0: "SD_360p",
	1: "SD_480p",
	2: "HD_720p",
	3: "HD_1080p",
	4: "UHD_1440p",
	5: "UHD_2160p",
}

var Model_Video_Size_value = map[string]int32{
	"SD_360p":   0,
	"SD_480p":   1,
	"HD_720p":   2,
	"HD_1080p":  3,
	"UHD_1440p": 4,
	"UHD_2160p": 5,
}

func (x Model_Video_Size) String() string {
	return proto.EnumName(Model_Video_Size_name, int32(x))
}

func (Model_Video_Size) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 5, 0}
}

type Model struct {
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type Model_Block struct {
	Header   *Model_Block_Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Children []string            `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*Model_Block_Dashboard
	//	*Model_Block_Page
	//	*Model_Block_Dataview
	//	*Model_Block_Text
	//	*Model_Block_Media
	//	*Model_Block_Layout
	//	*Model_Block_Div
	Content isModel_Block_Content `protobuf_oneof:"content"`
}

func (m *Model_Block) Reset()         { *m = Model_Block{} }
func (m *Model_Block) String() string { return proto.CompactTextString(m) }
func (*Model_Block) ProtoMessage()    {}
func (*Model_Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0}
}
func (m *Model_Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block.Merge(m, src)
}
func (m *Model_Block) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block proto.InternalMessageInfo

type isModel_Block_Content interface {
	isModel_Block_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Block_Dashboard struct {
	Dashboard *Model_Block_Content_Dashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type Model_Block_Page struct {
	Page *Model_Block_Content_Page `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type Model_Block_Dataview struct {
	Dataview *Model_Block_Content_Dataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type Model_Block_Text struct {
	Text *Model_Block_Content_Text `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type Model_Block_Media struct {
	Media *Model_Block_Content_Media `protobuf:"bytes,15,opt,name=media,proto3,oneof" json:"media,omitempty"`
}
type Model_Block_Layout struct {
	Layout *Model_Block_Content_Layout `protobuf:"bytes,16,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type Model_Block_Div struct {
	Div *Model_Block_Content_Div `protobuf:"bytes,17,opt,name=div,proto3,oneof" json:"div,omitempty"`
}

func (*Model_Block_Dashboard) isModel_Block_Content() {}
func (*Model_Block_Page) isModel_Block_Content()      {}
func (*Model_Block_Dataview) isModel_Block_Content()  {}
func (*Model_Block_Text) isModel_Block_Content()      {}
func (*Model_Block_Media) isModel_Block_Content()     {}
func (*Model_Block_Layout) isModel_Block_Content()    {}
func (*Model_Block_Div) isModel_Block_Content()       {}

func (m *Model_Block) GetContent() isModel_Block_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Model_Block) GetHeader() *Model_Block_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Model_Block) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Model_Block) GetDashboard() *Model_Block_Content_Dashboard {
	if x, ok := m.GetContent().(*Model_Block_Dashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *Model_Block) GetPage() *Model_Block_Content_Page {
	if x, ok := m.GetContent().(*Model_Block_Page); ok {
		return x.Page
	}
	return nil
}

func (m *Model_Block) GetDataview() *Model_Block_Content_Dataview {
	if x, ok := m.GetContent().(*Model_Block_Dataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *Model_Block) GetText() *Model_Block_Content_Text {
	if x, ok := m.GetContent().(*Model_Block_Text); ok {
		return x.Text
	}
	return nil
}

func (m *Model_Block) GetMedia() *Model_Block_Content_Media {
	if x, ok := m.GetContent().(*Model_Block_Media); ok {
		return x.Media
	}
	return nil
}

func (m *Model_Block) GetLayout() *Model_Block_Content_Layout {
	if x, ok := m.GetContent().(*Model_Block_Layout); ok {
		return x.Layout
	}
	return nil
}

func (m *Model_Block) GetDiv() *Model_Block_Content_Div {
	if x, ok := m.GetContent().(*Model_Block_Div); ok {
		return x.Div
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Block) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Block_Dashboard)(nil),
		(*Model_Block_Page)(nil),
		(*Model_Block_Dataview)(nil),
		(*Model_Block_Text)(nil),
		(*Model_Block_Media)(nil),
		(*Model_Block_Layout)(nil),
		(*Model_Block_Div)(nil),
	}
}

type Model_Block_Header struct {
	Id          string                          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        Model_Block_Header_Type         `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Model_Block_Header_Type" json:"type,omitempty"`
	Fields      *Model_Struct                   `protobuf:"bytes,3,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *Model_Block_Header_Permissions `protobuf:"bytes,4,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Model_Block_Header) Reset()         { *m = Model_Block_Header{} }
func (m *Model_Block_Header) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Header) ProtoMessage()    {}
func (*Model_Block_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0}
}
func (m *Model_Block_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Header.Merge(m, src)
}
func (m *Model_Block_Header) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Header proto.InternalMessageInfo

func (m *Model_Block_Header) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model_Block_Header) GetType() Model_Block_Header_Type {
	if m != nil {
		return m.Type
	}
	return Model_Block_Header_DASHBOARD
}

func (m *Model_Block_Header) GetFields() *Model_Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Model_Block_Header) GetPermissions() *Model_Block_Header_Permissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type Model_Block_Header_Permissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *Model_Block_Header_Permissions) Reset()         { *m = Model_Block_Header_Permissions{} }
func (m *Model_Block_Header_Permissions) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Header_Permissions) ProtoMessage()    {}
func (*Model_Block_Header_Permissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0, 0}
}
func (m *Model_Block_Header_Permissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Header_Permissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Header_Permissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Header_Permissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Header_Permissions.Merge(m, src)
}
func (m *Model_Block_Header_Permissions) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Header_Permissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Header_Permissions.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Header_Permissions proto.InternalMessageInfo

func (m *Model_Block_Header_Permissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type Model_Block_Content struct {
}

func (m *Model_Block_Content) Reset()         { *m = Model_Block_Content{} }
func (m *Model_Block_Content) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content) ProtoMessage()    {}
func (*Model_Block_Content) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1}
}
func (m *Model_Block_Content) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content.Merge(m, src)
}
func (m *Model_Block_Content) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content proto.InternalMessageInfo

type Model_Block_Content_Layout struct {
	Style Model_Block_Content_Layout_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_Content_Layout_Style" json:"style,omitempty"`
}

func (m *Model_Block_Content_Layout) Reset()         { *m = Model_Block_Content_Layout{} }
func (m *Model_Block_Content_Layout) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Layout) ProtoMessage()    {}
func (*Model_Block_Content_Layout) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 0}
}
func (m *Model_Block_Content_Layout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Layout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Layout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Layout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Layout.Merge(m, src)
}
func (m *Model_Block_Content_Layout) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Layout) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Layout.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Layout proto.InternalMessageInfo

func (m *Model_Block_Content_Layout) GetStyle() Model_Block_Content_Layout_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_Content_Layout_ROW
}

type Model_Block_Content_Div struct {
}

func (m *Model_Block_Content_Div) Reset()         { *m = Model_Block_Content_Div{} }
func (m *Model_Block_Content_Div) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Div) ProtoMessage()    {}
func (*Model_Block_Content_Div) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 1}
}
func (m *Model_Block_Content_Div) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Div) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Div.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Div) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Div.Merge(m, src)
}
func (m *Model_Block_Content_Div) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Div) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Div.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Div proto.InternalMessageInfo

type Model_Block_Content_Dashboard struct {
	Style   Model_Block_Content_Dashboard_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_Content_Dashboard_Style" json:"style,omitempty"`
	Headers []*Model_Block_Header               `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *Model_Block_Content_Dashboard) Reset()         { *m = Model_Block_Content_Dashboard{} }
func (m *Model_Block_Content_Dashboard) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Dashboard) ProtoMessage()    {}
func (*Model_Block_Content_Dashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 2}
}
func (m *Model_Block_Content_Dashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Dashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Dashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Dashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Dashboard.Merge(m, src)
}
func (m *Model_Block_Content_Dashboard) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Dashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Dashboard.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Dashboard proto.InternalMessageInfo

func (m *Model_Block_Content_Dashboard) GetStyle() Model_Block_Content_Dashboard_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_Content_Dashboard_MAIN_SCREEN
}

func (m *Model_Block_Content_Dashboard) GetHeaders() []*Model_Block_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

type Model_Block_Content_Dataview struct {
}

func (m *Model_Block_Content_Dataview) Reset()         { *m = Model_Block_Content_Dataview{} }
func (m *Model_Block_Content_Dataview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Dataview) ProtoMessage()    {}
func (*Model_Block_Content_Dataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 3}
}
func (m *Model_Block_Content_Dataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Dataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Dataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Dataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Dataview.Merge(m, src)
}
func (m *Model_Block_Content_Dataview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Dataview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Dataview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Dataview proto.InternalMessageInfo

type Model_Block_Content_Text struct {
	Text       string                              `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      Model_Block_Content_Text_Style      `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.Model_Block_Content_Text_Style" json:"style,omitempty"`
	MarksList  *Model_Block_Content_Text_Marks     `protobuf:"bytes,3,opt,name=marksList,proto3" json:"marksList,omitempty"`
	Toggleable bool                                `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	MarkerType Model_Block_Content_Text_MarkerType `protobuf:"varint,5,opt,name=markerType,proto3,enum=anytype.Model_Block_Content_Text_MarkerType" json:"markerType,omitempty"`
	Checkable  bool                                `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                                `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *Model_Block_Content_Text) Reset()         { *m = Model_Block_Content_Text{} }
func (m *Model_Block_Content_Text) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Text) ProtoMessage()    {}
func (*Model_Block_Content_Text) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4}
}
func (m *Model_Block_Content_Text) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Text) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Text.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Text) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Text.Merge(m, src)
}
func (m *Model_Block_Content_Text) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Text) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Text.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Text proto.InternalMessageInfo

func (m *Model_Block_Content_Text) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Model_Block_Content_Text) GetStyle() Model_Block_Content_Text_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_Content_Text_p
}

func (m *Model_Block_Content_Text) GetMarksList() *Model_Block_Content_Text_Marks {
	if m != nil {
		return m.MarksList
	}
	return nil
}

func (m *Model_Block_Content_Text) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *Model_Block_Content_Text) GetMarkerType() Model_Block_Content_Text_MarkerType {
	if m != nil {
		return m.MarkerType
	}
	return Model_Block_Content_Text_none
}

func (m *Model_Block_Content_Text) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *Model_Block_Content_Text) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type Model_Block_Content_Text_Marks struct {
	Marks []*Model_Block_Content_Text_Mark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *Model_Block_Content_Text_Marks) Reset()         { *m = Model_Block_Content_Text_Marks{} }
func (m *Model_Block_Content_Text_Marks) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Text_Marks) ProtoMessage()    {}
func (*Model_Block_Content_Text_Marks) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4, 0}
}
func (m *Model_Block_Content_Text_Marks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Text_Marks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Text_Marks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Text_Marks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Text_Marks.Merge(m, src)
}
func (m *Model_Block_Content_Text_Marks) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Text_Marks) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Text_Marks.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Text_Marks proto.InternalMessageInfo

func (m *Model_Block_Content_Text_Marks) GetMarks() []*Model_Block_Content_Text_Mark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type Model_Block_Content_Text_Mark struct {
	Range *Model_Range                       `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  Model_Block_Content_Text_Mark_Type `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Model_Block_Content_Text_Mark_Type" json:"type,omitempty"`
	Param string                             `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *Model_Block_Content_Text_Mark) Reset()         { *m = Model_Block_Content_Text_Mark{} }
func (m *Model_Block_Content_Text_Mark) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Text_Mark) ProtoMessage()    {}
func (*Model_Block_Content_Text_Mark) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 4, 1}
}
func (m *Model_Block_Content_Text_Mark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Text_Mark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Text_Mark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Text_Mark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Text_Mark.Merge(m, src)
}
func (m *Model_Block_Content_Text_Mark) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Text_Mark) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Text_Mark.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Text_Mark proto.InternalMessageInfo

func (m *Model_Block_Content_Text_Mark) GetRange() *Model_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Model_Block_Content_Text_Mark) GetType() Model_Block_Content_Text_Mark_Type {
	if m != nil {
		return m.Type
	}
	return Model_Block_Content_Text_Mark_STRIKETHROUGH
}

func (m *Model_Block_Content_Text_Mark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type Model_Block_Content_Media struct {
	Content []byte                          `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	State   Model_Block_Content_Media_State `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.Model_Block_Content_Media_State" json:"state,omitempty"`
	// Types that are valid to be assigned to Preview:
	//	*Model_Block_Content_Media_Video
	//	*Model_Block_Content_Media_Image
	//	*Model_Block_Content_Media_File
	Preview isModel_Block_Content_Media_Preview `protobuf_oneof:"preview"`
}

func (m *Model_Block_Content_Media) Reset()         { *m = Model_Block_Content_Media{} }
func (m *Model_Block_Content_Media) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Media) ProtoMessage()    {}
func (*Model_Block_Content_Media) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5}
}
func (m *Model_Block_Content_Media) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Media) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Media.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Media) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Media.Merge(m, src)
}
func (m *Model_Block_Content_Media) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Media) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Media.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Media proto.InternalMessageInfo

type isModel_Block_Content_Media_Preview interface {
	isModel_Block_Content_Media_Preview()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Block_Content_Media_Video struct {
	Video *Model_Block_Content_Media_VideoPreview `protobuf:"bytes,101,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type Model_Block_Content_Media_Image struct {
	Image *Model_Block_Content_Media_ImagePreview `protobuf:"bytes,102,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type Model_Block_Content_Media_File struct {
	File *Model_Block_Content_Media_FilePreview `protobuf:"bytes,103,opt,name=file,proto3,oneof" json:"file,omitempty"`
}

func (*Model_Block_Content_Media_Video) isModel_Block_Content_Media_Preview() {}
func (*Model_Block_Content_Media_Image) isModel_Block_Content_Media_Preview() {}
func (*Model_Block_Content_Media_File) isModel_Block_Content_Media_Preview()  {}

func (m *Model_Block_Content_Media) GetPreview() isModel_Block_Content_Media_Preview {
	if m != nil {
		return m.Preview
	}
	return nil
}

func (m *Model_Block_Content_Media) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Model_Block_Content_Media) GetState() Model_Block_Content_Media_State {
	if m != nil {
		return m.State
	}
	return Model_Block_Content_Media_EMPTY
}

func (m *Model_Block_Content_Media) GetVideo() *Model_Block_Content_Media_VideoPreview {
	if x, ok := m.GetPreview().(*Model_Block_Content_Media_Video); ok {
		return x.Video
	}
	return nil
}

func (m *Model_Block_Content_Media) GetImage() *Model_Block_Content_Media_ImagePreview {
	if x, ok := m.GetPreview().(*Model_Block_Content_Media_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Model_Block_Content_Media) GetFile() *Model_Block_Content_Media_FilePreview {
	if x, ok := m.GetPreview().(*Model_Block_Content_Media_File); ok {
		return x.File
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Block_Content_Media) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Block_Content_Media_Video)(nil),
		(*Model_Block_Content_Media_Image)(nil),
		(*Model_Block_Content_Media_File)(nil),
	}
}

type Model_Block_Content_Media_VideoPreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Model_Block_Content_Media_VideoPreview) Reset() {
	*m = Model_Block_Content_Media_VideoPreview{}
}
func (m *Model_Block_Content_Media_VideoPreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Media_VideoPreview) ProtoMessage()    {}
func (*Model_Block_Content_Media_VideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 0}
}
func (m *Model_Block_Content_Media_VideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Media_VideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Media_VideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Media_VideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Media_VideoPreview.Merge(m, src)
}
func (m *Model_Block_Content_Media_VideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Media_VideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Media_VideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Media_VideoPreview proto.InternalMessageInfo

func (m *Model_Block_Content_Media_VideoPreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Model_Block_Content_Media_VideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_Content_Media_VideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Model_Block_Content_Media_ImagePreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Model_Block_Content_Media_ImagePreview) Reset() {
	*m = Model_Block_Content_Media_ImagePreview{}
}
func (m *Model_Block_Content_Media_ImagePreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Media_ImagePreview) ProtoMessage()    {}
func (*Model_Block_Content_Media_ImagePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 1}
}
func (m *Model_Block_Content_Media_ImagePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Media_ImagePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Media_ImagePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Media_ImagePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Media_ImagePreview.Merge(m, src)
}
func (m *Model_Block_Content_Media_ImagePreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Media_ImagePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Media_ImagePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Media_ImagePreview proto.InternalMessageInfo

func (m *Model_Block_Content_Media_ImagePreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Model_Block_Content_Media_ImagePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_Content_Media_ImagePreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Model_Block_Content_Media_FilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *Model_Block_Content_Media_FilePreview) Reset()         { *m = Model_Block_Content_Media_FilePreview{} }
func (m *Model_Block_Content_Media_FilePreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Media_FilePreview) ProtoMessage()    {}
func (*Model_Block_Content_Media_FilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 5, 2}
}
func (m *Model_Block_Content_Media_FilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Media_FilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Media_FilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Media_FilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Media_FilePreview.Merge(m, src)
}
func (m *Model_Block_Content_Media_FilePreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Media_FilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Media_FilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Media_FilePreview proto.InternalMessageInfo

func (m *Model_Block_Content_Media_FilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_Content_Media_FilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type Model_Block_Content_Page struct {
	Style Model_Block_Content_Page_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_Content_Page_Style" json:"style,omitempty"`
}

func (m *Model_Block_Content_Page) Reset()         { *m = Model_Block_Content_Page{} }
func (m *Model_Block_Content_Page) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Content_Page) ProtoMessage()    {}
func (*Model_Block_Content_Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 6}
}
func (m *Model_Block_Content_Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Content_Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Content_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Content_Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Content_Page.Merge(m, src)
}
func (m *Model_Block_Content_Page) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Content_Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Content_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Content_Page proto.InternalMessageInfo

func (m *Model_Block_Content_Page) GetStyle() Model_Block_Content_Page_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_Content_Page_EMPTY
}

type Model_Range struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *Model_Range) Reset()         { *m = Model_Range{} }
func (m *Model_Range) String() string { return proto.CompactTextString(m) }
func (*Model_Range) ProtoMessage()    {}
func (*Model_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 1}
}
func (m *Model_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Range.Merge(m, src)
}
func (m *Model_Range) XXX_Size() int {
	return m.Size()
}
func (m *Model_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Range proto.InternalMessageInfo

func (m *Model_Range) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Model_Range) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

type Model_Struct struct {
	// Unordered map of dynamically typed values.
	Fields map[string]*Model_Struct_Value `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Model_Struct) Reset()         { *m = Model_Struct{} }
func (m *Model_Struct) String() string { return proto.CompactTextString(m) }
func (*Model_Struct) ProtoMessage()    {}
func (*Model_Struct) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2}
}
func (m *Model_Struct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Struct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Struct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Struct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Struct.Merge(m, src)
}
func (m *Model_Struct) XXX_Size() int {
	return m.Size()
}
func (m *Model_Struct) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Struct.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Struct proto.InternalMessageInfo

func (m *Model_Struct) GetFields() map[string]*Model_Struct_Value {
	if m != nil {
		return m.Fields
	}
	return nil
}

// `Value` represents a dynamically typed value which can be either
// null, a number, a string, a boolean, a recursive struct value, or a
// list of values. A producer of value is expected to set one of that
// variants, absence of any variant indicates an error.
type Model_Struct_Value struct {
	// Types that are valid to be assigned to Kind:
	//	*Model_Struct_Value_NullValue
	//	*Model_Struct_Value_NumberValue
	//	*Model_Struct_Value_StringValue
	//	*Model_Struct_Value_BoolValue
	//	*Model_Struct_Value_StructValue
	//	*Model_Struct_Value_ListValue
	Kind isModel_Struct_Value_Kind `protobuf_oneof:"kind"`
}

func (m *Model_Struct_Value) Reset()         { *m = Model_Struct_Value{} }
func (m *Model_Struct_Value) String() string { return proto.CompactTextString(m) }
func (*Model_Struct_Value) ProtoMessage()    {}
func (*Model_Struct_Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2, 1}
}
func (m *Model_Struct_Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Struct_Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Struct_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Struct_Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Struct_Value.Merge(m, src)
}
func (m *Model_Struct_Value) XXX_Size() int {
	return m.Size()
}
func (m *Model_Struct_Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Struct_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Struct_Value proto.InternalMessageInfo

type isModel_Struct_Value_Kind interface {
	isModel_Struct_Value_Kind()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Struct_Value_NullValue struct {
	NullValue Model_Struct_NullValue `protobuf:"varint,1,opt,name=null_value,json=nullValue,proto3,enum=anytype.Model_Struct_NullValue,oneof" json:"null_value,omitempty"`
}
type Model_Struct_Value_NumberValue struct {
	NumberValue float64 `protobuf:"fixed64,2,opt,name=number_value,json=numberValue,proto3,oneof" json:"number_value,omitempty"`
}
type Model_Struct_Value_StringValue struct {
	StringValue string `protobuf:"bytes,3,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}
type Model_Struct_Value_BoolValue struct {
	BoolValue bool `protobuf:"varint,4,opt,name=bool_value,json=boolValue,proto3,oneof" json:"bool_value,omitempty"`
}
type Model_Struct_Value_StructValue struct {
	StructValue *Model_Struct `protobuf:"bytes,5,opt,name=struct_value,json=structValue,proto3,oneof" json:"struct_value,omitempty"`
}
type Model_Struct_Value_ListValue struct {
	ListValue *Model_Struct_ListValue `protobuf:"bytes,6,opt,name=list_value,json=listValue,proto3,oneof" json:"list_value,omitempty"`
}

func (*Model_Struct_Value_NullValue) isModel_Struct_Value_Kind()   {}
func (*Model_Struct_Value_NumberValue) isModel_Struct_Value_Kind() {}
func (*Model_Struct_Value_StringValue) isModel_Struct_Value_Kind() {}
func (*Model_Struct_Value_BoolValue) isModel_Struct_Value_Kind()   {}
func (*Model_Struct_Value_StructValue) isModel_Struct_Value_Kind() {}
func (*Model_Struct_Value_ListValue) isModel_Struct_Value_Kind()   {}

func (m *Model_Struct_Value) GetKind() isModel_Struct_Value_Kind {
	if m != nil {
		return m.Kind
	}
	return nil
}

func (m *Model_Struct_Value) GetNullValue() Model_Struct_NullValue {
	if x, ok := m.GetKind().(*Model_Struct_Value_NullValue); ok {
		return x.NullValue
	}
	return Model_Struct_NULL_VALUE
}

func (m *Model_Struct_Value) GetNumberValue() float64 {
	if x, ok := m.GetKind().(*Model_Struct_Value_NumberValue); ok {
		return x.NumberValue
	}
	return 0
}

func (m *Model_Struct_Value) GetStringValue() string {
	if x, ok := m.GetKind().(*Model_Struct_Value_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *Model_Struct_Value) GetBoolValue() bool {
	if x, ok := m.GetKind().(*Model_Struct_Value_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *Model_Struct_Value) GetStructValue() *Model_Struct {
	if x, ok := m.GetKind().(*Model_Struct_Value_StructValue); ok {
		return x.StructValue
	}
	return nil
}

func (m *Model_Struct_Value) GetListValue() *Model_Struct_ListValue {
	if x, ok := m.GetKind().(*Model_Struct_Value_ListValue); ok {
		return x.ListValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Struct_Value) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Struct_Value_NullValue)(nil),
		(*Model_Struct_Value_NumberValue)(nil),
		(*Model_Struct_Value_StringValue)(nil),
		(*Model_Struct_Value_BoolValue)(nil),
		(*Model_Struct_Value_StructValue)(nil),
		(*Model_Struct_Value_ListValue)(nil),
	}
}

// `ListValue` is a wrapper around a repeated field of values.
type Model_Struct_ListValue struct {
	Values []*Model_Struct_Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *Model_Struct_ListValue) Reset()         { *m = Model_Struct_ListValue{} }
func (m *Model_Struct_ListValue) String() string { return proto.CompactTextString(m) }
func (*Model_Struct_ListValue) ProtoMessage()    {}
func (*Model_Struct_ListValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 2, 2}
}
func (m *Model_Struct_ListValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Struct_ListValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Struct_ListValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Struct_ListValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Struct_ListValue.Merge(m, src)
}
func (m *Model_Struct_ListValue) XXX_Size() int {
	return m.Size()
}
func (m *Model_Struct_ListValue) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Struct_ListValue.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Struct_ListValue proto.InternalMessageInfo

func (m *Model_Struct_ListValue) GetValues() []*Model_Struct_Value {
	if m != nil {
		return m.Values
	}
	return nil
}

//*
// Contains basic information about user account
type Model_Account struct {
	Id     string                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string                `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Avatar *Model_Account_Avatar `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *Model_Account) Reset()         { *m = Model_Account{} }
func (m *Model_Account) String() string { return proto.CompactTextString(m) }
func (*Model_Account) ProtoMessage()    {}
func (*Model_Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 3}
}
func (m *Model_Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Account.Merge(m, src)
}
func (m *Model_Account) XXX_Size() int {
	return m.Size()
}
func (m *Model_Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Account proto.InternalMessageInfo

func (m *Model_Account) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model_Account) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Account) GetAvatar() *Model_Account_Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

//*
// Avatar of a user's account. It could be an image or color
type Model_Account_Avatar struct {
	// Types that are valid to be assigned to Avatar:
	//	*Model_Account_Avatar_Image
	//	*Model_Account_Avatar_Color
	Avatar isModel_Account_Avatar_Avatar `protobuf_oneof:"avatar"`
}

func (m *Model_Account_Avatar) Reset()         { *m = Model_Account_Avatar{} }
func (m *Model_Account_Avatar) String() string { return proto.CompactTextString(m) }
func (*Model_Account_Avatar) ProtoMessage()    {}
func (*Model_Account_Avatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 3, 0}
}
func (m *Model_Account_Avatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Account_Avatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Account_Avatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Account_Avatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Account_Avatar.Merge(m, src)
}
func (m *Model_Account_Avatar) XXX_Size() int {
	return m.Size()
}
func (m *Model_Account_Avatar) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Account_Avatar.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Account_Avatar proto.InternalMessageInfo

type isModel_Account_Avatar_Avatar interface {
	isModel_Account_Avatar_Avatar()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Account_Avatar_Image struct {
	Image *Model_Image `protobuf:"bytes,1,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type Model_Account_Avatar_Color struct {
	Color string `protobuf:"bytes,2,opt,name=color,proto3,oneof" json:"color,omitempty"`
}

func (*Model_Account_Avatar_Image) isModel_Account_Avatar_Avatar() {}
func (*Model_Account_Avatar_Color) isModel_Account_Avatar_Avatar() {}

func (m *Model_Account_Avatar) GetAvatar() isModel_Account_Avatar_Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *Model_Account_Avatar) GetImage() *Model_Image {
	if x, ok := m.GetAvatar().(*Model_Account_Avatar_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Model_Account_Avatar) GetColor() string {
	if x, ok := m.GetAvatar().(*Model_Account_Avatar_Color); ok {
		return x.Color
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Account_Avatar) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Account_Avatar_Image)(nil),
		(*Model_Account_Avatar_Color)(nil),
	}
}

type Model_Image struct {
	Id    string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []Model_Image_Size `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.Model_Image_Size" json:"sizes,omitempty"`
}

func (m *Model_Image) Reset()         { *m = Model_Image{} }
func (m *Model_Image) String() string { return proto.CompactTextString(m) }
func (*Model_Image) ProtoMessage()    {}
func (*Model_Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 4}
}
func (m *Model_Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Image.Merge(m, src)
}
func (m *Model_Image) XXX_Size() int {
	return m.Size()
}
func (m *Model_Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Image proto.InternalMessageInfo

func (m *Model_Image) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model_Image) GetSizes() []Model_Image_Size {
	if m != nil {
		return m.Sizes
	}
	return nil
}

type Model_Video struct {
	Id    string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []Model_Video_Size `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.Model_Video_Size" json:"sizes,omitempty"`
}

func (m *Model_Video) Reset()         { *m = Model_Video{} }
func (m *Model_Video) String() string { return proto.CompactTextString(m) }
func (*Model_Video) ProtoMessage()    {}
func (*Model_Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 5}
}
func (m *Model_Video) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Video.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Video.Merge(m, src)
}
func (m *Model_Video) XXX_Size() int {
	return m.Size()
}
func (m *Model_Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Video proto.InternalMessageInfo

func (m *Model_Video) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model_Video) GetSizes() []Model_Video_Size {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func init() {
	proto.RegisterEnum("anytype.Model_Block_Header_Type", Model_Block_Header_Type_name, Model_Block_Header_Type_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Layout_Style", Model_Block_Content_Layout_Style_name, Model_Block_Content_Layout_Style_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Dashboard_Style", Model_Block_Content_Dashboard_Style_name, Model_Block_Content_Dashboard_Style_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Text_Style", Model_Block_Content_Text_Style_name, Model_Block_Content_Text_Style_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Text_MarkerType", Model_Block_Content_Text_MarkerType_name, Model_Block_Content_Text_MarkerType_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Text_Mark_Type", Model_Block_Content_Text_Mark_Type_name, Model_Block_Content_Text_Mark_Type_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Media_State", Model_Block_Content_Media_State_name, Model_Block_Content_Media_State_value)
	proto.RegisterEnum("anytype.Model_Block_Content_Page_Style", Model_Block_Content_Page_Style_name, Model_Block_Content_Page_Style_value)
	proto.RegisterEnum("anytype.Model_Struct_NullValue", Model_Struct_NullValue_name, Model_Struct_NullValue_value)
	proto.RegisterEnum("anytype.Model_Image_Size", Model_Image_Size_name, Model_Image_Size_value)
	proto.RegisterEnum("anytype.Model_Video_Size", Model_Video_Size_name, Model_Video_Size_value)
	proto.RegisterType((*Model)(nil), "anytype.Model")
	proto.RegisterType((*Model_Block)(nil), "anytype.Model.Block")
	proto.RegisterType((*Model_Block_Header)(nil), "anytype.Model.Block.Header")
	proto.RegisterType((*Model_Block_Header_Permissions)(nil), "anytype.Model.Block.Header.Permissions")
	proto.RegisterType((*Model_Block_Content)(nil), "anytype.Model.Block.Content")
	proto.RegisterType((*Model_Block_Content_Layout)(nil), "anytype.Model.Block.Content.Layout")
	proto.RegisterType((*Model_Block_Content_Div)(nil), "anytype.Model.Block.Content.Div")
	proto.RegisterType((*Model_Block_Content_Dashboard)(nil), "anytype.Model.Block.Content.Dashboard")
	proto.RegisterType((*Model_Block_Content_Dataview)(nil), "anytype.Model.Block.Content.Dataview")
	proto.RegisterType((*Model_Block_Content_Text)(nil), "anytype.Model.Block.Content.Text")
	proto.RegisterType((*Model_Block_Content_Text_Marks)(nil), "anytype.Model.Block.Content.Text.Marks")
	proto.RegisterType((*Model_Block_Content_Text_Mark)(nil), "anytype.Model.Block.Content.Text.Mark")
	proto.RegisterType((*Model_Block_Content_Media)(nil), "anytype.Model.Block.Content.Media")
	proto.RegisterType((*Model_Block_Content_Media_VideoPreview)(nil), "anytype.Model.Block.Content.Media.VideoPreview")
	proto.RegisterType((*Model_Block_Content_Media_ImagePreview)(nil), "anytype.Model.Block.Content.Media.ImagePreview")
	proto.RegisterType((*Model_Block_Content_Media_FilePreview)(nil), "anytype.Model.Block.Content.Media.FilePreview")
	proto.RegisterType((*Model_Block_Content_Page)(nil), "anytype.Model.Block.Content.Page")
	proto.RegisterType((*Model_Range)(nil), "anytype.Model.Range")
	proto.RegisterType((*Model_Struct)(nil), "anytype.Model.Struct")
	proto.RegisterMapType((map[string]*Model_Struct_Value)(nil), "anytype.Model.Struct.FieldsEntry")
	proto.RegisterType((*Model_Struct_Value)(nil), "anytype.Model.Struct.Value")
	proto.RegisterType((*Model_Struct_ListValue)(nil), "anytype.Model.Struct.ListValue")
	proto.RegisterType((*Model_Account)(nil), "anytype.Model.Account")
	proto.RegisterType((*Model_Account_Avatar)(nil), "anytype.Model.Account.Avatar")
	proto.RegisterType((*Model_Image)(nil), "anytype.Model.Image")
	proto.RegisterType((*Model_Video)(nil), "anytype.Model.Video")
}

func init() { proto.RegisterFile("models.proto", fileDescriptor_0b5431a010549573) }

var fileDescriptor_0b5431a010549573 = []byte{
	// 1675 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xdf, 0x25, 0x77, 0xf9, 0xe7, 0x51, 0x96, 0x27, 0x83, 0x24, 0xd8, 0x6e, 0x5c, 0xc5, 0x61,
	0xd0, 0xd8, 0x6d, 0x52, 0x46, 0x96, 0xe4, 0x26, 0x35, 0x9a, 0x26, 0xa4, 0xb8, 0x16, 0x09, 0x51,
	0xa2, 0x30, 0xa4, 0xe4, 0xb8, 0x17, 0x61, 0xc5, 0x1d, 0x53, 0x0b, 0x2d, 0x77, 0x99, 0xe5, 0x52,
	0x89, 0x8c, 0x7e, 0x88, 0x7e, 0x80, 0x1e, 0x0a, 0xf4, 0x43, 0x14, 0xe8, 0xa1, 0x40, 0x6f, 0x3d,
	0xa6, 0xbd, 0xb4, 0xc7, 0xc2, 0xfe, 0x0e, 0xed, 0xb5, 0x78, 0x6f, 0x76, 0x49, 0xca, 0x96, 0x25,
	0x16, 0xc8, 0x89, 0xf3, 0x66, 0x7f, 0xbf, 0xf7, 0xde, 0xcc, 0xfb, 0x37, 0x84, 0x95, 0x51, 0xe4,
	0xc9, 0x60, 0x52, 0x1b, 0xc7, 0x51, 0x12, 0xf1, 0xa2, 0x1b, 0x5e, 0x24, 0x17, 0x63, 0x59, 0xfd,
	0xfd, 0x1a, 0x98, 0x7b, 0xf8, 0xc5, 0xfe, 0xfb, 0x3b, 0x60, 0x36, 0x82, 0x68, 0x70, 0xc6, 0x37,
	0xa1, 0x70, 0x2a, 0x5d, 0x4f, 0xc6, 0x96, 0x7e, 0x57, 0xbf, 0x5f, 0xd9, 0x78, 0xaf, 0x96, 0xa2,
	0x6b, 0x84, 0xac, 0x11, 0xaa, 0xd6, 0x22, 0x88, 0x48, 0xa1, 0xdc, 0x86, 0xd2, 0xe0, 0xd4, 0x0f,
	0xbc, 0x58, 0x86, 0x56, 0xee, 0x6e, 0xfe, 0x7e, 0x59, 0xcc, 0x64, 0xfe, 0x18, 0xca, 0x9e, 0x3b,
	0x39, 0x3d, 0x89, 0xdc, 0xd8, 0xb3, 0x2a, 0xa4, 0xf3, 0xa3, 0x2b, 0x75, 0x6e, 0x47, 0x61, 0x22,
	0xc3, 0xa4, 0xd6, 0xcc, 0xd0, 0x2d, 0x4d, 0xcc, 0xa9, 0xfc, 0x33, 0x30, 0xc6, 0xee, 0x50, 0x5a,
	0x2b, 0xa4, 0xe2, 0x83, 0x6b, 0x55, 0x1c, 0xb8, 0x43, 0xd9, 0xd2, 0x04, 0x11, 0xf8, 0x36, 0x94,
	0x3c, 0x37, 0x71, 0xcf, 0x7d, 0xf9, 0xad, 0x75, 0x8b, 0xc8, 0x3f, 0xb9, 0xc1, 0xbe, 0x02, 0xb7,
	0x34, 0x31, 0x23, 0xa2, 0xf5, 0x44, 0x7e, 0x97, 0x58, 0xab, 0x4b, 0x58, 0xef, 0xcb, 0xef, 0x12,
	0xb4, 0x8e, 0x04, 0xfe, 0x08, 0xcc, 0x91, 0xf4, 0x7c, 0xd7, 0xba, 0x4d, 0xcc, 0xea, 0xb5, 0xcc,
	0x3d, 0x44, 0xb6, 0x34, 0xa1, 0x28, 0xfc, 0x0b, 0x28, 0x04, 0xee, 0x45, 0x34, 0x4d, 0x2c, 0x46,
	0xe4, 0x0f, 0xaf, 0x25, 0x77, 0x08, 0xda, 0xd2, 0x44, 0x4a, 0xe2, 0x5b, 0x90, 0xf7, 0xfc, 0x73,
	0xeb, 0x2d, 0xe2, 0xde, 0xbd, 0xfe, 0xcc, 0xfe, 0x79, 0x4b, 0x13, 0x08, 0xb7, 0xff, 0x9a, 0x87,
	0x82, 0x0a, 0x2f, 0x5f, 0x85, 0x9c, 0xef, 0x51, 0x1e, 0x94, 0x45, 0xce, 0xf7, 0xf8, 0x16, 0x18,
	0xa8, 0xc1, 0xca, 0xdd, 0xd5, 0xef, 0xaf, 0xbe, 0x41, 0xa3, 0xa2, 0xd6, 0xfa, 0x17, 0x63, 0x29,
	0x08, 0xcd, 0x7f, 0x0e, 0x85, 0x67, 0xbe, 0x0c, 0xbc, 0x89, 0x95, 0x27, 0x4f, 0xde, 0x79, 0x85,
	0xd7, 0x4b, 0xe2, 0xe9, 0x20, 0x11, 0x29, 0x88, 0xb7, 0xa1, 0x32, 0x96, 0xf1, 0xc8, 0x9f, 0x4c,
	0xfc, 0x28, 0x9c, 0x58, 0x06, 0x71, 0xee, 0x5d, 0x67, 0xeb, 0x60, 0x0e, 0x17, 0x8b, 0x5c, 0xfb,
	0x02, 0x2a, 0x0b, 0xdf, 0x38, 0x07, 0x23, 0x96, 0xae, 0x3a, 0x50, 0x49, 0xd0, 0x1a, 0xf7, 0xa4,
	0xe7, 0x27, 0x74, 0xa4, 0x92, 0xa0, 0x35, 0x7f, 0x17, 0x0a, 0xb1, 0x1c, 0x45, 0xe7, 0x92, 0x1c,
	0x2e, 0x89, 0x54, 0x42, 0xac, 0x17, 0xbb, 0x43, 0x72, 0xa9, 0x24, 0x68, 0x8d, 0x58, 0x2f, 0x8e,
	0xc6, 0xdd, 0xd0, 0x32, 0x15, 0x56, 0x49, 0xd5, 0xdf, 0x82, 0x81, 0x57, 0xc0, 0x6f, 0x41, 0xb9,
	0x59, 0xef, 0xb5, 0x1a, 0xdd, 0xba, 0x68, 0x32, 0x8d, 0x97, 0xc0, 0x38, 0xa8, 0xef, 0x38, 0x4c,
	0xe7, 0x2b, 0x50, 0x6a, 0xd6, 0xfb, 0xf5, 0xa3, 0xb6, 0xf3, 0x84, 0xe5, 0x70, 0xbf, 0xef, 0x7c,
	0xdd, 0x67, 0x79, 0x5c, 0x3d, 0x6e, 0x77, 0x1c, 0x66, 0xf0, 0x0a, 0x14, 0x0f, 0xda, 0xdb, 0xfd,
	0x43, 0xe1, 0x30, 0x93, 0x97, 0xc1, 0x3c, 0x6a, 0x37, 0x9d, 0x2e, 0x2b, 0x20, 0xb3, 0xd1, 0xed,
	0xee, 0xee, 0xd5, 0xc5, 0x2e, 0x2b, 0x72, 0x80, 0x42, 0xa7, 0xfe, 0xb4, 0x7b, 0xd8, 0x67, 0x25,
	0x5e, 0x84, 0x7c, 0xb3, 0x7d, 0xc4, 0xca, 0xf6, 0x7f, 0x6f, 0x41, 0x31, 0x0d, 0xad, 0x3d, 0x84,
	0x82, 0xca, 0x0c, 0xfe, 0x25, 0x98, 0x93, 0xe4, 0x22, 0x90, 0x74, 0x01, 0xab, 0x1b, 0x3f, 0x5d,
	0x22, 0x9b, 0x6a, 0x3d, 0x24, 0x08, 0xc5, 0xab, 0xde, 0x01, 0x93, 0x64, 0x34, 0x24, 0xba, 0x4f,
	0x98, 0x86, 0xd6, 0xb7, 0xbb, 0x9d, 0xc3, 0xbd, 0x7d, 0xa6, 0xdb, 0x26, 0xe4, 0x9b, 0xfe, 0xb9,
	0xfd, 0x07, 0x1d, 0xca, 0xb3, 0x12, 0xe6, 0x8d, 0xcb, 0x36, 0x3f, 0x59, 0xae, 0xf2, 0x2f, 0x99,
	0xe5, 0x0f, 0xa1, 0xa8, 0xfa, 0xcc, 0x84, 0x9a, 0xcb, 0x0d, 0x3d, 0x29, 0xc3, 0x56, 0xad, 0xcc,
	0xdb, 0xdb, 0x50, 0xd9, 0xab, 0xb7, 0xf7, 0x8f, 0x7b, 0xdb, 0xc2, 0x71, 0xf6, 0x99, 0x66, 0x03,
	0x94, 0xb2, 0x22, 0xb7, 0xff, 0x69, 0x82, 0x81, 0x05, 0x8b, 0xd1, 0xa5, 0x0a, 0x57, 0xe9, 0xae,
	0x8a, 0xf7, 0x8b, 0xcc, 0x7b, 0x95, 0xf1, 0xf7, 0x6e, 0x2c, 0xfb, 0xcb, 0x8e, 0x3b, 0x50, 0x1e,
	0xb9, 0xf1, 0xd9, 0xa4, 0xe3, 0x4f, 0x92, 0x34, 0xf9, 0x97, 0x50, 0xb1, 0x87, 0x14, 0x31, 0x67,
	0xf2, 0x35, 0x80, 0x24, 0x1a, 0x0e, 0x03, 0xe9, 0x9e, 0x04, 0x32, 0xcd, 0xbe, 0x85, 0x1d, 0xde,
	0x01, 0x40, 0xb0, 0x8c, 0x31, 0xe3, 0x28, 0x0f, 0x6f, 0xba, 0xe8, 0x99, 0x1d, 0xc5, 0x11, 0x0b,
	0x7c, 0x7e, 0x07, 0xca, 0x83, 0x53, 0x39, 0x38, 0x23, 0x63, 0x05, 0x32, 0x36, 0xdf, 0xe0, 0x16,
	0x14, 0x49, 0x90, 0x9e, 0x55, 0xa4, 0x6f, 0x99, 0x68, 0x3b, 0x60, 0x92, 0xe7, 0xfc, 0x57, 0x60,
	0x92, 0xef, 0x96, 0x4e, 0xc1, 0xfa, 0x68, 0x39, 0x4f, 0x84, 0x22, 0xd9, 0xff, 0xd0, 0xc1, 0x40,
	0x99, 0xff, 0x0c, 0xcc, 0xd8, 0x0d, 0x87, 0x32, 0x9d, 0x43, 0x6f, 0xbf, 0xa2, 0x46, 0xe0, 0x37,
	0xa1, 0x20, 0xfc, 0xcb, 0x4b, 0x8d, 0xe9, 0xe3, 0xe5, 0x2c, 0x2e, 0xf6, 0xa8, 0xb7, 0xc1, 0x1c,
	0xbb, 0xb1, 0x3b, 0xa2, 0x28, 0x95, 0x85, 0x12, 0xaa, 0x3b, 0x69, 0x11, 0xbf, 0x05, 0xb7, 0x7a,
	0x7d, 0xd1, 0xde, 0x75, 0xfa, 0x2d, 0xd1, 0x3d, 0xdc, 0x69, 0x31, 0x0d, 0x8b, 0x70, 0xd7, 0x79,
	0xaa, 0xca, 0x5a, 0xc7, 0x32, 0x68, 0xf7, 0xeb, 0x9d, 0xf6, 0xb6, 0x2a, 0xe5, 0x46, 0xb7, 0xd3,
	0x54, 0xa5, 0xdc, 0x69, 0xef, 0xef, 0x32, 0xa3, 0xba, 0x9d, 0xa5, 0xa2, 0x09, 0xfa, 0x98, 0x69,
	0xbc, 0x00, 0xb9, 0xd3, 0x07, 0x4c, 0xa7, 0xdf, 0x0d, 0x96, 0xa3, 0xdf, 0x4d, 0x96, 0xa7, 0xdf,
	0x2d, 0x66, 0x60, 0xb5, 0x7f, 0x33, 0x8d, 0x12, 0xc9, 0x4c, 0x54, 0x32, 0x88, 0x3c, 0xc9, 0x0a,
	0xd5, 0x1a, 0xc0, 0x3c, 0x64, 0xb8, 0x1f, 0x46, 0xa1, 0x54, 0x35, 0x18, 0x4e, 0x47, 0x27, 0x32,
	0x56, 0x8e, 0x9c, 0x4c, 0x83, 0x40, 0x26, 0x2c, 0x67, 0xff, 0xc7, 0x00, 0x93, 0x06, 0x0a, 0x05,
	0x4d, 0x9d, 0x9e, 0x2e, 0x73, 0x45, 0x64, 0x22, 0xff, 0x35, 0x26, 0xb8, 0x9b, 0x64, 0x37, 0x77,
	0xff, 0xe6, 0xe9, 0x54, 0xeb, 0x21, 0x5e, 0x28, 0x1a, 0xdf, 0x01, 0xf3, 0xdc, 0xf7, 0x64, 0x64,
	0x49, 0x0a, 0xd2, 0xa7, 0x4b, 0xf0, 0x8f, 0x10, 0x7f, 0x10, 0xcb, 0x74, 0xc4, 0x2a, 0x3e, 0x2a,
	0xf2, 0x47, 0x38, 0xde, 0x9f, 0x2d, 0xad, 0xa8, 0x8d, 0xf8, 0x05, 0x45, 0xc4, 0xe7, 0x4d, 0x30,
	0x9e, 0xf9, 0x81, 0xb4, 0x86, 0xa4, 0xa7, 0xb6, 0x84, 0x9e, 0xc7, 0x7e, 0xb0, 0xa0, 0x86, 0xd8,
	0xf6, 0x11, 0xac, 0x2c, 0xfa, 0x89, 0x45, 0x91, 0x9c, 0x4e, 0x47, 0x27, 0xa1, 0xeb, 0x07, 0xe9,
	0x1d, 0xce, 0x37, 0xb0, 0x75, 0x84, 0xee, 0x48, 0x5d, 0x62, 0x59, 0xd0, 0x1a, 0x33, 0xea, 0x5b,
	0xdf, 0x4b, 0x4e, 0x29, 0xa3, 0x4c, 0xa1, 0x04, 0xd4, 0xbb, 0xe8, 0xf6, 0x0f, 0xa6, 0xf7, 0x21,
	0x54, 0x16, 0x8e, 0x31, 0x23, 0xea, 0x0b, 0x44, 0x0e, 0x86, 0x3f, 0x88, 0xc2, 0x4c, 0x19, 0xae,
	0xab, 0x6d, 0xcc, 0x4b, 0x8c, 0x63, 0x19, 0x4c, 0x67, 0xef, 0xa0, 0xff, 0x94, 0x69, 0x38, 0xb1,
	0x0e, 0x0f, 0x3a, 0xdd, 0x7a, 0xb3, 0xbd, 0xbf, 0xc3, 0x74, 0x9a, 0x42, 0xc2, 0x49, 0xc7, 0xd4,
	0x6d, 0xa8, 0x34, 0xbb, 0x4f, 0xf6, 0xb3, 0xaf, 0x94, 0xe2, 0xcd, 0xee, 0xbe, 0xc3, 0x8c, 0x46,
	0x19, 0x8a, 0x63, 0x65, 0xdd, 0x7e, 0x0e, 0x06, 0x3e, 0xc0, 0xe6, 0xdd, 0x53, 0x5f, 0xa2, 0x7b,
	0x22, 0xe3, 0xf2, 0xb4, 0xd9, 0xcc, 0x8a, 0x66, 0xc1, 0x39, 0x9c, 0x93, 0xf5, 0xde, 0xae, 0x9a,
	0x9f, 0xb3, 0x29, 0x98, 0xc3, 0x81, 0xd4, 0x73, 0xfa, 0x2c, 0x8f, 0x6e, 0xa4, 0xb9, 0x6d, 0x7f,
	0x0c, 0x26, 0x35, 0x09, 0x3c, 0xf9, 0xb3, 0x38, 0x1a, 0x91, 0x1b, 0xa6, 0xa0, 0x35, 0x3e, 0x6d,
	0x92, 0x88, 0xee, 0xc2, 0x14, 0xb9, 0x24, 0xb2, 0xff, 0x64, 0x40, 0x41, 0x3d, 0x44, 0xf8, 0x2f,
	0x67, 0xef, 0x15, 0xd5, 0xc0, 0x3e, 0xb8, 0xf2, 0xbd, 0x52, 0x7b, 0x4c, 0x18, 0x27, 0x4c, 0xe2,
	0x8b, 0xec, 0xed, 0x62, 0x1f, 0x61, 0x18, 0x66, 0xdb, 0x9c, 0x41, 0xfe, 0x4c, 0x5e, 0xa4, 0x51,
	0xc0, 0x25, 0x7f, 0x00, 0xe6, 0xb9, 0x1b, 0x4c, 0x55, 0x48, 0x5f, 0x1f, 0x64, 0xa9, 0xea, 0x23,
	0x84, 0x08, 0x85, 0x7c, 0x94, 0xfb, 0x5c, 0xb7, 0xff, 0x9c, 0x03, 0x93, 0x36, 0xf9, 0x57, 0x00,
	0xe1, 0x34, 0x08, 0x8e, 0x95, 0x16, 0x75, 0xb1, 0xef, 0x5f, 0xad, 0x65, 0x7f, 0x1a, 0x04, 0x44,
	0xc2, 0x77, 0x74, 0x98, 0x09, 0xfc, 0x43, 0x58, 0x51, 0xed, 0xe2, 0x78, 0xee, 0x89, 0xde, 0xd2,
	0x44, 0x45, 0xed, 0xce, 0x40, 0x93, 0x24, 0xf6, 0xc3, 0x61, 0x0a, 0xa2, 0xb6, 0x88, 0x20, 0xb5,
	0xab, 0x40, 0xef, 0x03, 0x9c, 0x44, 0x51, 0xe6, 0x0b, 0xcd, 0x25, 0x34, 0x85, 0x7b, 0x0a, 0xf0,
	0x88, 0xb4, 0x4c, 0x07, 0x49, 0x0a, 0x31, 0xaf, 0x79, 0xff, 0xa5, 0xca, 0xa7, 0x83, 0x64, 0x76,
	0xd0, 0xc0, 0x9f, 0x64, 0xcc, 0x02, 0x31, 0xdf, 0x70, 0x50, 0x1c, 0x92, 0xb3, 0x83, 0x06, 0x99,
	0xd0, 0x28, 0x80, 0x71, 0xe6, 0x87, 0x9e, 0xfd, 0x15, 0x94, 0x67, 0x08, 0xfc, 0x7b, 0x43, 0x1a,
	0xb3, 0xe0, 0x5e, 0x1b, 0x81, 0x14, 0x5a, 0x7d, 0x0f, 0xca, 0xb3, 0xcb, 0xe4, 0xab, 0x00, 0xfb,
	0x87, 0x9d, 0xce, 0xf1, 0x51, 0xbd, 0x73, 0xe8, 0x30, 0xcd, 0xfe, 0x8b, 0x0e, 0xc5, 0xfa, 0x60,
	0x10, 0x4d, 0xc3, 0xe4, 0xb5, 0x07, 0xf3, 0x55, 0x05, 0xfc, 0x10, 0x0a, 0xee, 0xb9, 0x9b, 0xb8,
	0x71, 0xfa, 0x22, 0xf8, 0xf1, 0x2b, 0x1e, 0xa4, 0xba, 0x6a, 0x75, 0x02, 0x89, 0x14, 0x6c, 0x7f,
	0x0d, 0x05, 0xb5, 0xc3, 0x3f, 0xc9, 0x5a, 0xe5, 0xd5, 0x83, 0x91, 0xfa, 0xcb, 0xbc, 0x1f, 0xbe,
	0x0b, 0xe6, 0x20, 0x0a, 0xa2, 0x58, 0xf9, 0x80, 0xfb, 0x24, 0x36, 0x4a, 0x99, 0x1b, 0xf6, 0x37,
	0x60, 0x12, 0xe7, 0x35, 0xef, 0x3f, 0x05, 0x73, 0xe2, 0x3f, 0x97, 0xea, 0xd5, 0xb5, 0xba, 0xf1,
	0xa3, 0xab, 0x0c, 0xd5, 0x7a, 0xfe, 0x73, 0xac, 0x58, 0xc4, 0x55, 0xef, 0x81, 0x81, 0x22, 0x16,
	0x6c, 0xa7, 0x2e, 0x76, 0x1c, 0xa6, 0xe1, 0xb2, 0xb7, 0x57, 0xef, 0x74, 0x98, 0x8e, 0xcb, 0x7e,
	0xeb, 0x70, 0xaf, 0xc1, 0x72, 0xf6, 0x1f, 0x75, 0x30, 0xa9, 0xbf, 0xfe, 0xbf, 0x36, 0x89, 0x74,
	0xc9, 0xe6, 0xd3, 0xd4, 0x66, 0x05, 0x8a, 0xbd, 0xe6, 0xf1, 0xe6, 0x2f, 0xd6, 0x71, 0xbe, 0x2a,
	0x61, 0xeb, 0xf3, 0xf5, 0xb1, 0xea, 0x60, 0xad, 0xe6, 0xf1, 0x67, 0x1b, 0xeb, 0x63, 0x96, 0xc3,
	0xb6, 0xd1, 0x6a, 0x1e, 0x3f, 0x58, 0xc7, 0x4f, 0x79, 0xea, 0x75, 0x28, 0x6e, 0x6d, 0xad, 0x8f,
	0x99, 0x91, 0x89, 0x1b, 0x0f, 0x50, 0x8b, 0xd9, 0xb8, 0xf3, 0xb7, 0x17, 0x6b, 0xfa, 0xf7, 0x2f,
	0xd6, 0xf4, 0x7f, 0xbf, 0x58, 0xd3, 0x7f, 0xf7, 0x72, 0x4d, 0xfb, 0xfe, 0xe5, 0x9a, 0xf6, 0xaf,
	0x97, 0x6b, 0xda, 0x6f, 0x72, 0xe3, 0x93, 0x93, 0x02, 0xfd, 0x99, 0xde, 0xfc, 0x5f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x9d, 0x24, 0xb1, 0x57, 0x5c, 0x0f, 0x00, 0x00,
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Children[iNdEx])
			copy(dAtA[i:], m.Children[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.Children[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Dashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Dashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Dataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Dataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Layout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Layout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Div) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Div) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Header_Permissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Header_Permissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Header_Permissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Layout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Layout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Layout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Div) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Div) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Div) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Dashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Dashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Dashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Dataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Dataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Dataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Text) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MarkerType != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MarkerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MarksList != nil {
		{
			size, err := m.MarksList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Text_Marks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Text_Marks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Text_Marks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Text_Mark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Text_Mark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Text_Mark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size := m.Preview.Size()
			i -= size
			if _, err := m.Preview.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Media_Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Content_Media_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Content_Media_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Content_Media_VideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Media_VideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_VideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Media_ImagePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Media_ImagePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_ImagePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Media_FilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Media_FilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Media_FilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Content_Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Content_Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Content_Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Struct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Struct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k := range m.Fields {
			v := m.Fields[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintModels(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModels(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Struct_Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Struct_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != nil {
		{
			size := m.Kind.Size()
			i -= size
			if _, err := m.Kind.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Struct_Value_NullValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_NullValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintModels(dAtA, i, uint64(m.NullValue))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Model_Struct_Value_NumberValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_NumberValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NumberValue))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *Model_Struct_Value_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintModels(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *Model_Struct_Value_BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Model_Struct_Value_StructValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_StructValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StructValue != nil {
		{
			size, err := m.StructValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Struct_Value_ListValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_Value_ListValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListValue != nil {
		{
			size, err := m.ListValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Model_Struct_ListValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Struct_ListValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Struct_ListValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Account_Avatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Account_Avatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Account_Avatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Account_Avatar_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Account_Avatar_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Model_Account_Avatar_Color) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Account_Avatar_Color) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Color)
	copy(dAtA[i:], m.Color)
	i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *Model_Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		dAtA22 := make([]byte, len(m.Sizes)*10)
		var j21 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintModels(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		dAtA24 := make([]byte, len(m.Sizes)*10)
		var j23 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintModels(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *Model_Block_Dashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Dataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Layout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Div) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_Header_Permissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *Model_Block_Content) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block_Content_Layout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *Model_Block_Content_Div) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block_Content_Dashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Block_Content_Dataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block_Content_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.MarksList != nil {
		l = m.MarksList.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.MarkerType != 0 {
		n += 1 + sovModels(uint64(m.MarkerType))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *Model_Block_Content_Text_Marks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Block_Content_Text_Mark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_Content_Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		n += m.Preview.Size()
	}
	return n
}

func (m *Model_Block_Content_Media_Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Content_Media_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Content_Media_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Content_Media_VideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *Model_Block_Content_Media_ImagePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *Model_Block_Content_Media_FilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_Content_Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *Model_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovModels(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovModels(uint64(m.To))
	}
	return n
}

func (m *Model_Struct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Model_Struct_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		n += m.Kind.Size()
	}
	return n
}

func (m *Model_Struct_Value_NullValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovModels(uint64(m.NullValue))
	return n
}
func (m *Model_Struct_Value_NumberValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Model_Struct_Value_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovModels(uint64(l))
	return n
}
func (m *Model_Struct_Value_BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Model_Struct_Value_StructValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StructValue != nil {
		l = m.StructValue.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Struct_Value_ListValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListValue != nil {
		l = m.ListValue.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Struct_ListValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Account_Avatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	return n
}

func (m *Model_Account_Avatar_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Account_Avatar_Color) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Color)
	n += 1 + l + sovModels(uint64(l))
	return n
}
func (m *Model_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func (m *Model_Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Model_Block_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Dashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Dashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Page{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Page{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Dataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Dataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Text{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Text{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Media{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Media{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Layout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Layout{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Div{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Div{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Model_Block_Header_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &Model_Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &Model_Block_Header_Permissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Header_Permissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Layout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_Content_Layout_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Div) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Div: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Div: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Dashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_Content_Dashboard_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Model_Block_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Dataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Text) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_Content_Text_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarksList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarksList == nil {
				m.MarksList = &Model_Block_Content_Text_Marks{}
			}
			if err := m.MarksList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerType", wireType)
			}
			m.MarkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkerType |= Model_Block_Content_Text_MarkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Text_Marks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &Model_Block_Content_Text_Mark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Text_Mark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Model_Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Model_Block_Content_Text_Mark_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Model_Block_Content_Media_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Media_VideoPreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_Content_Media_Video{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Media_ImagePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_Content_Media_Image{v}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_Content_Media_FilePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_Content_Media_File{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Media_VideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Media_ImagePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Media_FilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Content_Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_Content_Page_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Struct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Struct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Struct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]*Model_Struct_Value)
			}
			var mapkey string
			var mapvalue *Model_Struct_Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Model_Struct_Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Struct_Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullValue", wireType)
			}
			var v Model_Struct_NullValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Model_Struct_NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &Model_Struct_Value_NullValue{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Kind = &Model_Struct_Value_NumberValue{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &Model_Struct_Value_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Kind = &Model_Struct_Value_BoolValue{b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Struct{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Model_Struct_Value_StructValue{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Struct_ListValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Kind = &Model_Struct_Value_ListValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Struct_ListValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &Model_Struct_Value{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Model_Account_Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Account_Avatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Image{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Avatar = &Model_Account_Avatar_Image{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &Model_Account_Avatar_Color{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Model_Image_Size
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Model_Image_Size(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]Model_Image_Size, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Model_Image_Size
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Model_Image_Size(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Model_Video_Size
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Model_Video_Size(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]Model_Video_Size, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Model_Video_Size
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Model_Video_Size(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
