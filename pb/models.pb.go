// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Model_Block_Header_Type int32

const (
	Model_Block_Header_DASHBOARD Model_Block_Header_Type = 0
	Model_Block_Header_PAGE      Model_Block_Header_Type = 1
	Model_Block_Header_DATAVIEW  Model_Block_Header_Type = 2
	Model_Block_Header_TEXT      Model_Block_Header_Type = 3
	Model_Block_Header_FILE      Model_Block_Header_Type = 4
	Model_Block_Header_PICTURE   Model_Block_Header_Type = 5
	Model_Block_Header_VIDEO     Model_Block_Header_Type = 6
	Model_Block_Header_BOOKMARK  Model_Block_Header_Type = 7
	Model_Block_Header_LAYOUT    Model_Block_Header_Type = 8
	Model_Block_Header_DIV       Model_Block_Header_Type = 9
)

var Model_Block_Header_Type_name = map[int32]string{
	0: "DASHBOARD",
	1: "PAGE",
	2: "DATAVIEW",
	3: "TEXT",
	4: "FILE",
	5: "PICTURE",
	6: "VIDEO",
	7: "BOOKMARK",
	8: "LAYOUT",
	9: "DIV",
}

var Model_Block_Header_Type_value = map[string]int32{
	"DASHBOARD": 0,
	"PAGE":      1,
	"DATAVIEW":  2,
	"TEXT":      3,
	"FILE":      4,
	"PICTURE":   5,
	"VIDEO":     6,
	"BOOKMARK":  7,
	"LAYOUT":    8,
	"DIV":       9,
}

func (x Model_Block_Header_Type) String() string {
	return proto.EnumName(Model_Block_Header_Type_name, int32(x))
}

func (Model_Block_Header_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0, 0}
}

type Model_Block_ContentLayout_Style int32

const (
	Model_Block_ContentLayout_ROW    Model_Block_ContentLayout_Style = 0
	Model_Block_ContentLayout_COLUMN Model_Block_ContentLayout_Style = 1
)

var Model_Block_ContentLayout_Style_name = map[int32]string{
	0: "ROW",
	1: "COLUMN",
}

var Model_Block_ContentLayout_Style_value = map[string]int32{
	"ROW":    0,
	"COLUMN": 1,
}

func (x Model_Block_ContentLayout_Style) String() string {
	return proto.EnumName(Model_Block_ContentLayout_Style_name, int32(x))
}

func (Model_Block_ContentLayout_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1, 0}
}

type Model_Block_ContentDashboard_Style int32

const (
	Model_Block_ContentDashboard_MAIN_SCREEN Model_Block_ContentDashboard_Style = 0
)

var Model_Block_ContentDashboard_Style_name = map[int32]string{
	0: "MAIN_SCREEN",
}

var Model_Block_ContentDashboard_Style_value = map[string]int32{
	"MAIN_SCREEN": 0,
}

func (x Model_Block_ContentDashboard_Style) String() string {
	return proto.EnumName(Model_Block_ContentDashboard_Style_name, int32(x))
}

func (Model_Block_ContentDashboard_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 3, 0}
}

type Model_Block_ContentText_Style int32

const (
	Model_Block_ContentText_p     Model_Block_ContentText_Style = 0
	Model_Block_ContentText_h1    Model_Block_ContentText_Style = 1
	Model_Block_ContentText_h2    Model_Block_ContentText_Style = 2
	Model_Block_ContentText_h3    Model_Block_ContentText_Style = 3
	Model_Block_ContentText_h4    Model_Block_ContentText_Style = 4
	Model_Block_ContentText_quote Model_Block_ContentText_Style = 5
	Model_Block_ContentText_code  Model_Block_ContentText_Style = 6
)

var Model_Block_ContentText_Style_name = map[int32]string{
	0: "p",
	1: "h1",
	2: "h2",
	3: "h3",
	4: "h4",
	5: "quote",
	6: "code",
}

var Model_Block_ContentText_Style_value = map[string]int32{
	"p":     0,
	"h1":    1,
	"h2":    2,
	"h3":    3,
	"h4":    4,
	"quote": 5,
	"code":  6,
}

func (x Model_Block_ContentText_Style) String() string {
	return proto.EnumName(Model_Block_ContentText_Style_name, int32(x))
}

func (Model_Block_ContentText_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5, 0}
}

type Model_Block_ContentText_MarkerType int32

const (
	Model_Block_ContentText_none   Model_Block_ContentText_MarkerType = 0
	Model_Block_ContentText_number Model_Block_ContentText_MarkerType = 1
	Model_Block_ContentText_bullet Model_Block_ContentText_MarkerType = 2
)

var Model_Block_ContentText_MarkerType_name = map[int32]string{
	0: "none",
	1: "number",
	2: "bullet",
}

var Model_Block_ContentText_MarkerType_value = map[string]int32{
	"none":   0,
	"number": 1,
	"bullet": 2,
}

func (x Model_Block_ContentText_MarkerType) String() string {
	return proto.EnumName(Model_Block_ContentText_MarkerType_name, int32(x))
}

func (Model_Block_ContentText_MarkerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5, 1}
}

type Model_Block_ContentText_Mark_Type int32

const (
	Model_Block_ContentText_Mark_STRIKETHROUGH Model_Block_ContentText_Mark_Type = 0
	Model_Block_ContentText_Mark_KEYBOARD      Model_Block_ContentText_Mark_Type = 1
	Model_Block_ContentText_Mark_ITALIC        Model_Block_ContentText_Mark_Type = 2
	Model_Block_ContentText_Mark_BOLD          Model_Block_ContentText_Mark_Type = 3
	Model_Block_ContentText_Mark_LINK          Model_Block_ContentText_Mark_Type = 4
)

var Model_Block_ContentText_Mark_Type_name = map[int32]string{
	0: "STRIKETHROUGH",
	1: "KEYBOARD",
	2: "ITALIC",
	3: "BOLD",
	4: "LINK",
}

var Model_Block_ContentText_Mark_Type_value = map[string]int32{
	"STRIKETHROUGH": 0,
	"KEYBOARD":      1,
	"ITALIC":        2,
	"BOLD":          3,
	"LINK":          4,
}

func (x Model_Block_ContentText_Mark_Type) String() string {
	return proto.EnumName(Model_Block_ContentText_Mark_Type_name, int32(x))
}

func (Model_Block_ContentText_Mark_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5, 1, 0}
}

type Model_Block_ContentMedia_State int32

const (
	Model_Block_ContentMedia_EMPTY       Model_Block_ContentMedia_State = 0
	Model_Block_ContentMedia_UPLOADING   Model_Block_ContentMedia_State = 1
	Model_Block_ContentMedia_PREVIEW     Model_Block_ContentMedia_State = 2
	Model_Block_ContentMedia_DOWNLOADING Model_Block_ContentMedia_State = 3
	Model_Block_ContentMedia_DONE        Model_Block_ContentMedia_State = 4
)

var Model_Block_ContentMedia_State_name = map[int32]string{
	0: "EMPTY",
	1: "UPLOADING",
	2: "PREVIEW",
	3: "DOWNLOADING",
	4: "DONE",
}

var Model_Block_ContentMedia_State_value = map[string]int32{
	"EMPTY":       0,
	"UPLOADING":   1,
	"PREVIEW":     2,
	"DOWNLOADING": 3,
	"DONE":        4,
}

func (x Model_Block_ContentMedia_State) String() string {
	return proto.EnumName(Model_Block_ContentMedia_State_name, int32(x))
}

func (Model_Block_ContentMedia_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 6, 0}
}

type Model_Block_ContentPage_Style int32

const (
	Model_Block_ContentPage_EMPTY    Model_Block_ContentPage_Style = 0
	Model_Block_ContentPage_TASK     Model_Block_ContentPage_Style = 1
	Model_Block_ContentPage_BOOKMARK Model_Block_ContentPage_Style = 2
	Model_Block_ContentPage_SET      Model_Block_ContentPage_Style = 3
)

var Model_Block_ContentPage_Style_name = map[int32]string{
	0: "EMPTY",
	1: "TASK",
	2: "BOOKMARK",
	3: "SET",
}

var Model_Block_ContentPage_Style_value = map[string]int32{
	"EMPTY":    0,
	"TASK":     1,
	"BOOKMARK": 2,
	"SET":      3,
}

func (x Model_Block_ContentPage_Style) String() string {
	return proto.EnumName(Model_Block_ContentPage_Style_name, int32(x))
}

func (Model_Block_ContentPage_Style) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 7, 0}
}

type Model struct {
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0}
}
func (m *Model) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return m.Size()
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

type Model_Block struct {
	Header   *Model_Block_Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Children []string            `protobuf:"bytes,2,rep,name=children,proto3" json:"children,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*Model_Block_Dashboard
	//	*Model_Block_Page
	//	*Model_Block_Dataview
	//	*Model_Block_Text
	//	*Model_Block_Media
	//	*Model_Block_Layout
	//	*Model_Block_Div
	Content isModel_Block_Content `protobuf_oneof:"content"`
}

func (m *Model_Block) Reset()         { *m = Model_Block{} }
func (m *Model_Block) String() string { return proto.CompactTextString(m) }
func (*Model_Block) ProtoMessage()    {}
func (*Model_Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0}
}
func (m *Model_Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block.Merge(m, src)
}
func (m *Model_Block) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block proto.InternalMessageInfo

type isModel_Block_Content interface {
	isModel_Block_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Block_Dashboard struct {
	Dashboard *Model_Block_ContentDashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type Model_Block_Page struct {
	Page *Model_Block_ContentPage `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type Model_Block_Dataview struct {
	Dataview *Model_Block_ContentDataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type Model_Block_Text struct {
	Text *Model_Block_ContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type Model_Block_Media struct {
	Media *Model_Block_ContentMedia `protobuf:"bytes,15,opt,name=media,proto3,oneof" json:"media,omitempty"`
}
type Model_Block_Layout struct {
	Layout *Model_Block_ContentLayout `protobuf:"bytes,16,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type Model_Block_Div struct {
	Div *Model_Block_ContentDiv `protobuf:"bytes,17,opt,name=div,proto3,oneof" json:"div,omitempty"`
}

func (*Model_Block_Dashboard) isModel_Block_Content() {}
func (*Model_Block_Page) isModel_Block_Content()      {}
func (*Model_Block_Dataview) isModel_Block_Content()  {}
func (*Model_Block_Text) isModel_Block_Content()      {}
func (*Model_Block_Media) isModel_Block_Content()     {}
func (*Model_Block_Layout) isModel_Block_Content()    {}
func (*Model_Block_Div) isModel_Block_Content()       {}

func (m *Model_Block) GetContent() isModel_Block_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Model_Block) GetHeader() *Model_Block_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Model_Block) GetChildren() []string {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *Model_Block) GetDashboard() *Model_Block_ContentDashboard {
	if x, ok := m.GetContent().(*Model_Block_Dashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *Model_Block) GetPage() *Model_Block_ContentPage {
	if x, ok := m.GetContent().(*Model_Block_Page); ok {
		return x.Page
	}
	return nil
}

func (m *Model_Block) GetDataview() *Model_Block_ContentDataview {
	if x, ok := m.GetContent().(*Model_Block_Dataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *Model_Block) GetText() *Model_Block_ContentText {
	if x, ok := m.GetContent().(*Model_Block_Text); ok {
		return x.Text
	}
	return nil
}

func (m *Model_Block) GetMedia() *Model_Block_ContentMedia {
	if x, ok := m.GetContent().(*Model_Block_Media); ok {
		return x.Media
	}
	return nil
}

func (m *Model_Block) GetLayout() *Model_Block_ContentLayout {
	if x, ok := m.GetContent().(*Model_Block_Layout); ok {
		return x.Layout
	}
	return nil
}

func (m *Model_Block) GetDiv() *Model_Block_ContentDiv {
	if x, ok := m.GetContent().(*Model_Block_Div); ok {
		return x.Div
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Block) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Block_Dashboard)(nil),
		(*Model_Block_Page)(nil),
		(*Model_Block_Dataview)(nil),
		(*Model_Block_Text)(nil),
		(*Model_Block_Media)(nil),
		(*Model_Block_Layout)(nil),
		(*Model_Block_Div)(nil),
	}
}

type Model_Block_Header struct {
	Id          string                          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type        Model_Block_Header_Type         `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Model_Block_Header_Type" json:"type,omitempty"`
	Fields      *Struct                         `protobuf:"bytes,3,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *Model_Block_Header_Permissions `protobuf:"bytes,4,opt,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Model_Block_Header) Reset()         { *m = Model_Block_Header{} }
func (m *Model_Block_Header) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Header) ProtoMessage()    {}
func (*Model_Block_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0}
}
func (m *Model_Block_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Header.Merge(m, src)
}
func (m *Model_Block_Header) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Header proto.InternalMessageInfo

func (m *Model_Block_Header) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model_Block_Header) GetType() Model_Block_Header_Type {
	if m != nil {
		return m.Type
	}
	return Model_Block_Header_DASHBOARD
}

func (m *Model_Block_Header) GetFields() *Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Model_Block_Header) GetPermissions() *Model_Block_Header_Permissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type Model_Block_Header_Permissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *Model_Block_Header_Permissions) Reset()         { *m = Model_Block_Header_Permissions{} }
func (m *Model_Block_Header_Permissions) String() string { return proto.CompactTextString(m) }
func (*Model_Block_Header_Permissions) ProtoMessage()    {}
func (*Model_Block_Header_Permissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 0, 0}
}
func (m *Model_Block_Header_Permissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_Header_Permissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_Header_Permissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_Header_Permissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_Header_Permissions.Merge(m, src)
}
func (m *Model_Block_Header_Permissions) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_Header_Permissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_Header_Permissions.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_Header_Permissions proto.InternalMessageInfo

func (m *Model_Block_Header_Permissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *Model_Block_Header_Permissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type Model_Block_ContentLayout struct {
	Style Model_Block_ContentLayout_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_ContentLayout_Style" json:"style,omitempty"`
}

func (m *Model_Block_ContentLayout) Reset()         { *m = Model_Block_ContentLayout{} }
func (m *Model_Block_ContentLayout) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentLayout) ProtoMessage()    {}
func (*Model_Block_ContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 1}
}
func (m *Model_Block_ContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentLayout.Merge(m, src)
}
func (m *Model_Block_ContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentLayout proto.InternalMessageInfo

func (m *Model_Block_ContentLayout) GetStyle() Model_Block_ContentLayout_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_ContentLayout_ROW
}

type Model_Block_ContentDiv struct {
}

func (m *Model_Block_ContentDiv) Reset()         { *m = Model_Block_ContentDiv{} }
func (m *Model_Block_ContentDiv) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentDiv) ProtoMessage()    {}
func (*Model_Block_ContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 2}
}
func (m *Model_Block_ContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentDiv.Merge(m, src)
}
func (m *Model_Block_ContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentDiv proto.InternalMessageInfo

type Model_Block_ContentDashboard struct {
	Style   Model_Block_ContentDashboard_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_ContentDashboard_Style" json:"style,omitempty"`
	Headers []*Model_Block_Header              `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (m *Model_Block_ContentDashboard) Reset()         { *m = Model_Block_ContentDashboard{} }
func (m *Model_Block_ContentDashboard) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentDashboard) ProtoMessage()    {}
func (*Model_Block_ContentDashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 3}
}
func (m *Model_Block_ContentDashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentDashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentDashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentDashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentDashboard.Merge(m, src)
}
func (m *Model_Block_ContentDashboard) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentDashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentDashboard.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentDashboard proto.InternalMessageInfo

func (m *Model_Block_ContentDashboard) GetStyle() Model_Block_ContentDashboard_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_ContentDashboard_MAIN_SCREEN
}

func (m *Model_Block_ContentDashboard) GetHeaders() []*Model_Block_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

type Model_Block_ContentDataview struct {
}

func (m *Model_Block_ContentDataview) Reset()         { *m = Model_Block_ContentDataview{} }
func (m *Model_Block_ContentDataview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentDataview) ProtoMessage()    {}
func (*Model_Block_ContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 4}
}
func (m *Model_Block_ContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentDataview.Merge(m, src)
}
func (m *Model_Block_ContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentDataview proto.InternalMessageInfo

type Model_Block_ContentText struct {
	Text       string                             `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      Model_Block_ContentText_Style      `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.Model_Block_ContentText_Style" json:"style,omitempty"`
	MarksList  *Model_Block_ContentText_Marks     `protobuf:"bytes,3,opt,name=marksList,proto3" json:"marksList,omitempty"`
	Toggleable bool                               `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	MarkerType Model_Block_ContentText_MarkerType `protobuf:"varint,5,opt,name=markerType,proto3,enum=anytype.Model_Block_ContentText_MarkerType" json:"markerType,omitempty"`
	Checkable  bool                               `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                               `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *Model_Block_ContentText) Reset()         { *m = Model_Block_ContentText{} }
func (m *Model_Block_ContentText) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentText) ProtoMessage()    {}
func (*Model_Block_ContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5}
}
func (m *Model_Block_ContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentText.Merge(m, src)
}
func (m *Model_Block_ContentText) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentText.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentText proto.InternalMessageInfo

func (m *Model_Block_ContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Model_Block_ContentText) GetStyle() Model_Block_ContentText_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_ContentText_p
}

func (m *Model_Block_ContentText) GetMarksList() *Model_Block_ContentText_Marks {
	if m != nil {
		return m.MarksList
	}
	return nil
}

func (m *Model_Block_ContentText) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *Model_Block_ContentText) GetMarkerType() Model_Block_ContentText_MarkerType {
	if m != nil {
		return m.MarkerType
	}
	return Model_Block_ContentText_none
}

func (m *Model_Block_ContentText) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *Model_Block_ContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type Model_Block_ContentText_Marks struct {
	Marks []*Model_Block_ContentText_Mark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *Model_Block_ContentText_Marks) Reset()         { *m = Model_Block_ContentText_Marks{} }
func (m *Model_Block_ContentText_Marks) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentText_Marks) ProtoMessage()    {}
func (*Model_Block_ContentText_Marks) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5, 0}
}
func (m *Model_Block_ContentText_Marks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentText_Marks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentText_Marks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentText_Marks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentText_Marks.Merge(m, src)
}
func (m *Model_Block_ContentText_Marks) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentText_Marks) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentText_Marks.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentText_Marks proto.InternalMessageInfo

func (m *Model_Block_ContentText_Marks) GetMarks() []*Model_Block_ContentText_Mark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type Model_Block_ContentText_Mark struct {
	Range *Model_Range                      `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  Model_Block_ContentText_Mark_Type `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.Model_Block_ContentText_Mark_Type" json:"type,omitempty"`
	Param string                            `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *Model_Block_ContentText_Mark) Reset()         { *m = Model_Block_ContentText_Mark{} }
func (m *Model_Block_ContentText_Mark) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentText_Mark) ProtoMessage()    {}
func (*Model_Block_ContentText_Mark) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 5, 1}
}
func (m *Model_Block_ContentText_Mark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentText_Mark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentText_Mark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentText_Mark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentText_Mark.Merge(m, src)
}
func (m *Model_Block_ContentText_Mark) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentText_Mark) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentText_Mark.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentText_Mark proto.InternalMessageInfo

func (m *Model_Block_ContentText_Mark) GetRange() *Model_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Model_Block_ContentText_Mark) GetType() Model_Block_ContentText_Mark_Type {
	if m != nil {
		return m.Type
	}
	return Model_Block_ContentText_Mark_STRIKETHROUGH
}

func (m *Model_Block_ContentText_Mark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type Model_Block_ContentMedia struct {
	Content []byte                         `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	State   Model_Block_ContentMedia_State `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.Model_Block_ContentMedia_State" json:"state,omitempty"`
	// Types that are valid to be assigned to Preview:
	//	*Model_Block_ContentMedia_Video
	//	*Model_Block_ContentMedia_Image
	//	*Model_Block_ContentMedia_File
	Preview isModel_Block_ContentMedia_Preview `protobuf_oneof:"preview"`
}

func (m *Model_Block_ContentMedia) Reset()         { *m = Model_Block_ContentMedia{} }
func (m *Model_Block_ContentMedia) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentMedia) ProtoMessage()    {}
func (*Model_Block_ContentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 6}
}
func (m *Model_Block_ContentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentMedia.Merge(m, src)
}
func (m *Model_Block_ContentMedia) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentMedia proto.InternalMessageInfo

type isModel_Block_ContentMedia_Preview interface {
	isModel_Block_ContentMedia_Preview()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Model_Block_ContentMedia_Video struct {
	Video *Model_Block_ContentMedia_VideoPreview `protobuf:"bytes,101,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type Model_Block_ContentMedia_Image struct {
	Image *Model_Block_ContentMedia_ImagePreview `protobuf:"bytes,102,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type Model_Block_ContentMedia_File struct {
	File *Model_Block_ContentMedia_FilePreview `protobuf:"bytes,103,opt,name=file,proto3,oneof" json:"file,omitempty"`
}

func (*Model_Block_ContentMedia_Video) isModel_Block_ContentMedia_Preview() {}
func (*Model_Block_ContentMedia_Image) isModel_Block_ContentMedia_Preview() {}
func (*Model_Block_ContentMedia_File) isModel_Block_ContentMedia_Preview()  {}

func (m *Model_Block_ContentMedia) GetPreview() isModel_Block_ContentMedia_Preview {
	if m != nil {
		return m.Preview
	}
	return nil
}

func (m *Model_Block_ContentMedia) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Model_Block_ContentMedia) GetState() Model_Block_ContentMedia_State {
	if m != nil {
		return m.State
	}
	return Model_Block_ContentMedia_EMPTY
}

func (m *Model_Block_ContentMedia) GetVideo() *Model_Block_ContentMedia_VideoPreview {
	if x, ok := m.GetPreview().(*Model_Block_ContentMedia_Video); ok {
		return x.Video
	}
	return nil
}

func (m *Model_Block_ContentMedia) GetImage() *Model_Block_ContentMedia_ImagePreview {
	if x, ok := m.GetPreview().(*Model_Block_ContentMedia_Image); ok {
		return x.Image
	}
	return nil
}

func (m *Model_Block_ContentMedia) GetFile() *Model_Block_ContentMedia_FilePreview {
	if x, ok := m.GetPreview().(*Model_Block_ContentMedia_File); ok {
		return x.File
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Model_Block_ContentMedia) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Model_Block_ContentMedia_Video)(nil),
		(*Model_Block_ContentMedia_Image)(nil),
		(*Model_Block_ContentMedia_File)(nil),
	}
}

type Model_Block_ContentMedia_VideoPreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Model_Block_ContentMedia_VideoPreview) Reset()         { *m = Model_Block_ContentMedia_VideoPreview{} }
func (m *Model_Block_ContentMedia_VideoPreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentMedia_VideoPreview) ProtoMessage()    {}
func (*Model_Block_ContentMedia_VideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 6, 0}
}
func (m *Model_Block_ContentMedia_VideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentMedia_VideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentMedia_VideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentMedia_VideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentMedia_VideoPreview.Merge(m, src)
}
func (m *Model_Block_ContentMedia_VideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentMedia_VideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentMedia_VideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentMedia_VideoPreview proto.InternalMessageInfo

func (m *Model_Block_ContentMedia_VideoPreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Model_Block_ContentMedia_VideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_ContentMedia_VideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Model_Block_ContentMedia_ImagePreview struct {
	Thumbnail []byte `protobuf:"bytes,1,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Width     int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *Model_Block_ContentMedia_ImagePreview) Reset()         { *m = Model_Block_ContentMedia_ImagePreview{} }
func (m *Model_Block_ContentMedia_ImagePreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentMedia_ImagePreview) ProtoMessage()    {}
func (*Model_Block_ContentMedia_ImagePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 6, 1}
}
func (m *Model_Block_ContentMedia_ImagePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentMedia_ImagePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentMedia_ImagePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentMedia_ImagePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentMedia_ImagePreview.Merge(m, src)
}
func (m *Model_Block_ContentMedia_ImagePreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentMedia_ImagePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentMedia_ImagePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentMedia_ImagePreview proto.InternalMessageInfo

func (m *Model_Block_ContentMedia_ImagePreview) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *Model_Block_ContentMedia_ImagePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_ContentMedia_ImagePreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type Model_Block_ContentMedia_FilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *Model_Block_ContentMedia_FilePreview) Reset()         { *m = Model_Block_ContentMedia_FilePreview{} }
func (m *Model_Block_ContentMedia_FilePreview) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentMedia_FilePreview) ProtoMessage()    {}
func (*Model_Block_ContentMedia_FilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 6, 2}
}
func (m *Model_Block_ContentMedia_FilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentMedia_FilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentMedia_FilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentMedia_FilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentMedia_FilePreview.Merge(m, src)
}
func (m *Model_Block_ContentMedia_FilePreview) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentMedia_FilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentMedia_FilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentMedia_FilePreview proto.InternalMessageInfo

func (m *Model_Block_ContentMedia_FilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model_Block_ContentMedia_FilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type Model_Block_ContentPage struct {
	Style  Model_Block_ContentPage_Style `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.Model_Block_ContentPage_Style" json:"style,omitempty"`
	Blocks []*Model_Block                `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *Model_Block_ContentPage) Reset()         { *m = Model_Block_ContentPage{} }
func (m *Model_Block_ContentPage) String() string { return proto.CompactTextString(m) }
func (*Model_Block_ContentPage) ProtoMessage()    {}
func (*Model_Block_ContentPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 0, 7}
}
func (m *Model_Block_ContentPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Block_ContentPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Block_ContentPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Block_ContentPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Block_ContentPage.Merge(m, src)
}
func (m *Model_Block_ContentPage) XXX_Size() int {
	return m.Size()
}
func (m *Model_Block_ContentPage) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Block_ContentPage.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Block_ContentPage proto.InternalMessageInfo

func (m *Model_Block_ContentPage) GetStyle() Model_Block_ContentPage_Style {
	if m != nil {
		return m.Style
	}
	return Model_Block_ContentPage_EMPTY
}

func (m *Model_Block_ContentPage) GetBlocks() []*Model_Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type Model_Range struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *Model_Range) Reset()         { *m = Model_Range{} }
func (m *Model_Range) String() string { return proto.CompactTextString(m) }
func (*Model_Range) ProtoMessage()    {}
func (*Model_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0, 1}
}
func (m *Model_Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Model_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Model_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Model_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model_Range.Merge(m, src)
}
func (m *Model_Range) XXX_Size() int {
	return m.Size()
}
func (m *Model_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Model_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Model_Range proto.InternalMessageInfo

func (m *Model_Range) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Model_Range) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

func init() {
	proto.RegisterEnum("anytype.Model_Block_Header_Type", Model_Block_Header_Type_name, Model_Block_Header_Type_value)
	proto.RegisterEnum("anytype.Model_Block_ContentLayout_Style", Model_Block_ContentLayout_Style_name, Model_Block_ContentLayout_Style_value)
	proto.RegisterEnum("anytype.Model_Block_ContentDashboard_Style", Model_Block_ContentDashboard_Style_name, Model_Block_ContentDashboard_Style_value)
	proto.RegisterEnum("anytype.Model_Block_ContentText_Style", Model_Block_ContentText_Style_name, Model_Block_ContentText_Style_value)
	proto.RegisterEnum("anytype.Model_Block_ContentText_MarkerType", Model_Block_ContentText_MarkerType_name, Model_Block_ContentText_MarkerType_value)
	proto.RegisterEnum("anytype.Model_Block_ContentText_Mark_Type", Model_Block_ContentText_Mark_Type_name, Model_Block_ContentText_Mark_Type_value)
	proto.RegisterEnum("anytype.Model_Block_ContentMedia_State", Model_Block_ContentMedia_State_name, Model_Block_ContentMedia_State_value)
	proto.RegisterEnum("anytype.Model_Block_ContentPage_Style", Model_Block_ContentPage_Style_name, Model_Block_ContentPage_Style_value)
	proto.RegisterType((*Model)(nil), "anytype.Model")
	proto.RegisterType((*Model_Block)(nil), "anytype.Model.Block")
	proto.RegisterType((*Model_Block_Header)(nil), "anytype.Model.Block.Header")
	proto.RegisterType((*Model_Block_Header_Permissions)(nil), "anytype.Model.Block.Header.Permissions")
	proto.RegisterType((*Model_Block_ContentLayout)(nil), "anytype.Model.Block.ContentLayout")
	proto.RegisterType((*Model_Block_ContentDiv)(nil), "anytype.Model.Block.ContentDiv")
	proto.RegisterType((*Model_Block_ContentDashboard)(nil), "anytype.Model.Block.ContentDashboard")
	proto.RegisterType((*Model_Block_ContentDataview)(nil), "anytype.Model.Block.ContentDataview")
	proto.RegisterType((*Model_Block_ContentText)(nil), "anytype.Model.Block.ContentText")
	proto.RegisterType((*Model_Block_ContentText_Marks)(nil), "anytype.Model.Block.ContentText.Marks")
	proto.RegisterType((*Model_Block_ContentText_Mark)(nil), "anytype.Model.Block.ContentText.Mark")
	proto.RegisterType((*Model_Block_ContentMedia)(nil), "anytype.Model.Block.ContentMedia")
	proto.RegisterType((*Model_Block_ContentMedia_VideoPreview)(nil), "anytype.Model.Block.ContentMedia.VideoPreview")
	proto.RegisterType((*Model_Block_ContentMedia_ImagePreview)(nil), "anytype.Model.Block.ContentMedia.ImagePreview")
	proto.RegisterType((*Model_Block_ContentMedia_FilePreview)(nil), "anytype.Model.Block.ContentMedia.FilePreview")
	proto.RegisterType((*Model_Block_ContentPage)(nil), "anytype.Model.Block.ContentPage")
	proto.RegisterType((*Model_Range)(nil), "anytype.Model.Range")
}

func init() { proto.RegisterFile("models.proto", fileDescriptor_0b5431a010549573) }

var fileDescriptor_0b5431a010549573 = []byte{
	// 1274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x8f, 0xdb, 0x44,
	0x18, 0xb6, 0x13, 0x3b, 0x1f, 0x6f, 0xb2, 0xbb, 0xd3, 0x51, 0x55, 0x59, 0xa6, 0x0a, 0x4b, 0x44,
	0xe9, 0xaa, 0x85, 0x48, 0x74, 0x5b, 0x24, 0x44, 0xa9, 0x94, 0x0f, 0x77, 0x63, 0xe5, 0x53, 0x93,
	0xec, 0x96, 0x72, 0x41, 0x4e, 0x3c, 0x9b, 0x58, 0x4d, 0xec, 0xe0, 0x78, 0xb7, 0x5d, 0x89, 0x9f,
	0xc0, 0x81, 0x5f, 0xc1, 0x91, 0x3f, 0xc0, 0x91, 0x0b, 0xc7, 0x72, 0x83, 0x1b, 0x6a, 0x7f, 0x05,
	0x37, 0x34, 0xef, 0x38, 0x89, 0xb7, 0x2a, 0x9b, 0x3d, 0x70, 0xf2, 0xbc, 0x33, 0xcf, 0xf3, 0x7e,
	0xcc, 0xbc, 0x1f, 0x86, 0xe2, 0x3c, 0x70, 0xf9, 0x6c, 0x59, 0x59, 0x84, 0x41, 0x14, 0xd0, 0xac,
	0xe3, 0x5f, 0x44, 0x17, 0x0b, 0x6e, 0x16, 0x97, 0x51, 0x78, 0x36, 0x8e, 0xe4, 0x76, 0xf9, 0xb7,
	0x5b, 0xa0, 0x77, 0x04, 0xce, 0xfc, 0xf1, 0x16, 0xe8, 0xb5, 0x59, 0x30, 0x7e, 0x41, 0x0f, 0x21,
	0x33, 0xe5, 0x8e, 0xcb, 0x43, 0x43, 0xdd, 0x57, 0x0f, 0x0a, 0x0f, 0x3e, 0xa8, 0xc4, 0xdc, 0x0a,
	0x22, 0x2b, 0x88, 0xaa, 0x34, 0x11, 0xc2, 0x62, 0x28, 0x35, 0x21, 0x37, 0x9e, 0x7a, 0x33, 0x37,
	0xe4, 0xbe, 0x91, 0xda, 0x4f, 0x1f, 0xe4, 0xd9, 0x5a, 0xa6, 0x16, 0xe4, 0x5d, 0x67, 0x39, 0x1d,
	0x05, 0x4e, 0xe8, 0x1a, 0x05, 0xd4, 0x79, 0xe7, 0xbd, 0x3a, 0xeb, 0x81, 0x1f, 0x71, 0x3f, 0x6a,
	0xac, 0xc0, 0x4d, 0x85, 0x6d, 0x98, 0xf4, 0x0b, 0xd0, 0x16, 0xce, 0x84, 0x1b, 0x45, 0xd4, 0xb0,
	0x7f, 0x95, 0x86, 0xbe, 0x33, 0xe1, 0x4d, 0x85, 0x21, 0x9e, 0xd6, 0x20, 0xe7, 0x3a, 0x91, 0x73,
	0xee, 0xf1, 0x97, 0xc6, 0x0e, 0x72, 0x3f, 0xbe, 0xda, 0xba, 0xc4, 0x36, 0x15, 0xb6, 0xe6, 0x09,
	0xdb, 0x11, 0x7f, 0x15, 0x19, 0xbb, 0xdb, 0x6d, 0x0f, 0xf9, 0xab, 0x48, 0xd8, 0x16, 0x78, 0xfa,
	0x25, 0xe8, 0x73, 0xee, 0x7a, 0x8e, 0xb1, 0x87, 0xc4, 0x8f, 0xae, 0x22, 0x76, 0x04, 0xb0, 0xa9,
	0x30, 0xc9, 0xa0, 0x8f, 0x21, 0x33, 0x73, 0x2e, 0x82, 0xb3, 0xc8, 0x20, 0xc8, 0x2d, 0x5f, 0xc5,
	0x6d, 0x23, 0xb2, 0xa9, 0xb0, 0x98, 0x43, 0x0f, 0x21, 0xed, 0x7a, 0xe7, 0xc6, 0x0d, 0xa4, 0x7e,
	0x78, 0x65, 0xbc, 0xde, 0x79, 0x53, 0x61, 0x02, 0x6d, 0xfe, 0x9a, 0x86, 0x8c, 0x7c, 0x57, 0xba,
	0x0b, 0x29, 0xcf, 0xc5, 0x04, 0xc8, 0xb3, 0x94, 0xe7, 0xd2, 0x87, 0xa0, 0x09, 0x05, 0x46, 0x6a,
	0x5f, 0x3d, 0xd8, 0xfd, 0x8f, 0x0b, 0x90, 0xd4, 0xca, 0xf0, 0x62, 0xc1, 0x19, 0xa2, 0xe9, 0x5d,
	0xc8, 0x9c, 0x7a, 0x7c, 0xe6, 0x2e, 0x8d, 0x34, 0x3a, 0xb2, 0xb7, 0xe6, 0x0d, 0x30, 0x0b, 0x59,
	0x7c, 0x4c, 0x6d, 0x28, 0x2c, 0x78, 0x38, 0xf7, 0x96, 0x4b, 0x2f, 0xf0, 0x97, 0x86, 0x86, 0xe8,
	0xbb, 0x57, 0x59, 0xe9, 0x6f, 0xe0, 0x2c, 0xc9, 0x35, 0x2f, 0xa0, 0x90, 0x38, 0xa3, 0x14, 0xb4,
	0x90, 0x3b, 0x32, 0x94, 0x1c, 0xc3, 0xb5, 0xd8, 0xe3, 0xae, 0x17, 0x61, 0x30, 0x39, 0x86, 0x6b,
	0x7a, 0x0b, 0x32, 0x21, 0x9f, 0x07, 0xe7, 0x1c, 0x5d, 0xcd, 0xb1, 0x58, 0x12, 0x58, 0x37, 0x74,
	0x26, 0xe8, 0x52, 0x8e, 0xe1, 0x5a, 0x60, 0xdd, 0x30, 0x58, 0xf4, 0x7c, 0x43, 0x97, 0x58, 0x29,
	0x95, 0x7f, 0x00, 0x4d, 0x04, 0x4f, 0x77, 0x20, 0xdf, 0xa8, 0x0e, 0x9a, 0xb5, 0x5e, 0x95, 0x35,
	0x88, 0x42, 0x73, 0xa0, 0xf5, 0xab, 0x47, 0x16, 0x51, 0x69, 0x11, 0x72, 0x8d, 0xea, 0xb0, 0x7a,
	0x62, 0x5b, 0xcf, 0x48, 0x4a, 0xec, 0x0f, 0xad, 0x6f, 0x86, 0x24, 0x2d, 0x56, 0x4f, 0xed, 0xb6,
	0x45, 0x34, 0x5a, 0x80, 0x6c, 0xdf, 0xae, 0x0f, 0x8f, 0x99, 0x45, 0x74, 0x9a, 0x07, 0xfd, 0xc4,
	0x6e, 0x58, 0x3d, 0x92, 0x11, 0xcc, 0x5a, 0xaf, 0xd7, 0xea, 0x54, 0x59, 0x8b, 0x64, 0x29, 0x40,
	0xa6, 0x5d, 0x7d, 0xde, 0x3b, 0x1e, 0x92, 0x1c, 0xcd, 0x42, 0xba, 0x61, 0x9f, 0x90, 0xbc, 0x39,
	0x87, 0x9d, 0x4b, 0xd9, 0x40, 0x9f, 0x80, 0xbe, 0x8c, 0x2e, 0x66, 0x1c, 0x63, 0xdf, 0x7d, 0x70,
	0xb0, 0x3d, 0x81, 0x2a, 0x03, 0x81, 0x67, 0x92, 0x56, 0xbe, 0x0d, 0x3a, 0xca, 0xc2, 0x04, 0xeb,
	0x3d, 0x23, 0x8a, 0xb0, 0x5b, 0xef, 0xb5, 0x8f, 0x3b, 0x5d, 0xa2, 0x9a, 0x45, 0x80, 0x4d, 0x06,
	0x99, 0x3f, 0xab, 0x40, 0xde, 0x2d, 0x5f, 0x5a, 0xbd, 0xec, 0xc0, 0xfd, 0x6b, 0x15, 0xfd, 0x25,
	0x1f, 0xe8, 0x23, 0xc8, 0xca, 0x0e, 0xb3, 0xc4, 0xb6, 0xb2, 0xa5, 0x1b, 0xad, 0xb0, 0x65, 0x63,
	0xe5, 0xfa, 0x1e, 0x14, 0x3a, 0x55, 0xbb, 0xfb, 0xdd, 0xa0, 0xce, 0x2c, 0xab, 0x4b, 0x14, 0xf3,
	0x06, 0xec, 0xbd, 0x53, 0xe8, 0xe6, 0x5f, 0x3a, 0x14, 0x12, 0xc5, 0x2b, 0x9e, 0x1c, 0x8b, 0x5d,
	0x66, 0xbf, 0x2c, 0xe4, 0xc7, 0xab, 0x50, 0x64, 0x01, 0x7c, 0xb2, 0xad, 0x03, 0x5c, 0x8e, 0xa2,
	0x01, 0xf9, 0xb9, 0x13, 0xbe, 0x58, 0xb6, 0xbd, 0x65, 0x14, 0x97, 0xc2, 0x76, 0x0d, 0x1d, 0xc1,
	0x60, 0x1b, 0x22, 0x2d, 0x01, 0x44, 0xc1, 0x64, 0x32, 0xe3, 0xce, 0x68, 0xc6, 0xe3, 0x84, 0x4c,
	0xec, 0xd0, 0x16, 0x80, 0x00, 0xf3, 0x50, 0x24, 0x21, 0xa6, 0xe6, 0x96, 0x3b, 0x5f, 0x9b, 0x91,
	0x14, 0x96, 0xa0, 0xd3, 0xdb, 0x90, 0x1f, 0x4f, 0xf9, 0xf8, 0x05, 0xda, 0xca, 0xa0, 0xad, 0xcd,
	0x06, 0x35, 0x20, 0x8b, 0x02, 0x77, 0x8d, 0x2c, 0x9e, 0xad, 0x44, 0xb3, 0x01, 0x3a, 0x3a, 0x4e,
	0xbf, 0x02, 0x1d, 0x5d, 0x37, 0x54, 0x7c, 0xb7, 0x3b, 0xd7, 0x72, 0x84, 0x49, 0x8e, 0xf9, 0x87,
	0x0a, 0x9a, 0x90, 0xe9, 0x3d, 0xd0, 0x43, 0xc7, 0x9f, 0xf0, 0x78, 0x16, 0xdd, 0x7c, 0x47, 0x0b,
	0x13, 0x67, 0x4c, 0x42, 0xe8, 0x93, 0x4b, 0x3d, 0xea, 0xde, 0xb5, 0x0c, 0x26, 0xbb, 0xd5, 0x4d,
	0xd0, 0x17, 0x4e, 0xe8, 0xcc, 0xf1, 0x85, 0xf2, 0x4c, 0x0a, 0xe5, 0xa3, 0xb8, 0xa8, 0x6f, 0xc0,
	0xce, 0x60, 0xc8, 0xec, 0x96, 0x35, 0x6c, 0xb2, 0xde, 0xf1, 0x51, 0x93, 0x28, 0xa2, 0x28, 0x5b,
	0xd6, 0x73, 0x59, 0xe6, 0xaa, 0x28, 0x0e, 0x7b, 0x58, 0x6d, 0xdb, 0x75, 0x59, 0xda, 0xb5, 0x5e,
	0xbb, 0x21, 0x4b, 0xbb, 0x6d, 0x77, 0x5b, 0x44, 0x2b, 0xd7, 0x57, 0x39, 0xa9, 0x83, 0xba, 0x20,
	0x0a, 0xcd, 0x40, 0x6a, 0xfa, 0x39, 0x51, 0xf1, 0xfb, 0x80, 0xa4, 0xf0, 0x7b, 0x48, 0xd2, 0xf8,
	0x7d, 0x48, 0x34, 0x51, 0xfd, 0xdf, 0x9f, 0x05, 0x11, 0x27, 0xba, 0x50, 0x32, 0x0e, 0x5c, 0x4e,
	0x32, 0xe5, 0x0a, 0xc0, 0xe6, 0xc1, 0xc4, 0xbe, 0x1f, 0xf8, 0x5c, 0x56, 0xa6, 0x7f, 0x36, 0x1f,
	0xf1, 0x50, 0x3a, 0x32, 0x3a, 0x9b, 0xcd, 0x78, 0x44, 0x52, 0xe6, 0x3f, 0x1a, 0x14, 0x93, 0xf3,
	0x05, 0x5f, 0x4e, 0xca, 0x78, 0xa5, 0x45, 0xb6, 0x12, 0xe9, 0xd7, 0x22, 0xc5, 0x9d, 0x68, 0x75,
	0x7f, 0x77, 0xb7, 0xce, 0xaa, 0xca, 0x40, 0xc0, 0x99, 0x64, 0xd1, 0xa7, 0xa0, 0x9f, 0x7b, 0x2e,
	0x0f, 0x0c, 0x8e, 0x2f, 0x55, 0xd9, 0x4e, 0x3f, 0x11, 0xf0, 0x7e, 0xc8, 0xe3, 0x69, 0x2b, 0xe9,
	0x42, 0x8f, 0x37, 0x17, 0x73, 0xfe, 0xf4, 0xba, 0x7a, 0x6c, 0x01, 0x4f, 0xe8, 0x41, 0x3a, 0xad,
	0x83, 0x76, 0xea, 0xcd, 0xb8, 0x31, 0x41, 0x35, 0x9f, 0x6d, 0x57, 0xf3, 0xd4, 0x9b, 0x25, 0xb4,
	0x20, 0xd9, 0x3c, 0x81, 0x62, 0xd2, 0x4b, 0x51, 0x15, 0xd1, 0xf4, 0x6c, 0x3e, 0xf2, 0x1d, 0x6f,
	0x16, 0xdf, 0xdf, 0x66, 0x43, 0x34, 0x0e, 0xdf, 0x99, 0xcb, 0x0b, 0xcc, 0x33, 0x5c, 0x8b, 0xa4,
	0x7a, 0xe9, 0xb9, 0xd1, 0x14, 0x93, 0x4a, 0x67, 0x52, 0x10, 0x7a, 0x93, 0x5e, 0xff, 0x6f, 0x7a,
	0x1f, 0x41, 0x21, 0x11, 0xc6, 0x9a, 0xa8, 0x26, 0x88, 0x14, 0x34, 0x6f, 0x1c, 0xf8, 0x2b, 0x65,
	0x62, 0x5d, 0xb6, 0x45, 0x6a, 0x8a, 0x47, 0xcc, 0x83, 0x6e, 0x75, 0xfa, 0xc3, 0xe7, 0x44, 0x11,
	0x43, 0xec, 0xb8, 0xdf, 0xee, 0x55, 0x1b, 0x76, 0xf7, 0x88, 0xa8, 0x38, 0x98, 0x98, 0x15, 0x4f,
	0xae, 0x3d, 0x28, 0x34, 0x7a, 0xcf, 0xba, 0xab, 0x53, 0xcc, 0xf2, 0x46, 0xaf, 0x6b, 0x11, 0xad,
	0x96, 0x87, 0xec, 0x42, 0x5a, 0x37, 0x7f, 0x51, 0xd7, 0x7d, 0x55, 0xfc, 0x90, 0x6d, 0x7a, 0xa8,
	0xba, 0xbd, 0x87, 0x0a, 0xc2, 0xe5, 0x1e, 0xfa, 0x29, 0x64, 0x46, 0x02, 0xb1, 0x1a, 0x04, 0x37,
	0xdf, 0x47, 0x67, 0x31, 0xa6, 0x7c, 0xb8, 0x2a, 0xb6, 0x44, 0x44, 0x62, 0xde, 0x56, 0x07, 0x2d,
	0x39, 0x87, 0xd7, 0xd3, 0x34, 0x25, 0xc6, 0xdb, 0xc0, 0x1a, 0x92, 0xb4, 0xf0, 0x3d, 0x2e, 0x06,
	0xf3, 0x3e, 0xe8, 0xd8, 0x5b, 0xc4, 0x75, 0x9d, 0x86, 0xc1, 0x1c, 0x7d, 0xd6, 0x19, 0xae, 0xc5,
	0xcf, 0x51, 0x14, 0xe0, 0x05, 0xea, 0x2c, 0x15, 0x05, 0xb5, 0xdb, 0xbf, 0xbf, 0x29, 0xa9, 0xaf,
	0xdf, 0x94, 0xd4, 0xbf, 0xdf, 0x94, 0xd4, 0x9f, 0xde, 0x96, 0x94, 0xd7, 0x6f, 0x4b, 0xca, 0x9f,
	0x6f, 0x4b, 0xca, 0xb7, 0xa9, 0xc5, 0x68, 0x94, 0xc1, 0x5f, 0xed, 0xc3, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x0c, 0x3d, 0xcc, 0x16, 0x91, 0x0b, 0x00, 0x00,
}

func (m *Model) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Children[iNdEx])
			copy(dAtA[i:], m.Children[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.Children[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Dashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Dashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Page) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Page) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Dataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Dataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Text) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Text) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Layout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Layout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Div) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Div) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_Header_Permissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_Header_Permissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_Header_Permissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentDashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MarkerType != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.MarkerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MarksList != nil {
		{
			size, err := m.MarksList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentText_Marks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentText_Marks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentText_Marks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentText_Mark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentText_Mark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentText_Mark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size := m.Preview.Size()
			i -= size
			if _, err := m.Preview.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentMedia_Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_ContentMedia_Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_ContentMedia_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Model_Block_ContentMedia_VideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentMedia_VideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_VideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentMedia_ImagePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentMedia_ImagePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_ImagePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentMedia_FilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentMedia_FilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentMedia_FilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Model_Block_ContentPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Block_ContentPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Block_ContentPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Model_Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Model_Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Model_Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Model) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, s := range m.Children {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *Model_Block_Dashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Dataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Text) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Layout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Div) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_Header_Permissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *Model_Block_ContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *Model_Block_ContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block_ContentDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Block_ContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Model_Block_ContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.MarksList != nil {
		l = m.MarksList.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.MarkerType != 0 {
		n += 1 + sovModels(uint64(m.MarkerType))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *Model_Block_ContentText_Marks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Block_ContentText_Mark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_ContentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		n += m.Preview.Size()
	}
	return n
}

func (m *Model_Block_ContentMedia_Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_ContentMedia_Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_ContentMedia_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *Model_Block_ContentMedia_VideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *Model_Block_ContentMedia_ImagePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *Model_Block_ContentMedia_FilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *Model_Block_ContentPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *Model_Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovModels(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovModels(uint64(m.To))
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Model) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Model: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Model: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Model_Block_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentDashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Dashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentPage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Page{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Dataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Text{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentMedia{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Media{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Layout{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &Model_Block_Div{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Model_Block_Header_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &Model_Block_Header_Permissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_Header_Permissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentLayout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentLayout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_ContentLayout_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDiv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDiv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentDashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_ContentDashboard_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Model_Block_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentDataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentDataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_ContentText_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarksList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarksList == nil {
				m.MarksList = &Model_Block_ContentText_Marks{}
			}
			if err := m.MarksList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerType", wireType)
			}
			m.MarkerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarkerType |= Model_Block_ContentText_MarkerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentText_Marks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &Model_Block_ContentText_Mark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentText_Mark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Model_Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Model_Block_ContentText_Mark_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Model_Block_ContentMedia_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentMedia_VideoPreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_ContentMedia_Video{v}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentMedia_ImagePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_ContentMedia_Image{v}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Model_Block_ContentMedia_FilePreview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Preview = &Model_Block_ContentMedia_File{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentMedia_VideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentMedia_ImagePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImagePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImagePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentMedia_FilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilePreview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilePreview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Block_ContentPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= Model_Block_ContentPage_Style(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &Model_Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Model_Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
