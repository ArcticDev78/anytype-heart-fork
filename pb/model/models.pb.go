// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb/model/protos/models.proto

package model

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BlockPosition int32

const (
	Block_Before BlockPosition = 0
	Block_After  BlockPosition = 1
)

var BlockPosition_name = map[int32]string{
	0: "Before",
	1: "After",
}

var BlockPosition_value = map[string]int32{
	"Before": 0,
	"After":  1,
}

func (x BlockPosition) String() string {
	return proto.EnumName(BlockPosition_name, int32(x))
}

func (BlockPosition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 0}
}

type BlockContentLayoutStyle int32

const (
	BlockContentLayout_Row    BlockContentLayoutStyle = 0
	BlockContentLayout_Column BlockContentLayoutStyle = 1
)

var BlockContentLayoutStyle_name = map[int32]string{
	0: "Row",
	1: "Column",
}

var BlockContentLayoutStyle_value = map[string]int32{
	"Row":    0,
	"Column": 1,
}

func (x BlockContentLayoutStyle) String() string {
	return proto.EnumName(BlockContentLayoutStyle_name, int32(x))
}

func (BlockContentLayoutStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 0, 0}
}

type BlockContentDashboardStyle int32

const (
	BlockContentDashboard_MainScreen BlockContentDashboardStyle = 0
	BlockContentDashboard_Archive    BlockContentDashboardStyle = 1
)

var BlockContentDashboardStyle_name = map[int32]string{
	0: "MainScreen",
	1: "Archive",
}

var BlockContentDashboardStyle_value = map[string]int32{
	"MainScreen": 0,
	"Archive":    1,
}

func (x BlockContentDashboardStyle) String() string {
	return proto.EnumName(BlockContentDashboardStyle_name, int32(x))
}

func (BlockContentDashboardStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 5, 0}
}

type BlockContentTextStyle int32

const (
	BlockContentText_Paragraph BlockContentTextStyle = 0
	BlockContentText_Header1   BlockContentTextStyle = 1
	BlockContentText_Header2   BlockContentTextStyle = 2
	BlockContentText_Header3   BlockContentTextStyle = 3
	BlockContentText_Header4   BlockContentTextStyle = 4
	BlockContentText_Quote     BlockContentTextStyle = 5
	BlockContentText_Code      BlockContentTextStyle = 6
	BlockContentText_Title     BlockContentTextStyle = 7
)

var BlockContentTextStyle_name = map[int32]string{
	0: "Paragraph",
	1: "Header1",
	2: "Header2",
	3: "Header3",
	4: "Header4",
	5: "Quote",
	6: "Code",
	7: "Title",
}

var BlockContentTextStyle_value = map[string]int32{
	"Paragraph": 0,
	"Header1":   1,
	"Header2":   2,
	"Header3":   3,
	"Header4":   4,
	"Quote":     5,
	"Code":      6,
	"Title":     7,
}

func (x BlockContentTextStyle) String() string {
	return proto.EnumName(BlockContentTextStyle_name, int32(x))
}

func (BlockContentTextStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7, 0}
}

type BlockContentTextMarker int32

const (
	BlockContentText_None   BlockContentTextMarker = 0
	BlockContentText_Number BlockContentTextMarker = 1
	BlockContentText_Bullet BlockContentTextMarker = 2
)

var BlockContentTextMarker_name = map[int32]string{
	0: "None",
	1: "Number",
	2: "Bullet",
}

var BlockContentTextMarker_value = map[string]int32{
	"None":   0,
	"Number": 1,
	"Bullet": 2,
}

func (x BlockContentTextMarker) String() string {
	return proto.EnumName(BlockContentTextMarker_name, int32(x))
}

func (BlockContentTextMarker) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7, 1}
}

type BlockContentTextMarkType int32

const (
	BlockContentTextMark_Strikethrough   BlockContentTextMarkType = 0
	BlockContentTextMark_Keyboard        BlockContentTextMarkType = 1
	BlockContentTextMark_Italic          BlockContentTextMarkType = 2
	BlockContentTextMark_Bold            BlockContentTextMarkType = 3
	BlockContentTextMark_Underscored     BlockContentTextMarkType = 4
	BlockContentTextMark_Link            BlockContentTextMarkType = 5
	BlockContentTextMark_TextColor       BlockContentTextMarkType = 6
	BlockContentTextMark_BackgroundColor BlockContentTextMarkType = 7
)

var BlockContentTextMarkType_name = map[int32]string{
	0: "Strikethrough",
	1: "Keyboard",
	2: "Italic",
	3: "Bold",
	4: "Underscored",
	5: "Link",
	6: "TextColor",
	7: "BackgroundColor",
}

var BlockContentTextMarkType_value = map[string]int32{
	"Strikethrough":   0,
	"Keyboard":        1,
	"Italic":          2,
	"Bold":            3,
	"Underscored":     4,
	"Link":            5,
	"TextColor":       6,
	"BackgroundColor": 7,
}

func (x BlockContentTextMarkType) String() string {
	return proto.EnumName(BlockContentTextMarkType_name, int32(x))
}

func (BlockContentTextMarkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7, 1, 0}
}

type BlockContentVideoState int32

const (
	BlockContentVideo_Empty             BlockContentVideoState = 0
	BlockContentVideo_Uploading         BlockContentVideoState = 1
	BlockContentVideo_PreviewDownloaded BlockContentVideoState = 2
	BlockContentVideo_Downloading       BlockContentVideoState = 3
	BlockContentVideo_Done              BlockContentVideoState = 4
)

var BlockContentVideoState_name = map[int32]string{
	0: "Empty",
	1: "Uploading",
	2: "PreviewDownloaded",
	3: "Downloading",
	4: "Done",
}

var BlockContentVideoState_value = map[string]int32{
	"Empty":             0,
	"Uploading":         1,
	"PreviewDownloaded": 2,
	"Downloading":       3,
	"Done":              4,
}

func (x BlockContentVideoState) String() string {
	return proto.EnumName(BlockContentVideoState_name, int32(x))
}

func (BlockContentVideoState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 8, 0}
}

type BlockContentImageState int32

const (
	BlockContentImage_Empty             BlockContentImageState = 0
	BlockContentImage_Uploading         BlockContentImageState = 1
	BlockContentImage_PreviewDownloaded BlockContentImageState = 2
	BlockContentImage_Downloading       BlockContentImageState = 3
	BlockContentImage_Done              BlockContentImageState = 4
)

var BlockContentImageState_name = map[int32]string{
	0: "Empty",
	1: "Uploading",
	2: "PreviewDownloaded",
	3: "Downloading",
	4: "Done",
}

var BlockContentImageState_value = map[string]int32{
	"Empty":             0,
	"Uploading":         1,
	"PreviewDownloaded": 2,
	"Downloading":       3,
	"Done":              4,
}

func (x BlockContentImageState) String() string {
	return proto.EnumName(BlockContentImageState_name, int32(x))
}

func (BlockContentImageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 9, 0}
}

type BlockContentImageType int32

const (
	BlockContentImage_Png BlockContentImageType = 0
	BlockContentImage_Jpg BlockContentImageType = 1
)

var BlockContentImageType_name = map[int32]string{
	0: "Png",
	1: "Jpg",
}

var BlockContentImageType_value = map[string]int32{
	"Png": 0,
	"Jpg": 1,
}

func (x BlockContentImageType) String() string {
	return proto.EnumName(BlockContentImageType_name, int32(x))
}

func (BlockContentImageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 9, 1}
}

type BlockContentFileState int32

const (
	BlockContentFile_Empty             BlockContentFileState = 0
	BlockContentFile_Uploading         BlockContentFileState = 1
	BlockContentFile_PreviewDownloaded BlockContentFileState = 2
	BlockContentFile_Downloading       BlockContentFileState = 3
	BlockContentFile_Done              BlockContentFileState = 4
)

var BlockContentFileState_name = map[int32]string{
	0: "Empty",
	1: "Uploading",
	2: "PreviewDownloaded",
	3: "Downloading",
	4: "Done",
}

var BlockContentFileState_value = map[string]int32{
	"Empty":             0,
	"Uploading":         1,
	"PreviewDownloaded": 2,
	"Downloading":       3,
	"Done":              4,
}

func (x BlockContentFileState) String() string {
	return proto.EnumName(BlockContentFileState_name, int32(x))
}

func (BlockContentFileState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 10, 0}
}

type BlockContentPageStyle int32

const (
	BlockContentPage_Empty BlockContentPageStyle = 0
	BlockContentPage_Task  BlockContentPageStyle = 1
	BlockContentPage_Set   BlockContentPageStyle = 2
)

var BlockContentPageStyle_name = map[int32]string{
	0: "Empty",
	1: "Task",
	2: "Set",
}

var BlockContentPageStyle_value = map[string]int32{
	"Empty": 0,
	"Task":  1,
	"Set":   2,
}

func (x BlockContentPageStyle) String() string {
	return proto.EnumName(BlockContentPageStyle_name, int32(x))
}

func (BlockContentPageStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 11, 0}
}

type ImageSize int32

const (
	Image_Large ImageSize = 0
	Image_Small ImageSize = 1
	Image_Thumb ImageSize = 2
)

var ImageSize_name = map[int32]string{
	0: "Large",
	1: "Small",
	2: "Thumb",
}

var ImageSize_value = map[string]int32{
	"Large": 0,
	"Small": 1,
	"Thumb": 2,
}

func (x ImageSize) String() string {
	return proto.EnumName(ImageSize_name, int32(x))
}

func (ImageSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{3, 0}
}

type ImageStyle int32

const (
	Image_Picture ImageStyle = 0
	Image_File    ImageStyle = 1
)

var ImageStyle_name = map[int32]string{
	0: "Picture",
	1: "File",
}

var ImageStyle_value = map[string]int32{
	"Picture": 0,
	"File":    1,
}

func (x ImageStyle) String() string {
	return proto.EnumName(ImageStyle_name, int32(x))
}

func (ImageStyle) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{3, 1}
}

type VideoSize int32

const (
	Video_SD360p   VideoSize = 0
	Video_SD480p   VideoSize = 1
	Video_HD720p   VideoSize = 2
	Video_HD1080p  VideoSize = 3
	Video_UHD1440p VideoSize = 4
	Video_UHD2160p VideoSize = 5
)

var VideoSize_name = map[int32]string{
	0: "SD360p",
	1: "SD480p",
	2: "HD720p",
	3: "HD1080p",
	4: "UHD1440p",
	5: "UHD2160p",
}

var VideoSize_value = map[string]int32{
	"SD360p":   0,
	"SD480p":   1,
	"HD720p":   2,
	"HD1080p":  3,
	"UHD1440p": 4,
	"UHD2160p": 5,
}

func (x VideoSize) String() string {
	return proto.EnumName(VideoSize_name, int32(x))
}

func (VideoSize) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{4, 0}
}

type Block struct {
	Id          string             `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Fields      *types.Struct      `protobuf:"bytes,2,opt,name=fields,proto3" json:"fields,omitempty"`
	Permissions *BlockPermissions  `protobuf:"bytes,3,opt,name=permissions,proto3" json:"permissions,omitempty"`
	ChildrenIds []string           `protobuf:"bytes,4,rep,name=childrenIds,proto3" json:"childrenIds,omitempty"`
	IsArchived  bool               `protobuf:"varint,5,opt,name=isArchived,proto3" json:"isArchived,omitempty"`
	Content     *BlockBlockContent `protobuf:"bytes,6,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Block) GetFields() *types.Struct {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *Block) GetPermissions() *BlockPermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Block) GetChildrenIds() []string {
	if m != nil {
		return m.ChildrenIds
	}
	return nil
}

func (m *Block) GetIsArchived() bool {
	if m != nil {
		return m.IsArchived
	}
	return false
}

func (m *Block) GetContent() *BlockBlockContent {
	if m != nil {
		return m.Content
	}
	return nil
}

type BlockPermissions struct {
	Read   bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Edit   bool `protobuf:"varint,2,opt,name=edit,proto3" json:"edit,omitempty"`
	Remove bool `protobuf:"varint,3,opt,name=remove,proto3" json:"remove,omitempty"`
	Drag   bool `protobuf:"varint,4,opt,name=drag,proto3" json:"drag,omitempty"`
	DropOn bool `protobuf:"varint,5,opt,name=dropOn,proto3" json:"dropOn,omitempty"`
}

func (m *BlockPermissions) Reset()         { *m = BlockPermissions{} }
func (m *BlockPermissions) String() string { return proto.CompactTextString(m) }
func (*BlockPermissions) ProtoMessage()    {}
func (*BlockPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 0}
}
func (m *BlockPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockPermissions.Merge(m, src)
}
func (m *BlockPermissions) XXX_Size() int {
	return m.Size()
}
func (m *BlockPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_BlockPermissions proto.InternalMessageInfo

func (m *BlockPermissions) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *BlockPermissions) GetEdit() bool {
	if m != nil {
		return m.Edit
	}
	return false
}

func (m *BlockPermissions) GetRemove() bool {
	if m != nil {
		return m.Remove
	}
	return false
}

func (m *BlockPermissions) GetDrag() bool {
	if m != nil {
		return m.Drag
	}
	return false
}

func (m *BlockPermissions) GetDropOn() bool {
	if m != nil {
		return m.DropOn
	}
	return false
}

type BlockBlockContent struct {
	// Types that are valid to be assigned to Content:
	//	*BlockBlockContentContentOfDashboard
	//	*BlockBlockContentContentOfPage
	//	*BlockBlockContentContentOfDataview
	//	*BlockBlockContentContentOfText
	//	*BlockBlockContentContentOfVideo
	//	*BlockBlockContentContentOfImage
	//	*BlockBlockContentContentOfFile
	//	*BlockBlockContentContentOfLayout
	//	*BlockBlockContentContentOfDiv
	//	*BlockBlockContentContentOfBookmark
	//	*BlockBlockContentContentOfIcon
	//	*BlockBlockContentContentOfLink
	Content IsBlockBlockContentContent `protobuf_oneof:"content"`
}

func (m *BlockBlockContent) Reset()         { *m = BlockBlockContent{} }
func (m *BlockBlockContent) String() string { return proto.CompactTextString(m) }
func (*BlockBlockContent) ProtoMessage()    {}
func (*BlockBlockContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 1}
}
func (m *BlockBlockContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockBlockContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockBlockContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockBlockContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockBlockContent.Merge(m, src)
}
func (m *BlockBlockContent) XXX_Size() int {
	return m.Size()
}
func (m *BlockBlockContent) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockBlockContent.DiscardUnknown(m)
}

var xxx_messageInfo_BlockBlockContent proto.InternalMessageInfo

type IsBlockBlockContentContent interface {
	IsBlockBlockContentContent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BlockBlockContentContentOfDashboard struct {
	Dashboard *BlockContentDashboard `protobuf:"bytes,11,opt,name=dashboard,proto3,oneof" json:"dashboard,omitempty"`
}
type BlockBlockContentContentOfPage struct {
	Page *BlockContentPage `protobuf:"bytes,12,opt,name=page,proto3,oneof" json:"page,omitempty"`
}
type BlockBlockContentContentOfDataview struct {
	Dataview *BlockContentDataview `protobuf:"bytes,13,opt,name=dataview,proto3,oneof" json:"dataview,omitempty"`
}
type BlockBlockContentContentOfText struct {
	Text *BlockContentText `protobuf:"bytes,14,opt,name=text,proto3,oneof" json:"text,omitempty"`
}
type BlockBlockContentContentOfVideo struct {
	Video *BlockContentVideo `protobuf:"bytes,15,opt,name=video,proto3,oneof" json:"video,omitempty"`
}
type BlockBlockContentContentOfImage struct {
	Image *BlockContentImage `protobuf:"bytes,16,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type BlockBlockContentContentOfFile struct {
	File *BlockContentFile `protobuf:"bytes,17,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type BlockBlockContentContentOfLayout struct {
	Layout *BlockContentLayout `protobuf:"bytes,18,opt,name=layout,proto3,oneof" json:"layout,omitempty"`
}
type BlockBlockContentContentOfDiv struct {
	Div *BlockContentDiv `protobuf:"bytes,19,opt,name=div,proto3,oneof" json:"div,omitempty"`
}
type BlockBlockContentContentOfBookmark struct {
	Bookmark *BlockContentBookmark `protobuf:"bytes,20,opt,name=bookmark,proto3,oneof" json:"bookmark,omitempty"`
}
type BlockBlockContentContentOfIcon struct {
	Icon *BlockContentIcon `protobuf:"bytes,21,opt,name=icon,proto3,oneof" json:"icon,omitempty"`
}
type BlockBlockContentContentOfLink struct {
	Link *BlockContentLink `protobuf:"bytes,22,opt,name=link,proto3,oneof" json:"link,omitempty"`
}

func (*BlockBlockContentContentOfDashboard) IsBlockBlockContentContent() {}
func (*BlockBlockContentContentOfPage) IsBlockBlockContentContent()      {}
func (*BlockBlockContentContentOfDataview) IsBlockBlockContentContent()  {}
func (*BlockBlockContentContentOfText) IsBlockBlockContentContent()      {}
func (*BlockBlockContentContentOfVideo) IsBlockBlockContentContent()     {}
func (*BlockBlockContentContentOfImage) IsBlockBlockContentContent()     {}
func (*BlockBlockContentContentOfFile) IsBlockBlockContentContent()      {}
func (*BlockBlockContentContentOfLayout) IsBlockBlockContentContent()    {}
func (*BlockBlockContentContentOfDiv) IsBlockBlockContentContent()       {}
func (*BlockBlockContentContentOfBookmark) IsBlockBlockContentContent()  {}
func (*BlockBlockContentContentOfIcon) IsBlockBlockContentContent()      {}
func (*BlockBlockContentContentOfLink) IsBlockBlockContentContent()      {}

func (m *BlockBlockContent) GetContent() IsBlockBlockContentContent {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BlockBlockContent) GetDashboard() *BlockContentDashboard {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfDashboard); ok {
		return x.Dashboard
	}
	return nil
}

func (m *BlockBlockContent) GetPage() *BlockContentPage {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfPage); ok {
		return x.Page
	}
	return nil
}

func (m *BlockBlockContent) GetDataview() *BlockContentDataview {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfDataview); ok {
		return x.Dataview
	}
	return nil
}

func (m *BlockBlockContent) GetText() *BlockContentText {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfText); ok {
		return x.Text
	}
	return nil
}

func (m *BlockBlockContent) GetVideo() *BlockContentVideo {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfVideo); ok {
		return x.Video
	}
	return nil
}

func (m *BlockBlockContent) GetImage() *BlockContentImage {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *BlockBlockContent) GetFile() *BlockContentFile {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfFile); ok {
		return x.File
	}
	return nil
}

func (m *BlockBlockContent) GetLayout() *BlockContentLayout {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfLayout); ok {
		return x.Layout
	}
	return nil
}

func (m *BlockBlockContent) GetDiv() *BlockContentDiv {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfDiv); ok {
		return x.Div
	}
	return nil
}

func (m *BlockBlockContent) GetBookmark() *BlockContentBookmark {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfBookmark); ok {
		return x.Bookmark
	}
	return nil
}

func (m *BlockBlockContent) GetIcon() *BlockContentIcon {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfIcon); ok {
		return x.Icon
	}
	return nil
}

func (m *BlockBlockContent) GetLink() *BlockContentLink {
	if x, ok := m.GetContent().(*BlockBlockContentContentOfLink); ok {
		return x.Link
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BlockBlockContent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BlockBlockContentContentOfDashboard)(nil),
		(*BlockBlockContentContentOfPage)(nil),
		(*BlockBlockContentContentOfDataview)(nil),
		(*BlockBlockContentContentOfText)(nil),
		(*BlockBlockContentContentOfVideo)(nil),
		(*BlockBlockContentContentOfImage)(nil),
		(*BlockBlockContentContentOfFile)(nil),
		(*BlockBlockContentContentOfLayout)(nil),
		(*BlockBlockContentContentOfDiv)(nil),
		(*BlockBlockContentContentOfBookmark)(nil),
		(*BlockBlockContentContentOfIcon)(nil),
		(*BlockBlockContentContentOfLink)(nil),
	}
}

type BlockContent struct {
}

func (m *BlockContent) Reset()         { *m = BlockContent{} }
func (m *BlockContent) String() string { return proto.CompactTextString(m) }
func (*BlockContent) ProtoMessage()    {}
func (*BlockContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2}
}
func (m *BlockContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContent.Merge(m, src)
}
func (m *BlockContent) XXX_Size() int {
	return m.Size()
}
func (m *BlockContent) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContent.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContent proto.InternalMessageInfo

//
// Layout have no visual representation, but affects on blocks, that it contains.
// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
type BlockContentLayout struct {
	Style BlockContentLayoutStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.model.BlockContentLayoutStyle" json:"style,omitempty"`
}

func (m *BlockContentLayout) Reset()         { *m = BlockContentLayout{} }
func (m *BlockContentLayout) String() string { return proto.CompactTextString(m) }
func (*BlockContentLayout) ProtoMessage()    {}
func (*BlockContentLayout) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 0}
}
func (m *BlockContentLayout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentLayout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentLayout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentLayout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentLayout.Merge(m, src)
}
func (m *BlockContentLayout) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentLayout) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentLayout.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentLayout proto.InternalMessageInfo

func (m *BlockContentLayout) GetStyle() BlockContentLayoutStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentLayout_Row
}

//
// Link: block to link some content from an external sources.
type BlockContentLink struct {
	ContentId    string `protobuf:"bytes,1,opt,name=contentId,proto3" json:"contentId,omitempty"`
	IsLazyRender bool   `protobuf:"varint,2,opt,name=isLazyRender,proto3" json:"isLazyRender,omitempty"`
}

func (m *BlockContentLink) Reset()         { *m = BlockContentLink{} }
func (m *BlockContentLink) String() string { return proto.CompactTextString(m) }
func (*BlockContentLink) ProtoMessage()    {}
func (*BlockContentLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 1}
}
func (m *BlockContentLink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentLink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentLink.Merge(m, src)
}
func (m *BlockContentLink) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentLink) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentLink.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentLink proto.InternalMessageInfo

func (m *BlockContentLink) GetContentId() string {
	if m != nil {
		return m.ContentId
	}
	return ""
}

func (m *BlockContentLink) GetIsLazyRender() bool {
	if m != nil {
		return m.IsLazyRender
	}
	return false
}

//
// Divider: block, that contains only one horizontal thin line
type BlockContentDiv struct {
}

func (m *BlockContentDiv) Reset()         { *m = BlockContentDiv{} }
func (m *BlockContentDiv) String() string { return proto.CompactTextString(m) }
func (*BlockContentDiv) ProtoMessage()    {}
func (*BlockContentDiv) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 2}
}
func (m *BlockContentDiv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDiv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDiv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDiv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDiv.Merge(m, src)
}
func (m *BlockContentDiv) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDiv) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDiv.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDiv proto.InternalMessageInfo

//
// Bookmark is to keep a web-link and to preview a content.
type BlockContentBookmark struct {
}

func (m *BlockContentBookmark) Reset()         { *m = BlockContentBookmark{} }
func (m *BlockContentBookmark) String() string { return proto.CompactTextString(m) }
func (*BlockContentBookmark) ProtoMessage()    {}
func (*BlockContentBookmark) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 3}
}
func (m *BlockContentBookmark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentBookmark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentBookmark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentBookmark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentBookmark.Merge(m, src)
}
func (m *BlockContentBookmark) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentBookmark) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentBookmark.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentBookmark proto.InternalMessageInfo

type BlockContentIcon struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *BlockContentIcon) Reset()         { *m = BlockContentIcon{} }
func (m *BlockContentIcon) String() string { return proto.CompactTextString(m) }
func (*BlockContentIcon) ProtoMessage()    {}
func (*BlockContentIcon) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 4}
}
func (m *BlockContentIcon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentIcon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentIcon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentIcon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentIcon.Merge(m, src)
}
func (m *BlockContentIcon) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentIcon) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentIcon.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentIcon proto.InternalMessageInfo

func (m *BlockContentIcon) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//
// Block type to organize pages on the main screen (main purpose)
// It also can be mounted on a page.
type BlockContentDashboard struct {
	Style BlockContentDashboardStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.model.BlockContentDashboardStyle" json:"style,omitempty"`
}

func (m *BlockContentDashboard) Reset()         { *m = BlockContentDashboard{} }
func (m *BlockContentDashboard) String() string { return proto.CompactTextString(m) }
func (*BlockContentDashboard) ProtoMessage()    {}
func (*BlockContentDashboard) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 5}
}
func (m *BlockContentDashboard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDashboard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDashboard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDashboard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDashboard.Merge(m, src)
}
func (m *BlockContentDashboard) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDashboard) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDashboard.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDashboard proto.InternalMessageInfo

func (m *BlockContentDashboard) GetStyle() BlockContentDashboardStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentDashboard_MainScreen
}

type BlockContentDataview struct {
}

func (m *BlockContentDataview) Reset()         { *m = BlockContentDataview{} }
func (m *BlockContentDataview) String() string { return proto.CompactTextString(m) }
func (*BlockContentDataview) ProtoMessage()    {}
func (*BlockContentDataview) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 6}
}
func (m *BlockContentDataview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentDataview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentDataview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentDataview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentDataview.Merge(m, src)
}
func (m *BlockContentDataview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentDataview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentDataview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentDataview proto.InternalMessageInfo

type BlockContentText struct {
	Text       string                 `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Style      BlockContentTextStyle  `protobuf:"varint,2,opt,name=style,proto3,enum=anytype.model.BlockContentTextStyle" json:"style,omitempty"`
	Marks      *BlockContentTextMarks `protobuf:"bytes,3,opt,name=marks,proto3" json:"marks,omitempty"`
	Toggleable bool                   `protobuf:"varint,4,opt,name=toggleable,proto3" json:"toggleable,omitempty"`
	Marker     BlockContentTextMarker `protobuf:"varint,5,opt,name=marker,proto3,enum=anytype.model.BlockContentTextMarker" json:"marker,omitempty"`
	Checkable  bool                   `protobuf:"varint,6,opt,name=checkable,proto3" json:"checkable,omitempty"`
	Checked    bool                   `protobuf:"varint,7,opt,name=checked,proto3" json:"checked,omitempty"`
}

func (m *BlockContentText) Reset()         { *m = BlockContentText{} }
func (m *BlockContentText) String() string { return proto.CompactTextString(m) }
func (*BlockContentText) ProtoMessage()    {}
func (*BlockContentText) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7}
}
func (m *BlockContentText) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentText) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentText.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentText) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentText.Merge(m, src)
}
func (m *BlockContentText) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentText) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentText.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentText proto.InternalMessageInfo

func (m *BlockContentText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *BlockContentText) GetStyle() BlockContentTextStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentText_Paragraph
}

func (m *BlockContentText) GetMarks() *BlockContentTextMarks {
	if m != nil {
		return m.Marks
	}
	return nil
}

func (m *BlockContentText) GetToggleable() bool {
	if m != nil {
		return m.Toggleable
	}
	return false
}

func (m *BlockContentText) GetMarker() BlockContentTextMarker {
	if m != nil {
		return m.Marker
	}
	return BlockContentText_None
}

func (m *BlockContentText) GetCheckable() bool {
	if m != nil {
		return m.Checkable
	}
	return false
}

func (m *BlockContentText) GetChecked() bool {
	if m != nil {
		return m.Checked
	}
	return false
}

type BlockContentTextMarks struct {
	Marks []*BlockContentTextMark `protobuf:"bytes,1,rep,name=marks,proto3" json:"marks,omitempty"`
}

func (m *BlockContentTextMarks) Reset()         { *m = BlockContentTextMarks{} }
func (m *BlockContentTextMarks) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMarks) ProtoMessage()    {}
func (*BlockContentTextMarks) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7, 0}
}
func (m *BlockContentTextMarks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMarks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMarks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMarks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMarks.Merge(m, src)
}
func (m *BlockContentTextMarks) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMarks) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMarks.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMarks proto.InternalMessageInfo

func (m *BlockContentTextMarks) GetMarks() []*BlockContentTextMark {
	if m != nil {
		return m.Marks
	}
	return nil
}

type BlockContentTextMark struct {
	Range *Range                   `protobuf:"bytes,1,opt,name=range,proto3" json:"range,omitempty"`
	Type  BlockContentTextMarkType `protobuf:"varint,2,opt,name=type,proto3,enum=anytype.model.BlockContentTextMarkType" json:"type,omitempty"`
	Param string                   `protobuf:"bytes,3,opt,name=param,proto3" json:"param,omitempty"`
}

func (m *BlockContentTextMark) Reset()         { *m = BlockContentTextMark{} }
func (m *BlockContentTextMark) String() string { return proto.CompactTextString(m) }
func (*BlockContentTextMark) ProtoMessage()    {}
func (*BlockContentTextMark) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 7, 1}
}
func (m *BlockContentTextMark) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentTextMark) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentTextMark.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentTextMark) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentTextMark.Merge(m, src)
}
func (m *BlockContentTextMark) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentTextMark) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentTextMark.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentTextMark proto.InternalMessageInfo

func (m *BlockContentTextMark) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *BlockContentTextMark) GetType() BlockContentTextMarkType {
	if m != nil {
		return m.Type
	}
	return BlockContentTextMark_Strikethrough
}

func (m *BlockContentTextMark) GetParam() string {
	if m != nil {
		return m.Param
	}
	return ""
}

type BlockContentVideo struct {
	LocalFilePath string                    `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         BlockContentVideoState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.model.BlockContentVideoState" json:"state,omitempty"`
	Preview       *BlockContentVideoPreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *BlockContentVideo) Reset()         { *m = BlockContentVideo{} }
func (m *BlockContentVideo) String() string { return proto.CompactTextString(m) }
func (*BlockContentVideo) ProtoMessage()    {}
func (*BlockContentVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 8}
}
func (m *BlockContentVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentVideo.Merge(m, src)
}
func (m *BlockContentVideo) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentVideo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentVideo proto.InternalMessageInfo

func (m *BlockContentVideo) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentVideo) GetState() BlockContentVideoState {
	if m != nil {
		return m.State
	}
	return BlockContentVideo_Empty
}

func (m *BlockContentVideo) GetPreview() *BlockContentVideoPreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type BlockContentVideoPreview struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon  string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
	Width int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
}

func (m *BlockContentVideoPreview) Reset()         { *m = BlockContentVideoPreview{} }
func (m *BlockContentVideoPreview) String() string { return proto.CompactTextString(m) }
func (*BlockContentVideoPreview) ProtoMessage()    {}
func (*BlockContentVideoPreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 8, 0}
}
func (m *BlockContentVideoPreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentVideoPreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentVideoPreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentVideoPreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentVideoPreview.Merge(m, src)
}
func (m *BlockContentVideoPreview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentVideoPreview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentVideoPreview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentVideoPreview proto.InternalMessageInfo

func (m *BlockContentVideoPreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentVideoPreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *BlockContentVideoPreview) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

type BlockContentImage struct {
	LocalFilePath   string `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	PreviewFilePath string `protobuf:"bytes,2,opt,name=previewFilePath,proto3" json:"previewFilePath,omitempty"`
}

func (m *BlockContentImage) Reset()         { *m = BlockContentImage{} }
func (m *BlockContentImage) String() string { return proto.CompactTextString(m) }
func (*BlockContentImage) ProtoMessage()    {}
func (*BlockContentImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 9}
}
func (m *BlockContentImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentImage.Merge(m, src)
}
func (m *BlockContentImage) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentImage) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentImage.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentImage proto.InternalMessageInfo

func (m *BlockContentImage) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentImage) GetPreviewFilePath() string {
	if m != nil {
		return m.PreviewFilePath
	}
	return ""
}

type BlockContentFile struct {
	LocalFilePath string                   `protobuf:"bytes,1,opt,name=localFilePath,proto3" json:"localFilePath,omitempty"`
	State         BlockContentFileState    `protobuf:"varint,2,opt,name=state,proto3,enum=anytype.model.BlockContentFileState" json:"state,omitempty"`
	Preview       *BlockContentFilePreview `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
}

func (m *BlockContentFile) Reset()         { *m = BlockContentFile{} }
func (m *BlockContentFile) String() string { return proto.CompactTextString(m) }
func (*BlockContentFile) ProtoMessage()    {}
func (*BlockContentFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 10}
}
func (m *BlockContentFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFile.Merge(m, src)
}
func (m *BlockContentFile) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFile) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFile.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFile proto.InternalMessageInfo

func (m *BlockContentFile) GetLocalFilePath() string {
	if m != nil {
		return m.LocalFilePath
	}
	return ""
}

func (m *BlockContentFile) GetState() BlockContentFileState {
	if m != nil {
		return m.State
	}
	return BlockContentFile_Empty
}

func (m *BlockContentFile) GetPreview() *BlockContentFilePreview {
	if m != nil {
		return m.Preview
	}
	return nil
}

type BlockContentFilePreview struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,2,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *BlockContentFilePreview) Reset()         { *m = BlockContentFilePreview{} }
func (m *BlockContentFilePreview) String() string { return proto.CompactTextString(m) }
func (*BlockContentFilePreview) ProtoMessage()    {}
func (*BlockContentFilePreview) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 10, 0}
}
func (m *BlockContentFilePreview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentFilePreview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentFilePreview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentFilePreview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentFilePreview.Merge(m, src)
}
func (m *BlockContentFilePreview) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentFilePreview) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentFilePreview.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentFilePreview proto.InternalMessageInfo

func (m *BlockContentFilePreview) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockContentFilePreview) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type BlockContentPage struct {
	Style BlockContentPageStyle `protobuf:"varint,1,opt,name=style,proto3,enum=anytype.model.BlockContentPageStyle" json:"style,omitempty"`
}

func (m *BlockContentPage) Reset()         { *m = BlockContentPage{} }
func (m *BlockContentPage) String() string { return proto.CompactTextString(m) }
func (*BlockContentPage) ProtoMessage()    {}
func (*BlockContentPage) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{0, 2, 11}
}
func (m *BlockContentPage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockContentPage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockContentPage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockContentPage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockContentPage.Merge(m, src)
}
func (m *BlockContentPage) XXX_Size() int {
	return m.Size()
}
func (m *BlockContentPage) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockContentPage.DiscardUnknown(m)
}

var xxx_messageInfo_BlockContentPage proto.InternalMessageInfo

func (m *BlockContentPage) GetStyle() BlockContentPageStyle {
	if m != nil {
		return m.Style
	}
	return BlockContentPage_Empty
}

//
// General purpose structure, uses in Mark.
type Range struct {
	From int32 `protobuf:"varint,1,opt,name=from,proto3" json:"from,omitempty"`
	To   int32 `protobuf:"varint,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{1}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Range) GetTo() int32 {
	if m != nil {
		return m.To
	}
	return 0
}

//*
// Contains basic information about a user account
type Account struct {
	Id     string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name   string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Avatar *AccountAvatar `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{2}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Account) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Account) GetAvatar() *AccountAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

//*
// Avatar of a user's account. It could be an image or color
type AccountAvatar struct {
	// Types that are valid to be assigned to Avatar:
	//	*AccountAvatarAvatarOfImage
	//	*AccountAvatarAvatarOfColor
	Avatar IsAccountAvatarAvatar `protobuf_oneof:"avatar"`
}

func (m *AccountAvatar) Reset()         { *m = AccountAvatar{} }
func (m *AccountAvatar) String() string { return proto.CompactTextString(m) }
func (*AccountAvatar) ProtoMessage()    {}
func (*AccountAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{2, 0}
}
func (m *AccountAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountAvatar.Merge(m, src)
}
func (m *AccountAvatar) XXX_Size() int {
	return m.Size()
}
func (m *AccountAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_AccountAvatar proto.InternalMessageInfo

type IsAccountAvatarAvatar interface {
	IsAccountAvatarAvatar()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AccountAvatarAvatarOfImage struct {
	Image *Image `protobuf:"bytes,1,opt,name=image,proto3,oneof" json:"image,omitempty"`
}
type AccountAvatarAvatarOfColor struct {
	Color string `protobuf:"bytes,2,opt,name=color,proto3,oneof" json:"color,omitempty"`
}

func (*AccountAvatarAvatarOfImage) IsAccountAvatarAvatar() {}
func (*AccountAvatarAvatarOfColor) IsAccountAvatarAvatar() {}

func (m *AccountAvatar) GetAvatar() IsAccountAvatarAvatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *AccountAvatar) GetImage() *Image {
	if x, ok := m.GetAvatar().(*AccountAvatarAvatarOfImage); ok {
		return x.Image
	}
	return nil
}

func (m *AccountAvatar) GetColor() string {
	if x, ok := m.GetAvatar().(*AccountAvatarAvatarOfColor); ok {
		return x.Color
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AccountAvatar) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AccountAvatarAvatarOfImage)(nil),
		(*AccountAvatarAvatarOfColor)(nil),
	}
}

type Image struct {
	Id    string      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []ImageSize `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.model.ImageSize" json:"sizes,omitempty"`
	Style ImageStyle  `protobuf:"varint,3,opt,name=style,proto3,enum=anytype.model.ImageStyle" json:"style,omitempty"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{3}
}
func (m *Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return m.Size()
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Image) GetSizes() []ImageSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *Image) GetStyle() ImageStyle {
	if m != nil {
		return m.Style
	}
	return Image_Picture
}

type Video struct {
	Id    string      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Sizes []VideoSize `protobuf:"varint,2,rep,packed,name=sizes,proto3,enum=anytype.model.VideoSize" json:"sizes,omitempty"`
}

func (m *Video) Reset()         { *m = Video{} }
func (m *Video) String() string { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()    {}
func (*Video) Descriptor() ([]byte, []int) {
	return fileDescriptor_47d1277a02da26d7, []int{4}
}
func (m *Video) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Video) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Video.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Video) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Video.Merge(m, src)
}
func (m *Video) XXX_Size() int {
	return m.Size()
}
func (m *Video) XXX_DiscardUnknown() {
	xxx_messageInfo_Video.DiscardUnknown(m)
}

var xxx_messageInfo_Video proto.InternalMessageInfo

func (m *Video) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Video) GetSizes() []VideoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func init() {
	proto.RegisterEnum("anytype.model.BlockPosition", BlockPosition_name, BlockPosition_value)
	proto.RegisterEnum("anytype.model.BlockContentLayoutStyle", BlockContentLayoutStyle_name, BlockContentLayoutStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentDashboardStyle", BlockContentDashboardStyle_name, BlockContentDashboardStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentTextStyle", BlockContentTextStyle_name, BlockContentTextStyle_value)
	proto.RegisterEnum("anytype.model.BlockContentTextMarker", BlockContentTextMarker_name, BlockContentTextMarker_value)
	proto.RegisterEnum("anytype.model.BlockContentTextMarkType", BlockContentTextMarkType_name, BlockContentTextMarkType_value)
	proto.RegisterEnum("anytype.model.BlockContentVideoState", BlockContentVideoState_name, BlockContentVideoState_value)
	proto.RegisterEnum("anytype.model.BlockContentImageState", BlockContentImageState_name, BlockContentImageState_value)
	proto.RegisterEnum("anytype.model.BlockContentImageType", BlockContentImageType_name, BlockContentImageType_value)
	proto.RegisterEnum("anytype.model.BlockContentFileState", BlockContentFileState_name, BlockContentFileState_value)
	proto.RegisterEnum("anytype.model.BlockContentPageStyle", BlockContentPageStyle_name, BlockContentPageStyle_value)
	proto.RegisterEnum("anytype.model.ImageSize", ImageSize_name, ImageSize_value)
	proto.RegisterEnum("anytype.model.ImageStyle", ImageStyle_name, ImageStyle_value)
	proto.RegisterEnum("anytype.model.VideoSize", VideoSize_name, VideoSize_value)
	proto.RegisterType((*Block)(nil), "anytype.model.Block")
	proto.RegisterType((*BlockPermissions)(nil), "anytype.model.Block.Permissions")
	proto.RegisterType((*BlockBlockContent)(nil), "anytype.model.Block.BlockContent")
	proto.RegisterType((*BlockContent)(nil), "anytype.model.Block.Content")
	proto.RegisterType((*BlockContentLayout)(nil), "anytype.model.Block.Content.Layout")
	proto.RegisterType((*BlockContentLink)(nil), "anytype.model.Block.Content.Link")
	proto.RegisterType((*BlockContentDiv)(nil), "anytype.model.Block.Content.Div")
	proto.RegisterType((*BlockContentBookmark)(nil), "anytype.model.Block.Content.Bookmark")
	proto.RegisterType((*BlockContentIcon)(nil), "anytype.model.Block.Content.Icon")
	proto.RegisterType((*BlockContentDashboard)(nil), "anytype.model.Block.Content.Dashboard")
	proto.RegisterType((*BlockContentDataview)(nil), "anytype.model.Block.Content.Dataview")
	proto.RegisterType((*BlockContentText)(nil), "anytype.model.Block.Content.Text")
	proto.RegisterType((*BlockContentTextMarks)(nil), "anytype.model.Block.Content.Text.Marks")
	proto.RegisterType((*BlockContentTextMark)(nil), "anytype.model.Block.Content.Text.Mark")
	proto.RegisterType((*BlockContentVideo)(nil), "anytype.model.Block.Content.Video")
	proto.RegisterType((*BlockContentVideoPreview)(nil), "anytype.model.Block.Content.Video.Preview")
	proto.RegisterType((*BlockContentImage)(nil), "anytype.model.Block.Content.Image")
	proto.RegisterType((*BlockContentFile)(nil), "anytype.model.Block.Content.File")
	proto.RegisterType((*BlockContentFilePreview)(nil), "anytype.model.Block.Content.File.Preview")
	proto.RegisterType((*BlockContentPage)(nil), "anytype.model.Block.Content.Page")
	proto.RegisterType((*Range)(nil), "anytype.model.Range")
	proto.RegisterType((*Account)(nil), "anytype.model.Account")
	proto.RegisterType((*AccountAvatar)(nil), "anytype.model.Account.Avatar")
	proto.RegisterType((*Image)(nil), "anytype.model.Image")
	proto.RegisterType((*Video)(nil), "anytype.model.Video")
}

func init() { proto.RegisterFile("pb/model/protos/models.proto", fileDescriptor_47d1277a02da26d7) }

var fileDescriptor_47d1277a02da26d7 = []byte{
	// 1621 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcf, 0x93, 0x1b, 0x47,
	0x15, 0xd6, 0x48, 0x33, 0xfa, 0xf1, 0xe4, 0x5d, 0x8f, 0x3b, 0x8e, 0x99, 0x4c, 0x99, 0xad, 0x8d,
	0x48, 0xf0, 0xc6, 0x49, 0xb4, 0x3f, 0xbc, 0x10, 0x0a, 0x30, 0xc1, 0x5a, 0x25, 0x68, 0x83, 0x13,
	0x96, 0x91, 0x4d, 0x51, 0xdc, 0x5a, 0x33, 0xbd, 0xa3, 0x66, 0x47, 0xd3, 0x53, 0xad, 0xd6, 0x3a,
	0x72, 0x71, 0xe7, 0xca, 0x9d, 0xe2, 0xff, 0xe0, 0xc4, 0x85, 0x2a, 0x8a, 0x63, 0xe0, 0xc4, 0x91,
	0xb2, 0xff, 0x06, 0x38, 0xa7, 0x5e, 0x77, 0xcf, 0x4a, 0x5a, 0x6f, 0x79, 0x95, 0x43, 0x2e, 0xaa,
	0x79, 0x6f, 0xde, 0xd7, 0xfd, 0xbd, 0xf7, 0xfa, 0x7b, 0xad, 0x81, 0xbb, 0xc5, 0x68, 0x77, 0x22,
	0x12, 0x96, 0xed, 0x16, 0x52, 0x28, 0x31, 0x35, 0xc6, 0xb4, 0xab, 0x2d, 0xb2, 0x41, 0xf3, 0xb9,
	0x9a, 0x17, 0xac, 0xab, 0xbd, 0xe1, 0xdd, 0x54, 0x88, 0x34, 0x63, 0x26, 0x74, 0x34, 0x3b, 0xdd,
	0x9d, 0x2a, 0x39, 0x8b, 0x95, 0x09, 0xee, 0xfc, 0xff, 0x2d, 0xf0, 0x7a, 0x99, 0x88, 0xcf, 0xc8,
	0x26, 0x54, 0x79, 0x12, 0x38, 0xdb, 0xce, 0x4e, 0x2b, 0xaa, 0xf2, 0x84, 0xec, 0x42, 0xfd, 0x94,
	0xb3, 0x2c, 0x99, 0x06, 0xd5, 0x6d, 0x67, 0xa7, 0x7d, 0xf0, 0x9d, 0xae, 0x59, 0xa8, 0x5b, 0x2e,
	0xd4, 0x1d, 0xea, 0x85, 0x22, 0x1b, 0x46, 0x7a, 0xd0, 0x2e, 0x98, 0x9c, 0xf0, 0xe9, 0x94, 0x8b,
	0x7c, 0x1a, 0xd4, 0x34, 0x6a, 0xbb, 0xbb, 0xc2, 0xa6, 0xab, 0xf7, 0xea, 0x9e, 0x2c, 0xe2, 0xa2,
	0x65, 0x10, 0xd9, 0x86, 0x76, 0x3c, 0xe6, 0x59, 0x22, 0x59, 0x7e, 0x9c, 0x4c, 0x03, 0x77, 0xbb,
	0xb6, 0xd3, 0x8a, 0x96, 0x5d, 0x64, 0x0b, 0x80, 0x4f, 0x1f, 0xc9, 0x78, 0xcc, 0xcf, 0x59, 0x12,
	0x78, 0xdb, 0xce, 0x4e, 0x33, 0x5a, 0xf2, 0x90, 0x9f, 0x40, 0x23, 0x16, 0xb9, 0x62, 0xb9, 0x0a,
	0xea, 0x9a, 0xc1, 0xdb, 0x57, 0x32, 0xd0, 0xbf, 0x47, 0x26, 0x30, 0x2a, 0x11, 0xe1, 0x1c, 0xda,
	0x4b, 0xd4, 0x08, 0x01, 0x57, 0x32, 0x6a, 0x8a, 0xd2, 0x8c, 0xf4, 0x33, 0xfa, 0x58, 0xc2, 0x95,
	0x2e, 0x4a, 0x33, 0xd2, 0xcf, 0xe4, 0x0e, 0xd4, 0x25, 0x9b, 0x88, 0x73, 0xa6, 0x93, 0x6e, 0x46,
	0xd6, 0xc2, 0xd8, 0x44, 0xd2, 0x34, 0x70, 0x4d, 0x2c, 0x3e, 0x63, 0x6c, 0x22, 0x45, 0xf1, 0xab,
	0xdc, 0x72, 0xb7, 0x56, 0xf8, 0x3f, 0x0f, 0x6e, 0x2c, 0x93, 0x22, 0x9f, 0x42, 0x2b, 0xa1, 0xd3,
	0xf1, 0x48, 0x50, 0x99, 0x04, 0x6d, 0x9d, 0xca, 0xf7, 0xaf, 0x4c, 0xc5, 0x02, 0xba, 0xfd, 0x32,
	0x7a, 0x50, 0x89, 0x16, 0x50, 0xf2, 0x11, 0xb8, 0x05, 0x4d, 0x59, 0x70, 0xe3, 0x35, 0xd5, 0x28,
	0x97, 0x38, 0xa1, 0x29, 0x1b, 0x54, 0x22, 0x0d, 0x20, 0x47, 0xd0, 0x4c, 0xa8, 0xa2, 0xe7, 0x9c,
	0x3d, 0x0b, 0x36, 0x34, 0xf8, 0xdd, 0x6b, 0xf6, 0x37, 0xc1, 0x83, 0x4a, 0x74, 0x01, 0xc4, 0xdd,
	0x15, 0xfb, 0x52, 0x05, 0x9b, 0x6b, 0xec, 0xfe, 0x84, 0x7d, 0xa9, 0x70, 0x77, 0x04, 0x90, 0x1f,
	0x83, 0x77, 0xce, 0x13, 0x26, 0x82, 0x9b, 0x1a, 0xd9, 0x79, 0x2d, 0xf2, 0x37, 0x18, 0x39, 0xa8,
	0x44, 0x06, 0x82, 0x58, 0x3e, 0xc1, 0x9c, 0xfd, 0x35, 0xb0, 0xc7, 0x13, 0x93, 0xb4, 0x81, 0x20,
	0xe1, 0x53, 0x9e, 0xb1, 0xe0, 0xd6, 0x1a, 0x84, 0x3f, 0xe5, 0x99, 0x2e, 0x17, 0x02, 0xc8, 0x43,
	0xa8, 0x67, 0x74, 0x2e, 0x66, 0x2a, 0x20, 0x1a, 0xfa, 0xbd, 0xd7, 0x42, 0x1f, 0xeb, 0xd0, 0x41,
	0x25, 0xb2, 0x20, 0x72, 0x08, 0xb5, 0x84, 0x9f, 0x07, 0x6f, 0xbc, 0x46, 0x35, 0x17, 0x85, 0xe6,
	0xe7, 0x83, 0x4a, 0x84, 0xe1, 0xd8, 0xa3, 0x91, 0x10, 0x67, 0x13, 0x2a, 0xcf, 0x82, 0xdb, 0x6b,
	0xf4, 0xa8, 0x67, 0x83, 0xb1, 0x47, 0x25, 0x10, 0x53, 0xe6, 0xb1, 0xc8, 0x83, 0x37, 0xd7, 0x48,
	0xf9, 0x38, 0x16, 0x39, 0xa6, 0x8c, 0x00, 0x04, 0x66, 0x3c, 0x3f, 0x0b, 0xee, 0xac, 0x01, 0x7c,
	0xcc, 0x73, 0xdc, 0x55, 0x03, 0x7a, 0xad, 0x0b, 0x91, 0x86, 0xff, 0xf6, 0xa1, 0x61, 0x63, 0xc2,
	0x14, 0xea, 0xa6, 0x2e, 0xe4, 0x63, 0xf0, 0xa6, 0x6a, 0x9e, 0x31, 0x2d, 0xbd, 0xcd, 0x83, 0xf7,
	0xd6, 0xa8, 0x65, 0x77, 0x88, 0x80, 0xc8, 0xe0, 0x3a, 0x77, 0xc1, 0xd3, 0x36, 0x69, 0x40, 0x2d,
	0x12, 0xcf, 0xfc, 0x0a, 0x01, 0xa8, 0x1f, 0x89, 0x6c, 0x36, 0xc9, 0x7d, 0x27, 0x1c, 0x80, 0x8b,
	0x7c, 0xc8, 0x5d, 0x68, 0x59, 0x1e, 0xc7, 0xe5, 0xe8, 0x5b, 0x38, 0x48, 0x07, 0x6e, 0xf0, 0xe9,
	0x63, 0xfa, 0x7c, 0x1e, 0xb1, 0x3c, 0x61, 0xd2, 0x4a, 0x7e, 0xc5, 0x17, 0x7a, 0x50, 0xeb, 0xf3,
	0xf3, 0x10, 0xa0, 0x59, 0x96, 0x36, 0x0c, 0xc1, 0xc5, 0x2a, 0xa1, 0xfa, 0x73, 0x3a, 0x61, 0x76,
	0x5d, 0xfd, 0x1c, 0xce, 0xa0, 0x75, 0x21, 0x53, 0xd2, 0x5b, 0x4d, 0xf2, 0x83, 0xf5, 0xd4, 0xbd,
	0x9a, 0xe7, 0x3b, 0x65, 0x9e, 0x9b, 0x00, 0x9f, 0x53, 0x9e, 0x0f, 0x63, 0xc9, 0x58, 0xee, 0x57,
	0x48, 0x1b, 0x1a, 0x76, 0x26, 0xfa, 0x0e, 0xd2, 0x2b, 0xd5, 0x19, 0xfe, 0xb9, 0x0e, 0x2e, 0x2a,
	0x0d, 0xf9, 0x69, 0x69, 0x5a, 0x7e, 0x5a, 0x75, 0x0f, 0x4b, 0x4a, 0x55, 0x4d, 0xe9, 0xde, 0xb5,
	0x7a, 0x5d, 0x61, 0x83, 0x70, 0x2c, 0x41, 0x39, 0xfc, 0xd7, 0x80, 0x7f, 0x8e, 0xe1, 0x91, 0x41,
	0xe1, 0x6c, 0x57, 0x22, 0x4d, 0x33, 0x46, 0x47, 0x19, 0xb3, 0x53, 0x73, 0xc9, 0x43, 0x7e, 0x0e,
	0x75, 0x0c, 0x64, 0x52, 0xcf, 0xce, 0xcd, 0x83, 0x9d, 0xf5, 0xd6, 0x67, 0x32, 0xb2, 0x38, 0xdd,
	0xf0, 0x31, 0x8b, 0xcf, 0xf4, 0x06, 0x75, 0xbd, 0xc1, 0xc2, 0x41, 0x02, 0x68, 0x68, 0x83, 0x25,
	0x41, 0x43, 0xbf, 0x2b, 0xcd, 0xf0, 0x13, 0xf0, 0x34, 0x53, 0xf2, 0xd3, 0x32, 0x43, 0x67, 0xbb,
	0x76, 0xed, 0x44, 0xbe, 0x60, 0x60, 0x13, 0x0c, 0xff, 0x58, 0x05, 0x17, 0x6d, 0x72, 0x1f, 0x3c,
	0x49, 0xf3, 0xd4, 0xb4, 0xbe, 0x7d, 0x70, 0xfb, 0xd2, 0x32, 0x11, 0xbe, 0x8b, 0x4c, 0x08, 0xf9,
	0x18, 0x5c, 0x7c, 0x65, 0x5b, 0xf2, 0xfe, 0x7a, 0x3b, 0x76, 0x9f, 0xcc, 0x0b, 0x16, 0x69, 0x20,
	0xb9, 0x0d, 0x5e, 0x41, 0x25, 0x9d, 0xe8, 0xae, 0xb4, 0x22, 0x63, 0x74, 0xfe, 0x00, 0x2e, 0xc6,
	0x90, 0x5b, 0xb0, 0x31, 0x54, 0x92, 0x9f, 0x31, 0x35, 0x96, 0x62, 0x96, 0x8e, 0xfd, 0x0a, 0xb9,
	0x01, 0xcd, 0x5f, 0xb2, 0xb9, 0x3e, 0x6d, 0xbe, 0x83, 0xc2, 0x39, 0x56, 0x34, 0xe3, 0xb1, 0x5f,
	0x25, 0x4d, 0x70, 0x7b, 0x22, 0x4b, 0xfc, 0x1a, 0xb9, 0x09, 0xed, 0xa7, 0xa8, 0x80, 0x69, 0x2c,
	0x24, 0x4b, 0x7c, 0x17, 0x5f, 0xa1, 0xa6, 0x7c, 0x8f, 0x6c, 0x40, 0x0b, 0x79, 0x1c, 0x89, 0x4c,
	0x48, 0xbf, 0x4e, 0xde, 0x80, 0x9b, 0x3d, 0x1a, 0x9f, 0xa5, 0x52, 0xcc, 0xf2, 0xc4, 0x38, 0x1b,
	0x9d, 0xdf, 0x97, 0xe7, 0x76, 0x03, 0x5a, 0x27, 0x54, 0xd2, 0x54, 0xd2, 0x62, 0x6c, 0x8e, 0xed,
	0x80, 0xd1, 0x84, 0xc9, 0x7d, 0xdf, 0x59, 0x18, 0x07, 0x7e, 0x75, 0x61, 0x3c, 0xf0, 0x6b, 0x0b,
	0xe3, 0xd0, 0x77, 0x49, 0x0b, 0xbc, 0x5f, 0xcf, 0x84, 0x62, 0xbe, 0x87, 0x24, 0x8e, 0x44, 0xc2,
	0xfc, 0x3a, 0x3a, 0x9f, 0x70, 0x95, 0x31, 0xbf, 0xd1, 0xb9, 0x0f, 0x75, 0x73, 0x0c, 0xf0, 0xf5,
	0x17, 0x22, 0x67, 0x66, 0x1a, 0x7c, 0x31, 0x9b, 0x8c, 0x98, 0x34, 0x09, 0xf6, 0x66, 0x59, 0xc6,
	0x94, 0x5f, 0x0d, 0xff, 0x55, 0x05, 0x4f, 0xdf, 0x26, 0xe4, 0x1d, 0xd8, 0xc8, 0x44, 0x4c, 0x33,
	0x1c, 0xf2, 0x27, 0x54, 0x8d, 0xad, 0x4e, 0x56, 0x9d, 0xe4, 0x67, 0x28, 0x18, 0xaa, 0xca, 0xee,
	0xec, 0x5c, 0x7f, 0x4d, 0x75, 0x87, 0x18, 0x1f, 0x19, 0x18, 0xe9, 0x43, 0xa3, 0x90, 0x4c, 0xdf,
	0xb1, 0x46, 0x33, 0xf7, 0xd7, 0x58, 0xe1, 0xc4, 0x20, 0xa2, 0x12, 0x1a, 0xfe, 0x02, 0x1a, 0xd6,
	0x77, 0xd5, 0xd4, 0x41, 0x9f, 0x1e, 0xf0, 0x55, 0xe3, 0xd3, 0xb3, 0xfb, 0x36, 0x78, 0xcf, 0x78,
	0xa2, 0xc6, 0x7a, 0x5b, 0x2f, 0x32, 0x46, 0x67, 0x88, 0x6d, 0x41, 0x5e, 0x2d, 0xf0, 0x3e, 0x99,
	0x14, 0x6a, 0xee, 0x57, 0xb0, 0x43, 0x4f, 0x8b, 0x4c, 0xd0, 0x84, 0xe7, 0xa9, 0xef, 0x90, 0x37,
	0xe1, 0x96, 0xdd, 0xab, 0x2f, 0x9e, 0xe5, 0xe8, 0x67, 0x89, 0x5f, 0xc5, 0xf3, 0x50, 0xda, 0x18,
	0x57, 0xc3, 0x5a, 0xf7, 0xb1, 0xd6, 0x6e, 0xf8, 0x0f, 0x07, 0x3c, 0x7d, 0xcb, 0xae, 0x59, 0xd3,
	0x1d, 0xb8, 0x69, 0x13, 0xbb, 0x88, 0x33, 0xcc, 0x2f, 0xbb, 0xbf, 0x15, 0xba, 0x9d, 0xc0, 0x0a,
	0xa3, 0x01, 0xb5, 0x93, 0x3c, 0xf5, 0x2b, 0xf8, 0xf0, 0x59, 0x91, 0xfa, 0x4e, 0xf8, 0xd7, 0x2a,
	0xb8, 0xb8, 0xf7, 0x9a, 0x79, 0x3c, 0x5c, 0x3d, 0x1b, 0xf7, 0xae, 0xfd, 0x2f, 0xb1, 0x7a, 0x34,
	0x8e, 0x2e, 0x1f, 0x8d, 0xf7, 0xae, 0x5f, 0xe0, 0x95, 0x93, 0xb1, 0xff, 0x8d, 0x4f, 0xc6, 0xb7,
	0x73, 0x06, 0x32, 0x70, 0xf1, 0xcf, 0xe5, 0xe2, 0x82, 0x71, 0xd6, 0xa8, 0x09, 0x22, 0x56, 0xaf,
	0xbb, 0x77, 0xcb, 0xb1, 0xb1, 0xc4, 0xad, 0x09, 0xee, 0x13, 0x3a, 0x3d, 0xf3, 0x1d, 0x6c, 0xd4,
	0x10, 0x55, 0xdc, 0x79, 0x1b, 0x9a, 0x27, 0x62, 0xca, 0x15, 0x17, 0xb9, 0x56, 0x37, 0x3b, 0x15,
	0x12, 0x55, 0xdf, 0x02, 0xef, 0xd1, 0xa9, 0x42, 0xd1, 0x77, 0xde, 0x07, 0x4f, 0x4f, 0x59, 0x2c,
	0xc1, 0xa9, 0x14, 0x13, 0x4d, 0xc8, 0x8b, 0xf4, 0x33, 0x7e, 0x0b, 0x29, 0xa1, 0x8b, 0xe2, 0x45,
	0x55, 0x25, 0x3a, 0x7f, 0x73, 0xa0, 0xf1, 0x28, 0x8e, 0xc5, 0x2c, 0x57, 0xaf, 0x7c, 0x27, 0x95,
	0x65, 0xad, 0x2e, 0x95, 0xf5, 0x07, 0x50, 0xa7, 0xe7, 0x54, 0x51, 0x69, 0x3b, 0xf7, 0xdd, 0x4b,
	0x69, 0xda, 0xb5, 0xba, 0x8f, 0x74, 0x50, 0x64, 0x83, 0xc3, 0xdf, 0x42, 0xdd, 0x78, 0xc8, 0x07,
	0xe5, 0x3f, 0xd8, 0xab, 0xef, 0x87, 0x4b, 0xff, 0x59, 0xef, 0x80, 0x17, 0xe3, 0x5c, 0x35, 0x1c,
	0xd0, 0xaf, 0xcd, 0x5e, 0xb3, 0xa4, 0xd1, 0xf9, 0xfb, 0x85, 0x04, 0x5f, 0xfd, 0xcc, 0xf3, 0xa6,
	0xfc, 0x39, 0xc3, 0xaf, 0xbc, 0xda, 0xce, 0xe6, 0xc1, 0x5b, 0x57, 0xed, 0xd4, 0x1d, 0xf2, 0xe7,
	0xd8, 0x02, 0x8c, 0x23, 0x7b, 0x65, 0x07, 0x6b, 0xba, 0x83, 0xe1, 0xd5, 0x80, 0xe5, 0xa6, 0xdd,
	0x03, 0x17, 0x17, 0xc0, 0xea, 0x3f, 0xa6, 0x32, 0xb5, 0x8d, 0x18, 0x4e, 0x68, 0x96, 0xf9, 0x8e,
	0x1e, 0xd4, 0xe3, 0xd9, 0x64, 0xe4, 0x57, 0x3b, 0x5b, 0x65, 0x77, 0xdb, 0xd0, 0x38, 0xe1, 0xb1,
	0x9a, 0xe9, 0xa6, 0x35, 0x8d, 0xe8, 0x7c, 0xa7, 0xf3, 0x17, 0xa7, 0x1c, 0xce, 0xdf, 0x30, 0x0b,
	0x3b, 0x78, 0x17, 0x59, 0x74, 0x86, 0x96, 0x13, 0x40, 0x7d, 0xd8, 0x7f, 0xf0, 0xc3, 0xbd, 0xc2,
	0xdc, 0x09, 0xc3, 0xfe, 0xe1, 0x8f, 0xf6, 0x0a, 0x73, 0x27, 0x0c, 0xfa, 0x1f, 0x1d, 0xec, 0x15,
	0xf6, 0xe6, 0xe9, 0xef, 0xef, 0xe1, 0x8b, 0x1a, 0xde, 0x8d, 0x4f, 0x07, 0xfd, 0xfd, 0xc3, 0xc3,
	0xbd, 0xc2, 0x77, 0xad, 0x75, 0xb0, 0x8f, 0x0b, 0x78, 0xbd, 0xcf, 0xfe, 0xf9, 0x62, 0xcb, 0xf9,
	0xea, 0xc5, 0x96, 0xf3, 0xdf, 0x17, 0x5b, 0xce, 0x9f, 0x5e, 0x6e, 0x55, 0xbe, 0x7a, 0xb9, 0x55,
	0xf9, 0xcf, 0xcb, 0xad, 0xca, 0xef, 0xf6, 0x52, 0xae, 0xc6, 0xb3, 0x51, 0x37, 0x16, 0x93, 0x5d,
	0x4b, 0x8d, 0x8b, 0xdd, 0x54, 0x7c, 0x68, 0x8d, 0x0f, 0x33, 0x3e, 0x92, 0x54, 0xce, 0x77, 0xcb,
	0x2f, 0xfb, 0x51, 0x5d, 0x7f, 0x66, 0x3f, 0xf8, 0x3a, 0x00, 0x00, 0xff, 0xff, 0x00, 0x3d, 0x9f,
	0x67, 0xec, 0x0f, 0x00, 0x00,
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size, err := m.Content.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.IsArchived {
		i--
		if m.IsArchived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ChildrenIds) > 0 {
		for iNdEx := len(m.ChildrenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChildrenIds[iNdEx])
			copy(dAtA[i:], m.ChildrenIds[iNdEx])
			i = encodeVarintModels(dAtA, i, uint64(len(m.ChildrenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Permissions != nil {
		{
			size, err := m.Permissions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Fields != nil {
		{
			size, err := m.Fields.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DropOn {
		i--
		if m.DropOn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Drag {
		i--
		if m.Drag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Remove {
		i--
		if m.Remove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Edit {
		i--
		if m.Edit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Read {
		i--
		if m.Read {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockBlockContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockBlockContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		{
			size := m.Content.Size()
			i -= size
			if _, err := m.Content.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockBlockContentContentOfDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dashboard != nil {
		{
			size, err := m.Dashboard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Page != nil {
		{
			size, err := m.Page.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dataview != nil {
		{
			size, err := m.Dataview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Text != nil {
		{
			size, err := m.Text.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layout != nil {
		{
			size, err := m.Layout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Div != nil {
		{
			size, err := m.Div.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bookmark != nil {
		{
			size, err := m.Bookmark.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfIcon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfIcon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Icon != nil {
		{
			size, err := m.Icon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *BlockBlockContentContentOfLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockBlockContentContentOfLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *BlockContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentLayout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentLayout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentLayout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentLink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentLink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentLink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLazyRender {
		i--
		if m.IsLazyRender {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ContentId) > 0 {
		i -= len(m.ContentId)
		copy(dAtA[i:], m.ContentId)
		i = encodeVarintModels(dAtA, i, uint64(len(m.ContentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDiv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDiv) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDiv) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentBookmark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentBookmark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentBookmark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentIcon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentIcon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDashboard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDashboard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDashboard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentDataview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentDataview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentDataview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BlockContentText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentText) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentText) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Checked {
		i--
		if m.Checked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Checkable {
		i--
		if m.Checkable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Marker != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Marker))
		i--
		dAtA[i] = 0x28
	}
	if m.Toggleable {
		i--
		if m.Toggleable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Marks != nil {
		{
			size, err := m.Marks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMarks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMarks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMarks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for iNdEx := len(m.Marks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Marks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintModels(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentTextMark) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentTextMark) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentTextMark) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Param) > 0 {
		i -= len(m.Param)
		copy(dAtA[i:], m.Param)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Param)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentVideoPreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentVideoPreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentVideoPreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Width != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviewFilePath) > 0 {
		i -= len(m.PreviewFilePath)
		copy(dAtA[i:], m.PreviewFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.PreviewFilePath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		{
			size, err := m.Preview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalFilePath) > 0 {
		i -= len(m.LocalFilePath)
		copy(dAtA[i:], m.LocalFilePath)
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalFilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentFilePreview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentFilePreview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentFilePreview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockContentPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockContentPage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockContentPage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Range) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x10
	}
	if m.From != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size := m.Avatar.Size()
			i -= size
			if _, err := m.Avatar.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountAvatarAvatarOfImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatarAvatarOfImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintModels(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AccountAvatarAvatarOfColor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountAvatarAvatarOfColor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Color)
	copy(dAtA[i:], m.Color)
	i = encodeVarintModels(dAtA, i, uint64(len(m.Color)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Style != 0 {
		i = encodeVarintModels(dAtA, i, uint64(m.Style))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sizes) > 0 {
		dAtA23 := make([]byte, len(m.Sizes)*10)
		var j22 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintModels(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Video) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Video) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Video) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		dAtA25 := make([]byte, len(m.Sizes)*10)
		var j24 int
		for _, num := range m.Sizes {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintModels(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	offset -= sovModels(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.ChildrenIds) > 0 {
		for _, s := range m.ChildrenIds {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.IsArchived {
		n += 2
	}
	if m.Content != nil {
		l = m.Content.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Edit {
		n += 2
	}
	if m.Remove {
		n += 2
	}
	if m.Drag {
		n += 2
	}
	if m.DropOn {
		n += 2
	}
	return n
}

func (m *BlockBlockContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *BlockBlockContentContentOfDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dashboard != nil {
		l = m.Dashboard.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dataview != nil {
		l = m.Dataview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layout != nil {
		l = m.Layout.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Div != nil {
		l = m.Div.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bookmark != nil {
		l = m.Bookmark.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Icon != nil {
		l = m.Icon.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockBlockContentContentOfLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 2 + l + sovModels(uint64(l))
	}
	return n
}
func (m *BlockContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentLayout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *BlockContentLink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.IsLazyRender {
		n += 2
	}
	return n
}

func (m *BlockContentDiv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentBookmark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentIcon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentDashboard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *BlockContentDataview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BlockContentText) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	if m.Marks != nil {
		l = m.Marks.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Toggleable {
		n += 2
	}
	if m.Marker != 0 {
		n += 1 + sovModels(uint64(m.Marker))
	}
	if m.Checkable {
		n += 2
	}
	if m.Checked {
		n += 2
	}
	return n
}

func (m *BlockContentTextMarks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Marks) > 0 {
		for _, e := range m.Marks {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	return n
}

func (m *BlockContentTextMark) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovModels(uint64(m.Type))
	}
	l = len(m.Param)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentVideoPreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovModels(uint64(m.Width))
	}
	return n
}

func (m *BlockContentImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.PreviewFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalFilePath)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovModels(uint64(m.State))
	}
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentFilePreview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *BlockContentPage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != 0 {
		n += 1 + sovModels(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovModels(uint64(m.To))
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}

func (m *AccountAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avatar != nil {
		n += m.Avatar.Size()
	}
	return n
}

func (m *AccountAvatarAvatarOfImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	return n
}
func (m *AccountAvatarAvatarOfColor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Color)
	n += 1 + l + sovModels(uint64(l))
	return n
}
func (m *Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	if m.Style != 0 {
		n += 1 + sovModels(uint64(m.Style))
	}
	return n
}

func (m *Video) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Sizes) > 0 {
		l = 0
		for _, e := range m.Sizes {
			l += sovModels(uint64(e))
		}
		n += 1 + sovModels(uint64(l)) + l
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &types.Struct{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &BlockPermissions{}
			}
			if err := m.Permissions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildrenIds = append(m.ChildrenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArchived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArchived = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Content == nil {
				m.Content = &BlockBlockContent{}
			}
			if err := m.Content.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Edit = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remove = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Drag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropOn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropOn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockBlockContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dashboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDashboard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfDashboard{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentPage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfPage{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDataview{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfDataview{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentText{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfText{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentVideo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfVideo{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentImage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfImage{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfFile{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentLayout{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfLayout{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Div", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentDiv{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfDiv{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bookmark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentBookmark{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfBookmark{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentIcon{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfIcon{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockContentLink{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &BlockBlockContentContentOfLink{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentLayout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentLayoutStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentLink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLazyRender", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLazyRender = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDiv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Div: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Div: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentBookmark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bookmark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bookmark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Icon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Icon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDashboard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dashboard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dashboard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentDashboardStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentDataview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dataview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dataview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Text: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Text: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentTextStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Marks == nil {
				m.Marks = &BlockContentTextMarks{}
			}
			if err := m.Marks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toggleable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Toggleable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marker", wireType)
			}
			m.Marker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Marker |= BlockContentTextMarker(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkable = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checked = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMarks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Marks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Marks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Marks = append(m.Marks, &BlockContentTextMark{})
			if err := m.Marks[len(m.Marks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentTextMark) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mark: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mark: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= BlockContentTextMarkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Param = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentVideoState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &BlockContentVideoPreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentVideoPreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalFilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalFilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= BlockContentFileState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &BlockContentFilePreview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentFilePreview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockContentPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= BlockContentPageStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &AccountAvatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Image{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Avatar = &AccountAvatarAvatarOfImage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = &AccountAvatarAvatarOfColor{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v ImageSize
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ImageSize(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]ImageSize, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ImageSize
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ImageSize(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Style", wireType)
			}
			m.Style = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Style |= ImageStyle(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Video) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Video: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Video: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v VideoSize
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= VideoSize(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sizes = append(m.Sizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthModels
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthModels
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Sizes) == 0 {
					m.Sizes = make([]VideoSize, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v VideoSize
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= VideoSize(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sizes = append(m.Sizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModels
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModels
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModels        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModels = fmt.Errorf("proto: unexpected end of group")
)
